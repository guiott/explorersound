 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
                        .area data(ram, con, rel)
 0000                   .dbfile ./main.c
 0000           _TmrFlag::
 0000 00                .byte 0
 0001                   .dbfile D:\PROGRA~1\PSOCPR~1\EXPLOR~1\EXPLOR~1\definitions.h
 0001                   .dbsym e TmrFlag _TmrFlag c
                        .area data(ram, con, rel)
 0000                   .dbfile D:\PROGRA~1\PSOCPR~1\EXPLOR~1\EXPLOR~1\definitions.h
                        .area data(ram, con, rel)
 0000                   .dbfile D:\PROGRA~1\PSOCPR~1\EXPLOR~1\EXPLOR~1\definitions.h
 0000           _GF::
 0000 0000              .byte 0,0
 0002 F801              .byte 248,1
 0004 7802              .byte 'x,2
 0006 3804              .byte 56,4
 0008 1808              .byte 24,8
 000A 0810              .byte 8,16
 000C 1C18              .byte 28,24
 000E 0C30              .byte 12,48
 0010                   .dbsym e GF _GF A[16:8:2]c
                        .area data(ram, con, rel)
 0000                   .dbfile D:\PROGRA~1\PSOCPR~1\EXPLOR~1\EXPLOR~1\definitions.h
                        .area data(ram, con, rel)
 0000                   .dbfile D:\PROGRA~1\PSOCPR~1\EXPLOR~1\EXPLOR~1\definitions.h
 0000           _GainIndx::
 0000 0404              .byte 4,4
 0002 0404              .byte 4,4
 0004 0404              .byte 4,4
 0006                   .dbsym e GainIndx _GainIndx A[6:3:2]c
                        .area data(ram, con, rel)
 0000                   .dbfile D:\PROGRA~1\PSOCPR~1\EXPLOR~1\EXPLOR~1\definitions.h
                        .area text(rom, con, rel)
 0000                   .dbfile D:\PROGRA~1\PSOCPR~1\EXPLOR~1\EXPLOR~1\definitions.h
 0000                   .dbfile D:\PROGRA~1\PSOCPR~1\EXPLOR~1\EXPLOR~1\main.c
 0000                   .dbfunc e main _main fV
 0000           ;        PortNum -> X+1
 0000           ;       PortIndx -> X+0
 0000           _main::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 3804              add SP,4
 0004                   .dbline 38
 0004           ; /* ////////////////////////////////////////////////////////////////////////////
 0004           ; ** Project:      ExplorerSound
 0004           ; ** Author:    Guido Ottaviani-->guido@guiott.com<--
 0004           ; ** Description: 
 0004           ; ** version 0.3   15-09-2010
 0004           ; **
 0004           ; ** Detailed descriptions are on file "Notes.txt" 
 0004           ; **
 0004           ; -------------------------------------------------------------------------------
 0004           ; Copyright 2010 Guido Ottaviani
 0004           ; guido@guiott.com
 0004           ; 
 0004           ;       ExplorerSound is free software: you can redistribute it and/or modify
 0004           ;     it under the terms of the GNU General Public License as published by
 0004           ;     the Free Software Foundation, either version 3 of the License, or
 0004           ;     (at your option) any later version.
 0004           ; 
 0004           ;     ExplorerSound is distributed in the hope that it will be useful,
 0004           ;     but WITHOUT ANY WARRANTY; without even the implied warranty of
 0004           ;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 0004           ;     GNU General Public License for more details.
 0004           ; 
 0004           ;     You should have received a copy of the GNU General Public License
 0004           ;     along with ExplorerSound.  If not, see <http://www.gnu.org/licenses/>.
 0004           ; -------------------------------------------------------------------------------      
 0004           ; /////////////////////////////////////////////////////////////////////////////*/
 0004           ; 
 0004           ; #include <m8c.h>        // part specific constants and macros
 0004           ; #include <stdlib.h>
 0004           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0004           ; #include "prototypes.h"
 0004           ; #include "definitions.h"
 0004           ; #include "delay.h"
 0004           ; 
 0004           ; #pragma interrupt_handler HB_Tmr_ISR_C // int handler for program clock
 0004           ; 
 0004           ; void main(void)
 0004           ; {
 0004                   .dbline 40
 0004           ;       BYTE PortNum[3];
 0004           ;       BYTE PortIndx = 0;
 0004 560000            mov [X+0],0
 0007                   .dbline 42
 0007           ;       
 0007           ;       BlocksInit();
 0007 938B              xcall _BlocksInit
 0009                   .dbline 44
 0009           ;       
 0009           ;       M8C_EnableGInt ;               // Turn on interrupts 
 0009 7101                      or  F, 01h
 000B           
 000B                   .dbline 46
 000B           ;       
 000B           ;       LED_2_On();
 000B 10                push X
 000C 7C0000            xcall _LED_2_On
 000F 20                pop X
 0010                   .dbline 47
 0010           ;       PortNum[0] = AMUX4_mic_PORT0_1;
 0010 560100            mov [X+1],0
 0013                   .dbline 48
 0013           ;       PortNum[1] = AMUX4_mic_PORT0_3;
 0013 560201            mov [X+2],1
 0016                   .dbline 49
 0016           ;       PortNum[2] = AMUX4_mic_PORT0_7;
 0016 560303            mov [X+3],3
 0019                   .dbline 51
 0019           ;       
 0019           ;       LedTest();
 0019 9425              xcall _LedTest
 001B 81C4              xjmp L5
 001D           L4:
 001D                   .dbline 55
 001D           ;       
 001D           ;       // Main loop=============================================================
 001D           ;       while (1)
 001D           ;       {
 001D                   .dbline 56
 001D           ;               if(ADCINCVR_pot_fIsDataAvailable() != 0)// Wait for data to be ready
 001D 10                push X
 001E 7C0000            xcall _ADCINCVR_pot_fIsDataAvailable
 0021 62D000            mov REG[0xd0],>__r0
 0024 20                pop X
 0025 3900              cmp A,0
 0027 A13F              jz L7
 0029                   .dbline 57
 0029           ;         {   
 0029                   .dbline 59
 0029           ;                       // Get Data, Clear data ready flag, in the range 0-1800
 0029           ;                       PotValue = ADCINCVR_pot_iGetDataClearFlag()+900;
 0029 10                push X
 002A 7C0000            xcall _ADCINCVR_pot_iGetDataClearFlag
 002D 62D000            mov REG[0xd0],>__r0
 0030 5A00              mov [__r0],X
 0032 20                pop X
 0033 0184              add A,-124
 0035 62D000            mov REG[0xd0],>_PotValue
 0038 5301              mov [_PotValue+1],A
 003A 62D000            mov REG[0xd0],>__r0
 003D 5100              mov A,[__r0]
 003F 0903              adc A,3
 0041 62D000            mov REG[0xd0],>_PotValue
 0044 5300              mov [_PotValue],A
 0046                   .dbline 62
 0046           ;                       
 0046           ;                       // ??????????????? DEBUG ??????????????
 0046           ;                       if (PotValue < 200)     GainIndx[1][0] = 0;
 0046 5101              mov A,[_PotValue+1]
 0048 11C8              sub A,-56
 004A 5100              mov A,[_PotValue]
 004C 3180              xor A,-128
 004E 1980              sbb A,(0 ^ 0x80)
 0050 D007              jnc L9
 0052           X1:
 0052                   .dbline 62
 0052 62D000            mov REG[0xd0],>_GainIndx
 0055 550200            mov [_GainIndx+2],0
 0058           L9:
 0058                   .dbline 63
 0058           ;                       if (PotValue >= 200 && PotValue < 400)  GainIndx[1][0] = 1;
 0058 62D000            mov REG[0xd0],>_PotValue
 005B 5101              mov A,[_PotValue+1]
 005D 11C8              sub A,-56
 005F 5100              mov A,[_PotValue]
 0061 3180              xor A,-128
 0063 1980              sbb A,(0 ^ 0x80)
 0065 C016              jc L12
 0067           X2:
 0067 62D000            mov REG[0xd0],>_PotValue
 006A 5101              mov A,[_PotValue+1]
 006C 1190              sub A,-112
 006E 5100              mov A,[_PotValue]
 0070 3180              xor A,-128
 0072 1981              sbb A,(1 ^ 0x80)
 0074 D007              jnc L12
 0076           X3:
 0076                   .dbline 63
 0076 62D000            mov REG[0xd0],>_GainIndx
 0079 550201            mov [_GainIndx+2],1
 007C           L12:
 007C                   .dbline 64
 007C           ;                       if (PotValue >= 400 && PotValue < 600)  GainIndx[1][0] = 2;
 007C 62D000            mov REG[0xd0],>_PotValue
 007F 5101              mov A,[_PotValue+1]
 0081 1190              sub A,-112
 0083 5100              mov A,[_PotValue]
 0085 3180              xor A,-128
 0087 1981              sbb A,(1 ^ 0x80)
 0089 C016              jc L15
 008B           X4:
 008B 62D000            mov REG[0xd0],>_PotValue
 008E 5101              mov A,[_PotValue+1]
 0090 1158              sub A,88
 0092 5100              mov A,[_PotValue]
 0094 3180              xor A,-128
 0096 1982              sbb A,(2 ^ 0x80)
 0098 D007              jnc L15
 009A           X5:
 009A                   .dbline 64
 009A 62D000            mov REG[0xd0],>_GainIndx
 009D 550202            mov [_GainIndx+2],2
 00A0           L15:
 00A0                   .dbline 65
 00A0           ;                       if (PotValue >= 600 && PotValue < 800)  GainIndx[1][0] = 3;
 00A0 62D000            mov REG[0xd0],>_PotValue
 00A3 5101              mov A,[_PotValue+1]
 00A5 1158              sub A,88
 00A7 5100              mov A,[_PotValue]
 00A9 3180              xor A,-128
 00AB 1982              sbb A,(2 ^ 0x80)
 00AD C016              jc L18
 00AF           X6:
 00AF 62D000            mov REG[0xd0],>_PotValue
 00B2 5101              mov A,[_PotValue+1]
 00B4 1120              sub A,32
 00B6 5100              mov A,[_PotValue]
 00B8 3180              xor A,-128
 00BA 1983              sbb A,(3 ^ 0x80)
 00BC D007              jnc L18
 00BE           X7:
 00BE                   .dbline 65
 00BE 62D000            mov REG[0xd0],>_GainIndx
 00C1 550203            mov [_GainIndx+2],3
 00C4           L18:
 00C4                   .dbline 66
 00C4           ;                       if (PotValue >= 800 && PotValue < 1000) GainIndx[1][0] = 4;
 00C4 62D000            mov REG[0xd0],>_PotValue
 00C7 5101              mov A,[_PotValue+1]
 00C9 1120              sub A,32
 00CB 5100              mov A,[_PotValue]
 00CD 3180              xor A,-128
 00CF 1983              sbb A,(3 ^ 0x80)
 00D1 C016              jc L21
 00D3           X8:
 00D3 62D000            mov REG[0xd0],>_PotValue
 00D6 5101              mov A,[_PotValue+1]
 00D8 11E8              sub A,-24
 00DA 5100              mov A,[_PotValue]
 00DC 3180              xor A,-128
 00DE 1983              sbb A,(3 ^ 0x80)
 00E0 D007              jnc L21
 00E2           X9:
 00E2                   .dbline 66
 00E2 62D000            mov REG[0xd0],>_GainIndx
 00E5 550204            mov [_GainIndx+2],4
 00E8           L21:
 00E8                   .dbline 67
 00E8           ;                       if (PotValue >= 1000 && PotValue < 1200)        GainIndx[1][0] = 5;
 00E8 62D000            mov REG[0xd0],>_PotValue
 00EB 5101              mov A,[_PotValue+1]
 00ED 11E8              sub A,-24
 00EF 5100              mov A,[_PotValue]
 00F1 3180              xor A,-128
 00F3 1983              sbb A,(3 ^ 0x80)
 00F5 C016              jc L24
 00F7           X10:
 00F7 62D000            mov REG[0xd0],>_PotValue
 00FA 5101              mov A,[_PotValue+1]
 00FC 11B0              sub A,-80
 00FE 5100              mov A,[_PotValue]
 0100 3180              xor A,-128
 0102 1984              sbb A,(4 ^ 0x80)
 0104 D007              jnc L24
 0106           X11:
 0106                   .dbline 67
 0106 62D000            mov REG[0xd0],>_GainIndx
 0109 550205            mov [_GainIndx+2],5
 010C           L24:
 010C                   .dbline 68
 010C           ;                       if (PotValue >= 1200 && PotValue < 1400)        GainIndx[1][0] = 6;
 010C 62D000            mov REG[0xd0],>_PotValue
 010F 5101              mov A,[_PotValue+1]
 0111 11B0              sub A,-80
 0113 5100              mov A,[_PotValue]
 0115 3180              xor A,-128
 0117 1984              sbb A,(4 ^ 0x80)
 0119 C016              jc L27
 011B           X12:
 011B 62D000            mov REG[0xd0],>_PotValue
 011E 5101              mov A,[_PotValue+1]
 0120 1178              sub A,120
 0122 5100              mov A,[_PotValue]
 0124 3180              xor A,-128
 0126 1985              sbb A,(5 ^ 0x80)
 0128 D007              jnc L27
 012A           X13:
 012A                   .dbline 68
 012A 62D000            mov REG[0xd0],>_GainIndx
 012D 550206            mov [_GainIndx+2],6
 0130           L27:
 0130                   .dbline 69
 0130           ;                       if (PotValue >= 1400)   GainIndx[1][0] = 7;
 0130 62D000            mov REG[0xd0],>_PotValue
 0133 5101              mov A,[_PotValue+1]
 0135 1178              sub A,120
 0137 5100              mov A,[_PotValue]
 0139 3180              xor A,-128
 013B 1985              sbb A,(5 ^ 0x80)
 013D C007              jc L30
 013F           X14:
 013F                   .dbline 69
 013F 62D000            mov REG[0xd0],>_GainIndx
 0142 550207            mov [_GainIndx+2],7
 0145           L30:
 0145                   .dbline 71
 0145           ;                       
 0145           ;                       PGA_pre_SetGain(GF[GainIndx[1][0]][0]);
 0145 62D000            mov REG[0xd0],>_GainIndx
 0148 5102              mov A,[_GainIndx+2]
 014A 62D000            mov REG[0xd0],>__r0
 014D 5300              mov [__r1],A
 014F 550000            mov [__r0],0
 0152 6500              asl [__r1]
 0154 6B00              rlc [__r0]
 0156 060000            add [__r1],<_GF
 0159 0E0000            adc [__r0],>_GF
 015C 5100              mov A,[__r0]
 015E 60D4              mov REG[0xd4],A
 0160 3E00              mvi A,[__r1]
 0162 10                push X
 0163 7C0000            xcall _PGA_pre_SetGain
 0166 20                pop X
 0167                   .dbline 73
 0167           ;                       // ??????????????????DEBUG ????????????????
 0167           ;               }
 0167           L7:
 0167                   .dbline 75
 0167           ;         
 0167           ;               if(ADCINCVR_mes_fIsDataAvailable() != 0)// Wait for data to be ready
 0167 10                push X
 0168 7C0000            xcall _ADCINCVR_mes_fIsDataAvailable
 016B 62D000            mov REG[0xd0],>__r0
 016E 20                pop X
 016F 3900              cmp A,0
 0171 A038              jz L34
 0173                   .dbline 76
 0173           ;         {   
 0173                   .dbline 78
 0173           ;                       // Get Data, Clear data ready flag
 0173           ;                       MesValue[PortIndx] = ADCINCVR_mes_iGetDataClearFlag(); 
 0173 10                push X
 0174 7C0000            xcall _ADCINCVR_mes_iGetDataClearFlag
 0177 62D000            mov REG[0xd0],>__r0
 017A 5300              mov [__r1],A
 017C 5A00              mov [__r0],X
 017E 20                pop X
 017F 5200              mov A,[X+0]
 0181 5300              mov [__r3],A
 0183 550000            mov [__r2],0
 0186 6500              asl [__r3]
 0188 6B00              rlc [__r2]
 018A 060000            add [__r3],<_MesValue
 018D 0E0000            adc [__r2],>_MesValue
 0190 5100              mov A,[__r2]
 0192 60D5              mov REG[0xd5],A
 0194 5100              mov A,[__r0]
 0196 3F00              mvi [__r3],A
 0198 5100              mov A,[__r1]
 019A 3F00              mvi [__r3],A
 019C                   .dbline 80
 019C           ;                                                                                                                 
 019C           ;                       PortIndx++; // next mux port
 019C 7700              inc [X+0]
 019E                   .dbline 81
 019E           ;                       if (PortIndx <3)
 019E 3D0003            cmp [X+0],3
 01A1 D008              jnc L36
 01A3           X15:
 01A3                   .dbline 82
 01A3           ;                       {
 01A3                   .dbline 84
 01A3           ;                       //      AMUX4_mic_InputSelect(PortIndx); ????????????????????????????????????
 01A3           ;                               ADCINCVR_mes_GetSamples(1); // Start ADC to read once more
 01A3 10                push X
 01A4 5001              mov A,1
 01A6 7C0000            xcall _ADCINCVR_mes_GetSamples
 01A9 20                pop X
 01AA                   .dbline 85
 01AA           ;                       }
 01AA           L36:
 01AA                   .dbline 86
 01AA           ;               }
 01AA           L34:
 01AA                   .dbline 88
 01AA           ;               
 01AA           ;               if (TmrFlag) // every 10ms
 01AA 62D000            mov REG[0xd0],>_TmrFlag
 01AD 3C0000            cmp [_TmrFlag],0
 01B0 A017              jz L38
 01B2                   .dbline 89
 01B2           ;               {
 01B2                   .dbline 90
 01B2           ;                       TmrFlag = 0;
 01B2 550000            mov [_TmrFlag],0
 01B5                   .dbline 91
 01B5           ;                       PortIndx= 0;
 01B5 560000            mov [X+0],0
 01B8                   .dbline 94
 01B8           ;                               
 01B8           ;               //      AMUX4_mic_InputSelect(PortIndx); ???????????????????????????????????????????
 01B8           ;                       ADCINCVR_mes_GetSamples(1);    // Start ADC to read 1 sample
 01B8 10                push X
 01B9 5001              mov A,1
 01BB 7C0000            xcall _ADCINCVR_mes_GetSamples
 01BE 20                pop X
 01BF                   .dbline 95
 01BF           ;                       ADCINCVR_pot_GetSamples(1);    // Start ADC to read 1 sample 
 01BF 10                push X
 01C0 5001              mov A,1
 01C2 7C0000            xcall _ADCINCVR_pot_GetSamples
 01C5 20                pop X
 01C6                   .dbline 97
 01C6           ;                       
 01C6           ;                       DigitalOut();
 01C6 901F              xcall _DigitalOut
 01C8                   .dbline 98
 01C8           ;               }
 01C8           L38:
 01C8                   .dbline 100
 01C8           ;               
 01C8           ;               if (Tmr1) // every 100ms
 01C8 62D000            mov REG[0xd0],>_Tmr1
 01CB 3C0000            cmp [_Tmr1],0
 01CE B006              jnz X16
 01D0 3C0100            cmp [_Tmr1+1],0
 01D3 A00C              jz L40
 01D5           X16:
 01D5                   .dbline 101
 01D5           ;               {
 01D5                   .dbline 102
 01D5           ;                       Tmr1 = 0;
 01D5 62D000            mov REG[0xd0],>_Tmr1
 01D8 550100            mov [_Tmr1+1],0
 01DB 550000            mov [_Tmr1],0
 01DE                   .dbline 103
 01DE           ;                       UartTxValues();
 01DE 909D              xcall _UartTxValues
 01E0                   .dbline 104
 01E0           ;               }
 01E0           L40:
 01E0                   .dbline 105
 01E0           ;       }// ========================================================== Main loop 
 01E0           L5:
 01E0                   .dbline 54
 01E0 8E3C              xjmp L4
 01E2           X0:
 01E2                   .dbline -2
 01E2           L1:
 01E2 38FC              add SP,-4
 01E4 20                pop X
 01E5                   .dbline 0 ; func end
 01E5 8FFF              jmp .
 01E7                   .dbsym l PortNum 1 A[3:3]c
 01E7                   .dbsym l PortIndx 0 c
 01E7                   .dbend
 01E7                   .dbfunc e DigitalOut _DigitalOut fV
 01E7           _DigitalOut::
 01E7                   .dbline -1
 01E7                   .dbline 110
 01E7           ; }
 01E7           ; 
 01E7           ; // Functions ***************************************************************
 01E7           ; void DigitalOut(void)
 01E7           ; {// Controls the outputs according to pot setting point
 01E7                   .dbline 111
 01E7           ;       DIGITAL_OUT_Off();
 01E7 10                push X
 01E8 7C0000            xcall _DIGITAL_OUT_Off
 01EB 20                pop X
 01EC                   .dbline 112
 01EC           ;       if (MesValue[0]>PotValue)
 01EC 62D000            mov REG[0xd0],>_PotValue
 01EF 5101              mov A,[_PotValue+1]
 01F1 62D000            mov REG[0xd0],>_MesValue
 01F4 1201              sub A,[_MesValue+1]
 01F6 5100              mov A,[_MesValue]
 01F8 3180              xor A,-128
 01FA 62D000            mov REG[0xd0],>__r0
 01FD 5300              mov [__rX],A
 01FF 62D000            mov REG[0xd0],>_PotValue
 0202 5100              mov A,[_PotValue]
 0204 3180              xor A,-128
 0206 62D000            mov REG[0xd0],>__r0
 0209 1A00              sbb A,[__rX]
 020B D00B              jnc L43
 020D           X17:
 020D                   .dbline 113
 020D           ;       {
 020D                   .dbline 114
 020D           ;               DIGITAL_OUT_On();
 020D 10                push X
 020E 7C0000            xcall _DIGITAL_OUT_On
 0211                   .dbline 115
 0211           ;               LED_1_On();
 0211 7C0000            xcall _LED_1_On
 0214 20                pop X
 0215                   .dbline 116
 0215           ;       }
 0215 8006              xjmp L44
 0217           L43:
 0217                   .dbline 118
 0217           ;       else
 0217           ;       {
 0217                   .dbline 119
 0217           ;               LED_1_Off();
 0217 10                push X
 0218 7C0000            xcall _LED_1_Off
 021B 20                pop X
 021C                   .dbline 120
 021C           ;       }
 021C           L44:
 021C                   .dbline 122
 021C           ;               
 021C           ;       if (MesValue[1]>PotValue)
 021C 62D000            mov REG[0xd0],>_PotValue
 021F 5101              mov A,[_PotValue+1]
 0221 62D000            mov REG[0xd0],>_MesValue
 0224 1203              sub A,[_MesValue+2+1]
 0226 5102              mov A,[_MesValue+2]
 0228 3180              xor A,-128
 022A 62D000            mov REG[0xd0],>__r0
 022D 5300              mov [__rX],A
 022F 62D000            mov REG[0xd0],>_PotValue
 0232 5100              mov A,[_PotValue]
 0234 3180              xor A,-128
 0236 62D000            mov REG[0xd0],>__r0
 0239 1A00              sbb A,[__rX]
 023B D00B              jnc L45
 023D           X18:
 023D                   .dbline 123
 023D           ;       {
 023D                   .dbline 124
 023D           ;               DIGITAL_OUT_On();
 023D 10                push X
 023E 7C0000            xcall _DIGITAL_OUT_On
 0241                   .dbline 125
 0241           ;               LED_2_On();
 0241 7C0000            xcall _LED_2_On
 0244 20                pop X
 0245                   .dbline 126
 0245           ;       }
 0245 8006              xjmp L46
 0247           L45:
 0247                   .dbline 128
 0247           ;       else
 0247           ;       {
 0247                   .dbline 129
 0247           ;               LED_2_Off();
 0247 10                push X
 0248 7C0000            xcall _LED_2_Off
 024B 20                pop X
 024C                   .dbline 130
 024C           ;       }
 024C           L46:
 024C                   .dbline 132
 024C           ;       
 024C           ;       if (MesValue[2]>PotValue)
 024C 62D000            mov REG[0xd0],>_PotValue
 024F 5101              mov A,[_PotValue+1]
 0251 62D000            mov REG[0xd0],>_MesValue
 0254 1205              sub A,[_MesValue+4+1]
 0256 5104              mov A,[_MesValue+4]
 0258 3180              xor A,-128
 025A 62D000            mov REG[0xd0],>__r0
 025D 5300              mov [__rX],A
 025F 62D000            mov REG[0xd0],>_PotValue
 0262 5100              mov A,[_PotValue]
 0264 3180              xor A,-128
 0266 62D000            mov REG[0xd0],>__r0
 0269 1A00              sbb A,[__rX]
 026B D00B              jnc L48
 026D           X19:
 026D                   .dbline 133
 026D           ;       {
 026D                   .dbline 134
 026D           ;               DIGITAL_OUT_On();
 026D 10                push X
 026E 7C0000            xcall _DIGITAL_OUT_On
 0271                   .dbline 135
 0271           ;               LED_3_On();
 0271 7C0000            xcall _LED_3_On
 0274 20                pop X
 0275                   .dbline 136
 0275           ;       }
 0275 8006              xjmp L49
 0277           L48:
 0277                   .dbline 138
 0277           ;       else
 0277           ;       {
 0277                   .dbline 139
 0277           ;               LED_3_Off();
 0277 10                push X
 0278 7C0000            xcall _LED_3_Off
 027B 20                pop X
 027C                   .dbline 140
 027C           ;       }
 027C           L49:
 027C                   .dbline -2
 027C           L42:
 027C                   .dbline 0 ; func end
 027C 7F                ret
 027D                   .dbend
 027D                   .dbfunc e UartTxValues _UartTxValues fV
 027D           _UartTxValues::
 027D                   .dbline -1
 027D                   .dbline 144
 027D           ; }
 027D           ; 
 027D           ; void UartTxValues(void)
 027D           ; {/* Transmit via UART the analog values read from various inputs.
 027D                   .dbline 149
 027D           ;       Usefull for debugging purposes, it could be converted in a
 027D           ;       command string using the same protocol used for dsNav if
 027D           ;       needed to output sound level values via serial comm
 027D           ; */
 027D           ;       TX8_CPutString("\n\rPot Value = ");
 027D 10                push X
 027E 5032              mov A,>L52
 0280 08                push A
 0281 5032              mov A,<L52
 0283 5C                mov X,A
 0284 18                pop A
 0285 7C0000            xcall _TX8_CPutString
 0288 20                pop X
 0289                   .dbline 150
 0289           ;       itoa(str, PotValue,10);
 0289 5000              mov A,0
 028B 08                push A
 028C 500A              mov A,10
 028E 08                push A
 028F 62D000            mov REG[0xd0],>_PotValue
 0292 5100              mov A,[_PotValue]
 0294 08                push A
 0295 5101              mov A,[_PotValue+1]
 0297 08                push A
 0298 5000              mov A,>_str
 029A 08                push A
 029B 5000              mov A,<_str
 029D 08                push A
 029E 7C0000            xcall _itoa
 02A1 38FA              add SP,-6
 02A3                   .dbline 151
 02A3           ;       TX8_PutString(str);
 02A3 10                push X
 02A4 5000              mov A,>_str
 02A6 08                push A
 02A7 5000              mov A,<_str
 02A9 5C                mov X,A
 02AA 18                pop A
 02AB 7C0000            xcall _TX8_PutString
 02AE 20                pop X
 02AF                   .dbline 152
 02AF           ;       TX8_CPutString("    Mes Value: 1 = ");
 02AF 10                push X
 02B0 501E              mov A,>L53
 02B2 08                push A
 02B3 501E              mov A,<L53
 02B5 5C                mov X,A
 02B6 18                pop A
 02B7 7C0000            xcall _TX8_CPutString
 02BA 20                pop X
 02BB                   .dbline 153
 02BB           ;       itoa(str, MesValue[0],10);
 02BB 5000              mov A,0
 02BD 08                push A
 02BE 500A              mov A,10
 02C0 08                push A
 02C1 62D000            mov REG[0xd0],>_MesValue
 02C4 5100              mov A,[_MesValue]
 02C6 08                push A
 02C7 5101              mov A,[_MesValue+1]
 02C9 08                push A
 02CA 5000              mov A,>_str
 02CC 08                push A
 02CD 5000              mov A,<_str
 02CF 08                push A
 02D0 7C0000            xcall _itoa
 02D3 38FA              add SP,-6
 02D5                   .dbline 154
 02D5           ;       TX8_PutString(str);
 02D5 10                push X
 02D6 5000              mov A,>_str
 02D8 08                push A
 02D9 5000              mov A,<_str
 02DB 5C                mov X,A
 02DC 18                pop A
 02DD 7C0000            xcall _TX8_PutString
 02E0 20                pop X
 02E1                   .dbline 155
 02E1           ;       TX8_CPutString("  -  2 = ");
 02E1 10                push X
 02E2 5014              mov A,>L54
 02E4 08                push A
 02E5 5014              mov A,<L54
 02E7 5C                mov X,A
 02E8 18                pop A
 02E9 7C0000            xcall _TX8_CPutString
 02EC 20                pop X
 02ED                   .dbline 156
 02ED           ;       itoa(str, MesValue[1],10);
 02ED 5000              mov A,0
 02EF 08                push A
 02F0 500A              mov A,10
 02F2 08                push A
 02F3 62D000            mov REG[0xd0],>_MesValue
 02F6 5102              mov A,[_MesValue+2]
 02F8 08                push A
 02F9 5103              mov A,[_MesValue+2+1]
 02FB 08                push A
 02FC 5000              mov A,>_str
 02FE 08                push A
 02FF 5000              mov A,<_str
 0301 08                push A
 0302 7C0000            xcall _itoa
 0305 38FA              add SP,-6
 0307                   .dbline 157
 0307           ;       TX8_PutString(str);
 0307 10                push X
 0308 5000              mov A,>_str
 030A 08                push A
 030B 5000              mov A,<_str
 030D 5C                mov X,A
 030E 18                pop A
 030F 7C0000            xcall _TX8_PutString
 0312 20                pop X
 0313                   .dbline 158
 0313           ;       TX8_CPutString("  -  3 = ");
 0313 10                push X
 0314 500A              mov A,>L56
 0316 08                push A
 0317 500A              mov A,<L56
 0319 5C                mov X,A
 031A 18                pop A
 031B 7C0000            xcall _TX8_CPutString
 031E 20                pop X
 031F                   .dbline 159
 031F           ;       itoa(str, MesValue[2],10);
 031F 5000              mov A,0
 0321 08                push A
 0322 500A              mov A,10
 0324 08                push A
 0325 62D000            mov REG[0xd0],>_MesValue
 0328 5104              mov A,[_MesValue+4]
 032A 08                push A
 032B 5105              mov A,[_MesValue+4+1]
 032D 08                push A
 032E 5000              mov A,>_str
 0330 08                push A
 0331 5000              mov A,<_str
 0333 08                push A
 0334 7C0000            xcall _itoa
 0337 38FA              add SP,-6
 0339                   .dbline 160
 0339           ;       TX8_PutString(str);
 0339 10                push X
 033A 5000              mov A,>_str
 033C 08                push A
 033D 5000              mov A,<_str
 033F 5C                mov X,A
 0340 18                pop A
 0341 7C0000            xcall _TX8_PutString
 0344 20                pop X
 0345                   .dbline 161
 0345           ;       TX8_CPutString("  Gain = ");
 0345 10                push X
 0346 5000              mov A,>L58
 0348 08                push A
 0349 5000              mov A,<L58
 034B 5C                mov X,A
 034C 18                pop A
 034D 7C0000            xcall _TX8_CPutString
 0350 20                pop X
 0351                   .dbline 162
 0351           ;       itoa(str, GF[GainIndx[1][0]][1], 10);
 0351 5000              mov A,0
 0353 08                push A
 0354 500A              mov A,10
 0356 08                push A
 0357 62D000            mov REG[0xd0],>_GainIndx
 035A 5102              mov A,[_GainIndx+2]
 035C 62D000            mov REG[0xd0],>__r0
 035F 5300              mov [__r1],A
 0361 550000            mov [__r0],0
 0364 6500              asl [__r1]
 0366 6B00              rlc [__r0]
 0368 060001            add [__r1],<_GF+1
 036B 0E0001            adc [__r0],>_GF+1
 036E 5100              mov A,[__r0]
 0370 60D4              mov REG[0xd4],A
 0372 3E00              mvi A,[__r1]
 0374 5300              mov [__r1],A
 0376 5000              mov A,0
 0378 08                push A
 0379 5100              mov A,[__r1]
 037B 08                push A
 037C 5000              mov A,>_str
 037E 08                push A
 037F 5000              mov A,<_str
 0381 08                push A
 0382 7C0000            xcall _itoa
 0385 38FA              add SP,-6
 0387                   .dbline 163
 0387           ;       TX8_PutString(str);     
 0387 10                push X
 0388 5000              mov A,>_str
 038A 08                push A
 038B 5000              mov A,<_str
 038D 5C                mov X,A
 038E 18                pop A
 038F 7C0000            xcall _TX8_PutString
 0392 20                pop X
 0393                   .dbline -2
 0393           L51:
 0393                   .dbline 0 ; func end
 0393 7F                ret
 0394                   .dbend
 0394                   .dbfunc e BlocksInit _BlocksInit fV
 0394           _BlocksInit::
 0394                   .dbline -1
 0394                   .dbline 167
 0394           ; }
 0394           ;       
 0394           ; void BlocksInit(void)
 0394           ; {// Analog and digital blocks inizialization
 0394                   .dbline 168
 0394           ;       ADCINCVR_pot_Start(ADCINCVR_pot_HIGHPOWER);     
 0394 10                push X
 0395 5003              mov A,3
 0397 7C0000            xcall _ADCINCVR_pot_Start
 039A 20                pop X
 039B                   .dbline 169
 039B           ;       ADCINCVR_mes_Start(ADCINCVR_mes_HIGHPOWER);
 039B 10                push X
 039C 5003              mov A,3
 039E 7C0000            xcall _ADCINCVR_mes_Start
 03A1                   .dbline 170
 03A1           ;       AMUX4_mic_Start();
 03A1 7C0000            xcall _AMUX4_mic_Start
 03A4 20                pop X
 03A5                   .dbline 171
 03A5           ;       BPF4_4KHz_Start(BPF4_4KHz_HIGHPOWER);
 03A5 10                push X
 03A6 5003              mov A,3
 03A8 7C0000            xcall _BPF4_4KHz_Start
 03AB                   .dbline 172
 03AB           ;       I2CHW_Start();
 03AB 7C0000            xcall _I2CHW_Start
 03AE 20                pop X
 03AF                   .dbline 173
 03AF           ;       PGA_out_Start(PGA_out_HIGHPOWER);
 03AF 10                push X
 03B0 5003              mov A,3
 03B2 7C0000            xcall _PGA_out_Start
 03B5 20                pop X
 03B6                   .dbline 174
 03B6           ;       PGA_pre_Start(PGA_pre_HIGHPOWER); 
 03B6 10                push X
 03B7 5003              mov A,3
 03B9 7C0000            xcall _PGA_pre_Start
 03BC 20                pop X
 03BD                   .dbline 175
 03BD           ;       RefMux_1_Start(RefMux_1_HIGHPOWER);
 03BD 10                push X
 03BE 5003              mov A,3
 03C0 7C0000            xcall _RefMux_1_Start
 03C3 20                pop X
 03C4                   .dbline 176
 03C4           ;     SCBLOCK_inbuff_Start(SCBLOCK_inbuff_HIGHPOWER);
 03C4 10                push X
 03C5 5003              mov A,3
 03C7 7C0000            xcall _SCBLOCK_inbuff_Start
 03CA                   .dbline 177
 03CA           ;       LED_1_Start();
 03CA 7C0000            xcall _LED_1_Start
 03CD                   .dbline 178
 03CD           ;       LED_2_Start();
 03CD 7C0000            xcall _LED_2_Start
 03D0                   .dbline 179
 03D0           ;       LED_3_Start();
 03D0 7C0000            xcall _LED_3_Start
 03D3                   .dbline 180
 03D3           ;       DIGITAL_OUT_Start();  
 03D3 7C0000            xcall _DIGITAL_OUT_Start
 03D6                   .dbline 182
 03D6           ;       
 03D6           ;       TX8_EnableInt();
 03D6 7C0000            xcall _TX8_EnableInt
 03D9 20                pop X
 03DA                   .dbline 183
 03DA           ;       TX8_Start(TX8_PARITY_NONE);
 03DA 10                push X
 03DB 5000              mov A,0
 03DD 7C0000            xcall _TX8_Start
 03E0 20                pop X
 03E1                   .dbline 185
 03E1           ;       
 03E1           ;       AMUX4_mic_InputSelect(AMUX4_mic_PORT0_1);
 03E1 10                push X
 03E2 5000              mov A,0
 03E4 7C0000            xcall _AMUX4_mic_InputSelect
 03E7 20                pop X
 03E8                   .dbline 186
 03E8           ;       PGA_pre_SetGain(PGA_pre_G48_0);
 03E8 10                push X
 03E9 500C              mov A,12
 03EB 7C0000            xcall _PGA_pre_SetGain
 03EE                   .dbline 188
 03EE           ;       
 03EE           ;     HB_Tmr_EnableInt();  
 03EE 7C0000            xcall _HB_Tmr_EnableInt
 03F1                   .dbline 189
 03F1           ;       HB_Tmr_Start();         
 03F1 7C0000            xcall _HB_Tmr_Start
 03F4 20                pop X
 03F5                   .dbline -2
 03F5           L61:
 03F5                   .dbline 0 ; func end
 03F5 7F                ret
 03F6                   .dbend
 03F6                   .dbfunc e HB_Tmr_ISR_C _HB_Tmr_ISR_C fV
 03F6           _HB_Tmr_ISR_C::
 03F6                   .dbline -1
 03F6 71C0              or F,-64
 03F8 08                push A
 03F9 5DD0              mov A,REG[0xd0]
 03FB 08                push A
 03FC                   .dbline 193
 03FC           ; }
 03FC           ;       
 03FC           ; void HB_Tmr_ISR_C(void)
 03FC           ; {// Base clock for all of the timings in the program
 03FC                   .dbline 194
 03FC           ;       TmrFlag = 1;
 03FC 62D000            mov REG[0xd0],>_TmrFlag
 03FF 550001            mov [_TmrFlag],1
 0402                   .dbline 195
 0402           ;       Tmr1++;
 0402 62D000            mov REG[0xd0],>_Tmr1
 0405 7601              inc [_Tmr1+1]
 0407 0E0000            adc [_Tmr1],0
 040A                   .dbline -2
 040A           L62:
 040A 18                pop A
 040B 60D0              mov REG[208],A
 040D 18                pop A
 040E                   .dbline 0 ; func end
 040E 7E                reti
 040F                   .dbend
 040F                   .dbfunc e DelayMs _DelayMs fV
 040F           ;              i -> X+0
 040F           ;             Ms -> X-5
 040F           _DelayMs::
 040F                   .dbline -1
 040F 10                push X
 0410 4F                mov X,SP
 0411 3802              add SP,2
 0413                   .dbline 199
 0413           ; }
 0413           ; 
 0413           ; void DelayMs(int Ms)
 0413           ; {
 0413                   .dbline 201
 0413           ;       int i;
 0413           ;       for (i=0; i<Ms; i++)
 0413 560100            mov [X+1],0
 0416 560000            mov [X+0],0
 0419 800D              xjmp L67
 041B           L64:
 041B                   .dbline 202
 041B           ;       {
 041B                   .dbline 203
 041B           ;               Delay50uTimes(20);
 041B 10                push X
 041C 5014              mov A,20
 041E 7C0000            xcall _Delay50uTimes
 0421 20                pop X
 0422                   .dbline 204
 0422           ;       }
 0422           L65:
 0422                   .dbline 201
 0422 7701              inc [X+1]
 0424 0F0000            adc [X+0],0
 0427           L67:
 0427                   .dbline 201
 0427 5201              mov A,[X+1]
 0429 13FC              sub A,[X-4]
 042B 52FB              mov A,[X-5]
 042D 3180              xor A,-128
 042F 62D000            mov REG[0xd0],>__r0
 0432 5300              mov [__rX],A
 0434 5200              mov A,[X+0]
 0436 3180              xor A,-128
 0438 1A00              sbb A,[__rX]
 043A CFE0              jc L64
 043C           X20:
 043C                   .dbline -2
 043C           L63:
 043C 38FE              add SP,-2
 043E 20                pop X
 043F                   .dbline 0 ; func end
 043F 7F                ret
 0440                   .dbsym l i 0 I
 0440                   .dbsym l Ms -5 I
 0440                   .dbend
 0440                   .dbfunc e LedTest _LedTest fV
 0440           ;              i -> X+0
 0440           _LedTest::
 0440                   .dbline -1
 0440 10                push X
 0441 4F                mov X,SP
 0442 3802              add SP,2
 0444                   .dbline 208
 0444           ; }
 0444           ; 
 0444           ; void LedTest(void)
 0444           ; {
 0444                   .dbline 210
 0444           ;       int i;
 0444           ;       LED_1_Off();
 0444 10                push X
 0445 7C0000            xcall _LED_1_Off
 0448                   .dbline 211
 0448           ;       LED_2_Off();
 0448 7C0000            xcall _LED_2_Off
 044B                   .dbline 212
 044B           ;       LED_3_Off();
 044B 7C0000            xcall _LED_3_Off
 044E 20                pop X
 044F                   .dbline 214
 044F           ;       
 044F           ;       for (i=0; i<3; i++)
 044F 560100            mov [X+1],0
 0452 560000            mov [X+0],0
 0455           L69:
 0455                   .dbline 215
 0455           ;       {
 0455                   .dbline 216
 0455           ;               LED_1_On();
 0455 10                push X
 0456 7C0000            xcall _LED_1_On
 0459 20                pop X
 045A                   .dbline 217
 045A           ;               DelayMs(500);
 045A 5001              mov A,1
 045C 08                push A
 045D 50F4              mov A,-12
 045F 08                push A
 0460 9FAD              xcall _DelayMs
 0462 38FE              add SP,-2
 0464                   .dbline 218
 0464           ;               LED_1_Off();
 0464 10                push X
 0465 7C0000            xcall _LED_1_Off
 0468                   .dbline 219
 0468           ;               LED_2_On();
 0468 7C0000            xcall _LED_2_On
 046B 20                pop X
 046C                   .dbline 220
 046C           ;               DelayMs(500);
 046C 5001              mov A,1
 046E 08                push A
 046F 50F4              mov A,-12
 0471 08                push A
 0472 9F9B              xcall _DelayMs
 0474 38FE              add SP,-2
 0476                   .dbline 221
 0476           ;               LED_2_Off();
 0476 10                push X
 0477 7C0000            xcall _LED_2_Off
 047A                   .dbline 222
 047A           ;               LED_3_On();
 047A 7C0000            xcall _LED_3_On
 047D 20                pop X
 047E                   .dbline 223
 047E           ;               DelayMs(500);
 047E 5001              mov A,1
 0480 08                push A
 0481 50F4              mov A,-12
 0483 08                push A
 0484 9F89              xcall _DelayMs
 0486 38FE              add SP,-2
 0488                   .dbline 224
 0488           ;               LED_3_Off();
 0488 10                push X
 0489 7C0000            xcall _LED_3_Off
 048C 20                pop X
 048D                   .dbline 225
 048D           ;       }
 048D           L70:
 048D                   .dbline 214
 048D 7701              inc [X+1]
 048F 0F0000            adc [X+0],0
 0492                   .dbline 214
 0492 5201              mov A,[X+1]
 0494 1103              sub A,3
 0496 5200              mov A,[X+0]
 0498 3180              xor A,-128
 049A 1980              sbb A,(0 ^ 0x80)
 049C CFB8              jc L69
 049E           X21:
 049E                   .dbline -2
 049E           L68:
 049E 38FE              add SP,-2
 04A0 20                pop X
 04A1                   .dbline 0 ; func end
 04A1 7F                ret
 04A2                   .dbsym l i 0 I
 04A2                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile D:\PROGRA~1\PSOCPR~1\EXPLOR~1\EXPLOR~1\main.c
 0000           _str::
 0000 00000000000000    .byte 0,0,0,0,0,0,0
 0007                   .dbfile D:\PROGRA~1\PSOCPR~1\EXPLOR~1\EXPLOR~1\definitions.h
 0007                   .dbsym e str _str A[7:7]c
                        .area data(ram, con, rel)
 0000                   .dbfile D:\PROGRA~1\PSOCPR~1\EXPLOR~1\EXPLOR~1\definitions.h
 0000           _Tmr1::
 0000 0000              .byte 0,0
 0002                   .dbsym e Tmr1 _Tmr1 i
                        .area data(ram, con, rel)
 0000                   .dbfile D:\PROGRA~1\PSOCPR~1\EXPLOR~1\EXPLOR~1\definitions.h
 0000           _i::
 0000 0000              .byte 0,0
 0002                   .dbsym e i _i i
                        .area data(ram, con, rel)
 0000                   .dbfile D:\PROGRA~1\PSOCPR~1\EXPLOR~1\EXPLOR~1\definitions.h
 0000           _MesValue::
 0000 000000000000      .byte 0,0,0,0,0,0
 0006                   .dbsym e MesValue _MesValue A[6:3]I
                        .area data(ram, con, rel)
 0000                   .dbfile D:\PROGRA~1\PSOCPR~1\EXPLOR~1\EXPLOR~1\definitions.h
 0000           _PotValue::
 0000 0000              .byte 0,0
 0002                   .dbsym e PotValue _PotValue I
                        .area lit(rom, con, rel)
 0000           L58:
 0000 20204761696E203D2000      .byte 32,32,'G,'a,'i,'n,32,61,32,0
 000A           L56:
 000A 20202D202033203D2000      .byte 32,32,45,32,32,51,32,61,32,0
 0014           L54:
 0014 20202D202032203D2000      .byte 32,32,45,32,32,50,32,61,32,0
 001E           L53:
 001E 202020204D65732056616C75653A2031  .byte 32,32,32,32,'M,'e,'s,32,'V,'a,'l,'u,'e,58,32,49
 002E 203D2000          .byte 32,61,32,0
 0032           L52:
 0032 0A0D506F742056616C7565203D2000    .byte 10,13,'P,'o,'t,32,'V,'a,'l,'u,'e,32,61,32,0
