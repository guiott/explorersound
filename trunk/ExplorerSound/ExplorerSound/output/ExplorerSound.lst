FILE: .\boot.asm
                                        (0001) ; Generated by PSoC Designer 5.0.1127.0
                                        (0002) ;
                                        (0003) ;@Id: boot.tpl#895 @
                                        (0004) ;=============================================================================
                                        (0005) ;  FILENAME:   boot.asm
                                        (0006) ;  Version:    4.18
                                        (0007) ;
                                        (0008) ;  DESCRIPTION:
                                        (0009) ;  M8C Boot Code for CY8C29xxx microcontroller family.
                                        (0010) ;
                                        (0011) ;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0012) ;
                                        (0013) ; NOTES:
                                        (0014) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                        (0015) ; the project's root directory to create BOOT.ASM. Any changes made to
                                        (0016) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                        (0017) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                        (0018) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                        (0019) ; are not accidentally modified.
                                        (0020) ;
                                        (0021) ;=============================================================================
                                        (0022) 
                                        (0023) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
                                        (0024) include "m8c.inc"			;Part specific file
                                        (0025) include "m8ssc.inc"			;Part specific file
                                        (0026) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
                                        (0027) 
                                        (0028) ;--------------------------------------
                                        (0029) ; Export Declarations
                                        (0030) ;--------------------------------------
                                        (0031) 
                                        (0032) export __Start
                                        (0033) IF	(TOOLCHAIN & HITECH)
                                        (0034) ELSE
                                        (0035) export __bss_start
                                        (0036) export __data_start
                                        (0037) export __idata_start
                                        (0038) export __func_lit_start
                                        (0039) export __text_start
                                        (0040) ENDIF
                                        (0041) export  _bGetPowerSetting
                                        (0042) export   bGetPowerSetting
                                        (0043) 
                                        (0044) 
                                        (0045) ;--------------------------------------
                                        (0046) ; Optimization flags
                                        (0047) ;--------------------------------------
                                        (0048) ;
                                        (0049) ; To change the value of these flags, modify the file boot.tpl, not
                                        (0050) ; boot.asm. See the notes in the banner comment at the beginning of
                                        (0051) ; this file.
                                        (0052) 
                                        (0053) ; Optimization for Assembly language (only) projects and C-language projects
                                        (0054) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                        (0055) ;   Set to 1: Support for C Run-time Environment initialization
                                        (0056) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                        (0057) ;
                                        (0058) IF	(TOOLCHAIN & HITECH)
                                        (0059) ; The C compiler will customize the startup code - it's not required here
                                        (0060) 
                                        (0061) C_LANGUAGE_SUPPORT:              equ 0
                                        (0062) ELSE
                                        (0063) C_LANGUAGE_SUPPORT:              equ 1
                                        (0064) ENDIF
                                        (0065) 
                                        (0066) 
                                        (0067) ; The following equate is required for proper operation. Reseting its value
                                        (0068) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
                                        (0069) ; selected.  If the designer chooses to not wait then stabilization of the ECO
                                        (0070) ; and PLL_Lock must take place within user code. See the family data sheet for
                                        (0071) ; the requirements of starting the ECO and PLL lock mode.
                                        (0072) ;
                                        (0073) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
                                        (0074) ;                invoking main
                                        (0075) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
                                        (0076) ;               the time code in main starts executing.
                                        (0077) ;
                                        (0078) WAIT_FOR_32K:                    equ 1
                                        (0079) 
                                        (0080) 
                                        (0081) ; For historical reasons, by default the boot code uses an lcall instruction
                                        (0082) ; to invoke the user's _main code. If _main executes a return instruction,
                                        (0083) ; boot provides an infinite loop. By changing the following equate from zero
                                        (0084) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                        (0085) ; bytes on the stack which are otherwise required for the return address. If
                                        (0086) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                        (0087) ; release, the C compiler automatically places an infinite loop at the end
                                        (0088) ; of main, rather than a return instruction.)
                                        (0089) ;
                                        (0090) ENABLE_LJMP_TO_MAIN:             equ 0
                                        (0091) 
                                        (0092) 
                                        (0093) ;-----------------------------------------------------------------------------
                                        (0094) ; Interrupt Vector Table
                                        (0095) ;-----------------------------------------------------------------------------
                                        (0096) ;
                                        (0097) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                        (0098) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                        (0099) ; very short ISRs could be encoded within the table itself. Normally,
                                        (0100) ; vector jump targets are modified automatically according to the user
                                        (0101) ; modules selected. This occurs when the 'Generate Application' opera-
                                        (0102) ; tion is run causing PSoC Designer to create boot.asm and the other
                                        (0103) ; configuration files. If you need to hard code a vector, update the
                                        (0104) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                        (0105) ; of this file.
                                        (0106) ;-----------------------------------------------------------------------------
                                        (0107) 
                                        (0108)     AREA TOP (ROM, ABS, CON)
                                        (0109) 
                                        (0110)     org   0                        ;Reset Interrupt Vector
                                        (0111) IF	(TOOLCHAIN & HITECH)
                                        (0112) ;   jmp   __Start                  ;C compiler fills in this vector
                                        (0113) ELSE
0000: 80 67    JMP   0x0068             (0114)     jmp   __Start                  ;First instruction executed following a Reset
                                        (0115) ENDIF
                                        (0116) 
                                        (0117)     org   04h                      ;Low Voltage Detect (LVD) Interrupt Vector
0002: 30       HALT                     
0003: 30       HALT                     
0004: 30       HALT                     (0118)     halt                           ;Stop execution if power falls too low
                                        (0119) 
                                        (0120)     org   08h                      ;Analog Column 0 Interrupt Vector
                                        (0121)     // call	void_handler
0005: 30       HALT                     
0006: 30       HALT                     
0007: 30       HALT                     
0008: 7E       RETI                     (0122)     reti
                                        (0123) 
                                        (0124)     org   0Ch                      ;Analog Column 1 Interrupt Vector
                                        (0125)     // call	void_handler
0009: 30       HALT                     
000A: 30       HALT                     
000B: 30       HALT                     
000C: 7E       RETI                     (0126)     reti
                                        (0127) 
                                        (0128)     org   10h                      ;Analog Column 2 Interrupt Vector
                                        (0129)     // call	void_handler
000D: 30       HALT                     
000E: 30       HALT                     
000F: 30       HALT                     
0010: 7E       RETI                     (0130)     reti
                                        (0131) 
                                        (0132)     org   14h                      ;Analog Column 3 Interrupt Vector
                                        (0133)     // call	void_handler
0011: 30       HALT                     
0012: 30       HALT                     
0013: 30       HALT                     
0014: 7E       RETI                     (0134)     reti
                                        (0135) 
                                        (0136)     org   18h                      ;VC3 Interrupt Vector
                                        (0137)     // call	void_handler
0015: 30       HALT                     
0016: 30       HALT                     
0017: 30       HALT                     
0018: 7E       RETI                     (0138)     reti
                                        (0139) 
                                        (0140)     org   1Ch                      ;GPIO Interrupt Vector
                                        (0141)     // call	void_handler
0019: 30       HALT                     
001A: 30       HALT                     
001B: 30       HALT                     
001C: 7E       RETI                     (0142)     reti
                                        (0143) 
                                        (0144)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
001D: 30       HALT                     
001E: 30       HALT                     
001F: 30       HALT                     
0020: 7D 08 42 LJMP  0x0842             (0145)     ljmp	_ADCINCVR_mes_CNT_ISR
0023: 7E       RETI                     (0146)     reti
                                        (0147) 
                                        (0148)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
                                        (0149)     // call	void_handler
0024: 7E       RETI                     (0150)     reti
                                        (0151) 
                                        (0152)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
0025: 30       HALT                     
0026: 30       HALT                     
0027: 30       HALT                     
0028: 7D 08 45 LJMP  0x0845             (0153)     ljmp	_ADCINCVR_mes_PWM16_ISR
002B: 7E       RETI                     (0154)     reti
                                        (0155) 
                                        (0156)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
002C: 7D 06 FD LJMP  0x06FD             (0157)     ljmp	_ADCINCVR_pot_CNT_ISR
002F: 7E       RETI                     (0158)     reti
                                        (0159) 
                                        (0160)     org   30h                      ;PSoC Block DBB10 Interrupt Vector
                                        (0161)     // call	void_handler
0030: 7E       RETI                     (0162)     reti
                                        (0163) 
                                        (0164)     org   34h                      ;PSoC Block DBB11 Interrupt Vector
0031: 30       HALT                     
0032: 30       HALT                     
0033: 30       HALT                     
0034: 7D 07 00 LJMP  0x0700             (0165)     ljmp	_ADCINCVR_pot_PWM16_ISR
0037: 7E       RETI                     (0166)     reti
                                        (0167) 
                                        (0168)     org   38h                      ;PSoC Block DCB12 Interrupt Vector
                                        (0169)     // call	void_handler
0038: 7E       RETI                     (0170)     reti
                                        (0171) 
                                        (0172)     org   3Ch                      ;PSoC Block DCB13 Interrupt Vector
                                        (0173)     // call	void_handler
0039: 30       HALT                     
003A: 30       HALT                     
003B: 30       HALT                     
003C: 7E       RETI                     (0174)     reti
                                        (0175) 
                                        (0176)     org   40h                      ;PSoC Block DBB20 Interrupt Vector
                                        (0177)     // call	void_handler
003D: 30       HALT                     
003E: 30       HALT                     
003F: 30       HALT                     
0040: 7E       RETI                     (0178)     reti
                                        (0179) 
                                        (0180)     org   44h                      ;PSoC Block DBB21 Interrupt Vector
                                        (0181)     // call	void_handler
0041: 30       HALT                     
0042: 30       HALT                     
0043: 30       HALT                     
0044: 7E       RETI                     (0182)     reti
                                        (0183) 
                                        (0184)     org   48h                      ;PSoC Block DCB22 Interrupt Vector
                                        (0185)     // call	void_handler
0045: 30       HALT                     
0046: 30       HALT                     
0047: 30       HALT                     
0048: 7E       RETI                     (0186)     reti
                                        (0187) 
                                        (0188)     org   4Ch                      ;PSoC Block DCB23 Interrupt Vector
                                        (0189)     // call	void_handler
0049: 30       HALT                     
004A: 30       HALT                     
004B: 30       HALT                     
004C: 7E       RETI                     (0190)     reti
                                        (0191) 
                                        (0192)     org   50h                      ;PSoC Block DBB30 Interrupt Vector
                                        (0193)     // call	void_handler
004D: 30       HALT                     
004E: 30       HALT                     
004F: 30       HALT                     
0050: 7E       RETI                     (0194)     reti
                                        (0195) 
                                        (0196)     org   54h                      ;PSoC Block DBB31 Interrupt Vector
                                        (0197)     // call	void_handler
0051: 30       HALT                     
0052: 30       HALT                     
0053: 30       HALT                     
0054: 7E       RETI                     (0198)     reti
                                        (0199) 
                                        (0200)     org   58h                      ;PSoC Block DCB32 Interrupt Vector
                                        (0201)     // call	void_handler
0055: 30       HALT                     
0056: 30       HALT                     
0057: 30       HALT                     
0058: 7E       RETI                     (0202)     reti
                                        (0203) 
                                        (0204)     org   5Ch                      ;PSoC Block DCB33 Interrupt Vector
                                        (0205)     // call	void_handler
0059: 30       HALT                     
005A: 30       HALT                     
005B: 30       HALT                     
005C: 7E       RETI                     (0206)     reti
                                        (0207) 
                                        (0208)     org   60h                      ;PSoC I2C Interrupt Vector
005D: 30       HALT                     
005E: 30       HALT                     
005F: 30       HALT                     
0060: 7D 04 F5 LJMP  0x04F5             (0209)     ljmp	_I2CHW_ISR
0063: 7E       RETI                     (0210)     reti
                                        (0211) 
                                        (0212)     org   64h                      ;Sleep Timer Interrupt Vector
                                        (0213)     // call	void_handler
0064: 7E       RETI                     (0214)     reti
                                        (0215) 
                                        (0216) ;-----------------------------------------------------------------------------
                                        (0217) ;  Start of Execution.
                                        (0218) ;-----------------------------------------------------------------------------
                                        (0219) ;  The Supervisory ROM SWBootReset function has already completed the
                                        (0220) ;  calibrate1 process, loading trim values for 5 volt operation.
                                        (0221) ;
                                        (0222) 
                                        (0223) IF	(TOOLCHAIN & HITECH)
                                        (0224)  	AREA PD_startup(CODE, REL, CON)
                                        (0225) ELSE
                                        (0226)     org 68h
                                        (0227) ENDIF
                                        (0228) __Start:
                                        (0229) 
                                        (0230)     ; initialize SMP values for voltage stabilization, if required,
                                        (0231)     ; leaving power-on reset (POR) level at the default (low) level, at
                                        (0232)     ; least for now. 
                                        (0233)     ;
0065: 30       HALT                     
0066: 30       HALT                     
0067: 30       HALT                     
0068: 71 10    OR    F,0x10             (0234)     M8C_SetBank1
006A: 62 FA 00 MOV   REG[0xFA],0x0      (0235)     mov reg[0FAh], 0				;Reset flash location
006D: 62 E3 86 MOV   REG[0xE3],0x86     (0236)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
0070: 70 EF    AND   F,0xEF             (0237)     M8C_SetBank0
                                        (0238) 
                                        (0239)     ; %53%20%46%46% Apply Erratum 001-05137 workaround
0072: 50 20    MOV   A,0x20             (0240)     mov   A, 20h
0074: 28       ROMX                     (0241)     romx
0075: 50 40    MOV   A,0x40             (0242)     mov   A, 40h
0077: 28       ROMX                     (0243)     romx
0078: 50 60    MOV   A,0x60             (0244)     mov   A, 60h
007A: 28       ROMX                     (0245)     romx
                                        (0246)     ; %45%20%46%46% End workaround
                                        (0247) 
                                        (0248) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                        (0249)     M8C_EnableWatchDog
                                        (0250) ENDIF
                                        (0251) 
                                        (0252) IF ( SELECT_32K )
                                        (0253)     or   reg[CPU_SCR1],  CPU_SCR1_ECO_ALLOWED  ; ECO will be used in this project
                                        (0254) ELSE
007B: 41 FE FB AND   REG[0xFE],0xFB     (0255)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                        (0256) ENDIF
                                        (0257) 
                                        (0258)     ;---------------------------
                                        (0259)     ; Set up the Temporary stack
                                        (0260)     ;---------------------------
                                        (0261)     ; A temporary stack is set up for the SSC instructions.
                                        (0262)     ; The real stack start will be assigned later.
                                        (0263)     ;
                                        (0264) _stack_start:          equ 80h
007E: 50 80    MOV   A,0x80             (0265)     mov   A, _stack_start          ; Set top of stack to end of used RAM
0080: 4E       SWAP  SP,A               (0266)     swap  SP, A                    ; This is only temporary if going to LMM
                                        (0267) 
                                        (0268)     ;-----------------------------------------------
                                        (0269)     ; Set Power-related Trim & the AGND Bypass bit.
                                        (0270)     ;-----------------------------------------------
                                        (0271) 
                                        (0272) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
                                        (0273)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0274)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0275)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                        (0276)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                        (0277)   IF ( AGND_BYPASS )
                                        (0278)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0279)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                        (0280)     ; bit in the write-only BDG_TR register. Recalculate the register
                                        (0281)     ; value using the proper trim values.
                                        (0282)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0283)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                        (0284)   ENDIF
                                        (0285)  ENDIF
                                        (0286) ENDIF ; 5.0 V Operation
                                        (0287) 
                                        (0288) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                        (0289)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0290)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0291)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                        (0292)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                        (0293)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                        (0294)  ENDIF
                                        (0295) ENDIF ; 3.3 Volt Operation
                                        (0296) 
0081: 55 F8 00 MOV   [0xF8],0x0         (0297)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
0084: 55 F9 00 MOV   [0xF9],0x0         (0298)     mov  [bSSC_KEYSP], 0
                                        (0299) 
                                        (0300)     ;---------------------------------------
                                        (0301)     ; Initialize Crystal Oscillator and PLL
                                        (0302)     ;---------------------------------------
                                        (0303) 
                                        (0304) IF ( SELECT_32K & WAIT_FOR_32K )
                                        (0305)     ; If the user has requested the External Crystal Oscillator (ECO) then turn it
                                        (0306)     ; on and wait for it to stabilize and the system to switch over to it. The PLL
                                        (0307)     ; is left off. Set the SleepTimer period is set to 1 sec to time the wait for
                                        (0308)     ; the ECO to stabilize.
                                        (0309)     ;
                                        (0310)     M8C_SetBank1
                                        (0311)     mov   reg[OSC_CR0], (SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz)
                                        (0312)     M8C_SetBank0
                                        (0313)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get a full second
                                        (0314)     or    reg[INT_MSK0], INT_MSK0_SLEEP   ; Enable latching of SleepTimer interrupt
                                        (0315)     mov   reg[INT_VC],   0                ; Clear all pending interrupts
                                        (0316) .WaitFor1s:
                                        (0317)     tst   reg[INT_CLR0], INT_MSK0_SLEEP   ; Test the SleepTimer Interrupt Status
                                        (0318)     jz   .WaitFor1s                       ; Interrupt will latch but will not dispatch
                                        (0319)                                           ;   since interrupts are not globally enabled
                                        (0320) ELSE ; !( SELECT_32K & WAIT_FOR_32K )
                                        (0321)     ; Either no ECO, or waiting for stable clock is to be done in main
0087: 71 10    OR    F,0x10             (0322)     M8C_SetBank1
0089: 62 E0 1A MOV   REG[0xE0],0x1A     (0323)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
008C: 70 EF    AND   F,0xEF             (0324)     M8C_SetBank0
008E: 62 E3 38 MOV   REG[0xE3],0x38     (0325)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0326) 
                                        (0327) ENDIF ;( SELECT_32K & WAIT_FOR_32K )
                                        (0328) 
                                        (0329) IF ( PLL_MODE )
                                        (0330)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was enabled).
                                        (0331)     ; Now start up PLL if selected, and wait 16 msec for it to stabilize.
                                        (0332)     ;
                                        (0333)     M8C_SetBank1
                                        (0334)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
                                        (0335)     M8C_SetBank0
                                        (0336)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get full period
                                        (0337)     mov   reg[INT_VC], 0                  ; Clear all pending interrupts
                                        (0338) 
                                        (0339) .WaitFor16ms:
                                        (0340)     tst   reg[INT_CLR0],INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0341)     jz   .WaitFor16ms
                                        (0342)     M8C_SetBank1                          ; continue boot at CPU Speed of SYSCLK/2
                                        (0343)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_12MHz)
                                        (0344)     M8C_SetBank0
                                        (0345) 
                                        (0346) IF      ( WAIT_FOR_32K )
                                        (0347) ELSE ; !( WAIT_FOR_32K )
                                        (0348)     ; Option settings (PLL-Yes, ECO-No) are incompatible - force a syntax error
                                        (0349)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
                                        (0350) ENDIF ;(WAIT_FOR_32K)
                                        (0351) ENDIF ;(PLL_MODE)
                                        (0352) 
                                        (0353)     ;------------------------
                                        (0354)     ; Close CT leakage path.
                                        (0355)     ;------------------------
0091: 62 71 05 MOV   REG[0x71],0x5      (0356)     mov   reg[ACB00CR0], 05h
0094: 62 75 05 MOV   REG[0x75],0x5      (0357)     mov   reg[ACB01CR0], 05h
0097: 62 79 05 MOV   REG[0x79],0x5      (0358)     mov   reg[ACB02CR0], 05h
009A: 62 7D 05 MOV   REG[0x7D],0x5      (0359)     mov   reg[ACB03CR0], 05h
                                        (0360) 
                                        (0361) 
                                        (0362) IF	(TOOLCHAIN & HITECH)
                                        (0363)     ;---------------------------------------------
                                        (0364)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                        (0365)     ;---------------------------------------------
                                        (0366) 	global		__Lstackps
                                        (0367) 	mov     a,low __Lstackps
                                        (0368) 	swap    a,sp
                                        (0369) 
                                        (0370) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0371)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                        (0372)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0373)     RAM_SETPAGE_CUR 0
                                        (0374)     RAM_SETPAGE_MVW 0
                                        (0375)     RAM_SETPAGE_MVR 0
                                        (0376)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                        (0377)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0378)     ELSE
                                        (0379)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0380)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0381) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0382) ELSE
                                        (0383)     ;---------------------------------------------
                                        (0384)     ; ImageCraft Enter the Large Memory Model, if applicable
                                        (0385)     ;---------------------------------------------
                                        (0386) IF ( SYSTEM_LARGE_MEMORY_MODEL )
009D: 62 D1 07 MOV   REG[0xD1],0x7      (0387)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
00A0: 50 00    MOV   A,0x0              (0388)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
00A2: 4E       SWAP  SP,A               (0389)     swap  A, SP
00A3: 62 D3 07 MOV   REG[0xD3],0x7      (0390)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
00A6: 62 D0 00 MOV   REG[0xD0],0x0      (0391)     RAM_SETPAGE_CUR 0
00A9: 62 D5 00 MOV   REG[0xD5],0x0      (0392)     RAM_SETPAGE_MVW 0
00AC: 62 D4 00 MOV   REG[0xD4],0x0      (0393)     RAM_SETPAGE_MVR 0
                                        (0394) 
                                        (0395)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
00AF: 71 C0    OR    F,0xC0             (0396)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0397)   ELSE
                                        (0398)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0399)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0400) ELSE
                                        (0401)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
                                        (0402)     swap  SP, A
                                        (0403) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0404) ENDIF ;	TOOLCHAIN
                                        (0405) 
                                        (0406)     ;-------------------------
                                        (0407)     ; Load Base Configuration
                                        (0408)     ;-------------------------
                                        (0409)     ; Load global parameter settings and load the user modules in the
                                        (0410)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                        (0411)     ; to minimize start up time; (2) We may still need to play with the
                                        (0412)     ; Sleep Timer.
                                        (0413)     ;
00B1: 7C 03 99 LCALL 0x0399             (0414)     lcall LoadConfigInit
                                        (0415) 
                                        (0416)     ;-----------------------------------
                                        (0417)     ; Initialize C Run-Time Environment
                                        (0418)     ;-----------------------------------
                                        (0419) IF ( C_LANGUAGE_SUPPORT )
                                        (0420) IF ( SYSTEM_SMALL_MEMORY_MODEL )
                                        (0421)     mov  A,0                           ; clear the 'bss' segment to zero
                                        (0422)     mov  [__r0],<__bss_start
                                        (0423) BssLoop:
                                        (0424)     cmp  [__r0],<__bss_end
                                        (0425)     jz   BssDone
                                        (0426)     mvi  [__r0],A
                                        (0427)     jmp  BssLoop
                                        (0428) BssDone:
                                        (0429)     mov  A,>__idata_start              ; copy idata to data segment
                                        (0430)     mov  X,<__idata_start
                                        (0431)     mov  [__r0],<__data_start
                                        (0432) IDataLoop:
                                        (0433)     cmp  [__r0],<__data_end
                                        (0434)     jz   C_RTE_Done
                                        (0435)     push A
                                        (0436)     romx
                                        (0437)     mvi  [__r0],A
                                        (0438)     pop  A
                                        (0439)     inc  X
                                        (0440)     adc  A,0
                                        (0441)     jmp  IDataLoop
                                        (0442) 
                                        (0443) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                        (0444) 
                                        (0445) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00B4: 62 D0 00 MOV   REG[0xD0],0x0      (0446)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                        (0447)                                        ; to use the Virtual Register page.
                                        (0448) 
                                        (0449)     ; Dereference the constant (flash) pointer pXIData to access the start
                                        (0450)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                        (0451)     ; text segment and may have been relocated by the Code Compressor.
                                        (0452)     ;
00B7: 50 03    MOV   A,0x3              (0453)     mov   A, >__pXIData                ; Get the address of the flash
00B9: 57 97    MOV   X,0x97             (0454)     mov   X, <__pXIData                ;   pointer to the xidata area.
00BB: 08       PUSH  A                  (0455)     push  A
00BC: 28       ROMX                     (0456)     romx                               ; get the MSB of xidata's address
00BD: 53 13    MOV   [__r0],A           (0457)     mov   [__r0], A
00BF: 18       POP   A                  (0458)     pop   A
00C0: 75       INC   X                  (0459)     inc   X
00C1: 09 00    ADC   A,0x0              (0460)     adc   A, 0
00C3: 28       ROMX                     (0461)     romx                               ; get the LSB of xidata's address
00C4: 4B       SWAP  A,X                (0462)     swap  A, X
00C5: 51 13    MOV   A,[__r0]           (0463)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                        (0464)                                        ;   XIData structure list in flash
00C7: 80 04    JMP   0x00CC             (0465)     jmp   .AccessStruct
                                        (0466) 
                                        (0467)     ; Unpack one element in the xidata "structure list" that specifies the
                                        (0468)     ; values of C variables. Each structure contains 3 member elements.
                                        (0469)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                        (0470)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                        (0471)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                        (0472)     ; contains 0xFF. There are two formats for the struct depending on the
                                        (0473)     ; value in the second member element, an unsigned byte:
                                        (0474)     ; (1) If the value of the second element is non-zero, it represents
                                        (0475)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                        (0476)     ; third member of the struct is an array of bytes of length 'size' and
                                        (0477)     ; the bytes are copied to the block of RAM.
                                        (0478)     ; (2) If the value of the second element is zero, the block of RAM is
                                        (0479)     ; to be cleared to zero. In this case, the third member of the struct
                                        (0480)     ; is an unsigned byte containing the number of bytes to clear.
                                        (0481) 
                                        (0482) .AccessNextStructLoop:
00C9: 75       INC   X                  (0483)     inc   X                            ; pXIData++
00CA: 09 00    ADC   A,0x0              (0484)     adc   A, 0
                                        (0485) .AccessStruct:                         ; Entry point for first block
                                        (0486)     ;
                                        (0487)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                        (0488)     ;
00CC: 62 E3 00 MOV   REG[0xE3],0x0      (0489)     M8C_ClearWDT                       ; Clear the watchdog for long inits
00CF: 08       PUSH  A                  (0490)     push  A
00D0: 28       ROMX                     (0491)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
00D1: 60 D5    MOV   REG[0xD5],A        (0492)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
00D3: 74       INC   A                  (0493)     inc   A                            ; End of Struct List? (MSB==0xFF?)
00D4: A0 4B    JZ    0x0120             (0494)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
00D6: 18       POP   A                  (0495)     pop   A                            ; restore pXIData to [A,X]
00D7: 75       INC   X                  (0496)     inc   X                            ; pXIData++
00D8: 09 00    ADC   A,0x0              (0497)     adc   A, 0
00DA: 08       PUSH  A                  (0498)     push  A
00DB: 28       ROMX                     (0499)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
00DC: 53 13    MOV   [__r0],A           (0500)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
00DE: 18       POP   A                  (0501)     pop   A                            ; restore pXIData to [A,X]
00DF: 75       INC   X                  (0502)     inc   X                            ; pXIData++ (point to size)
00E0: 09 00    ADC   A,0x0              (0503)     adc   A, 0
00E2: 08       PUSH  A                  (0504)     push  A
00E3: 28       ROMX                     (0505)     romx                               ; Get the size (CPU.A <- *pXIData)
00E4: A0 1C    JZ    0x0101             (0506)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
00E6: 53 12    MOV   [__r1],A           (0507)     mov   [__r1], A                    ;             else downcount in __r1
00E8: 18       POP   A                  (0508)     pop   A                            ; restore pXIData to [A,X]
                                        (0509) 
                                        (0510) .CopyNextByteLoop:
                                        (0511)     ; For each byte in the structure's array member, copy from flash to RAM.
                                        (0512)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                        (0513)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                        (0514)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0515)     ;
00E9: 75       INC   X                  (0516)     inc   X                            ; pXIData++ (point to next data byte)
00EA: 09 00    ADC   A,0x0              (0517)     adc   A, 0
00EC: 08       PUSH  A                  (0518)     push  A
00ED: 28       ROMX                     (0519)     romx                               ; Get the data value (CPU.A <- *pXIData)
00EE: 3F 13    MVI   [__r0],A           (0520)     mvi   [__r0], A                    ; Transfer the data to RAM
00F0: 47 13 FF TST   [__r0],0xFF        (0521)     tst   [__r0], 0xff                 ; Check for page crossing
00F3: B0 06    JNZ   0x00FA             (0522)     jnz   .CopyLoopTail                ;   No crossing, keep going
00F5: 5D D5    MOV   A,REG[0xD5]        (0523)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
00F7: 74       INC   A                  (0524)     inc   A
00F8: 60 D5    MOV   REG[0xD5],A        (0525)     mov   reg[ MVW_PP], A
                                        (0526) .CopyLoopTail:
00FA: 18       POP   A                  (0527)     pop   A                            ; restore pXIData to [A,X]
00FB: 7A 12    DEC   [__r1]             (0528)     dec   [__r1]                       ; End of this array in flash?
00FD: BF EB    JNZ   0x00E9             (0529)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
00FF: 8F C9    JMP   0x00C9             (0530)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                        (0531) 
                                        (0532) .ClearRAMBlockToZero:
0101: 18       POP   A                  (0533)     pop   A                            ; restore pXIData to [A,X]
0102: 75       INC   X                  (0534)     inc   X                            ; pXIData++ (point to next data byte)
0103: 09 00    ADC   A,0x0              (0535)     adc   A, 0
0105: 08       PUSH  A                  (0536)     push  A
0106: 28       ROMX                     (0537)     romx                               ; Get the run length (CPU.A <- *pXIData)
0107: 53 12    MOV   [__r1],A           (0538)     mov   [__r1], A                    ; Initialize downcounter
0109: 50 00    MOV   A,0x0              (0539)     mov   A, 0                         ; Initialize source data
                                        (0540) 
                                        (0541) .ClearRAMBlockLoop:
                                        (0542)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                        (0543)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0544)     ;
010B: 3F 13    MVI   [__r0],A           (0545)     mvi   [__r0], A                    ; Clear a byte
010D: 47 13 FF TST   [__r0],0xFF        (0546)     tst   [__r0], 0xff                 ; Check for page crossing
0110: B0 08    JNZ   0x0119             (0547)     jnz   .ClearLoopTail               ;   No crossing, keep going
0112: 5D D5    MOV   A,REG[0xD5]        (0548)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
0114: 74       INC   A                  (0549)     inc   A
0115: 60 D5    MOV   REG[0xD5],A        (0550)     mov   reg[ MVW_PP], A
0117: 50 00    MOV   A,0x0              (0551)     mov   A, 0                         ; Restore the zero used for clearing
                                        (0552) .ClearLoopTail:
0119: 7A 12    DEC   [__r1]             (0553)     dec   [__r1]                       ; Was this the last byte?
011B: BF EF    JNZ   0x010B             (0554)     jnz   .ClearRAMBlockLoop           ;   No,  continue
011D: 18       POP   A                  (0555)     pop   A                            ;   Yes, restore pXIData to [A,X] and
011E: 8F AA    JMP   0x00C9             (0556)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                        (0557) 
                                        (0558) .C_RTE_WrapUp:
0120: 18       POP   A                  (0559)     pop   A                            ; balance stack
                                        (0560) 
                                        (0561) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                                        (0562) 
                                        (0563) C_RTE_Done:
                                        (0564) 
                                        (0565) ENDIF ; C_LANGUAGE_SUPPORT
                                        (0566) 
                                        (0567)     ;-------------------------------
                                        (0568)     ; Voltage Stabilization for SMP
                                        (0569)     ;-------------------------------
                                        (0570) 
                                        (0571) IF ( POWER_SETTING & POWER_SET_5V0)    ; 5.0V Operation
                                        (0572) IF ( SWITCH_MODE_PUMP ^ 1 )            ; SMP is operational
                                        (0573)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0574)     ; When using the SMP at 5V, we must wait for Vdd to slew from 3.1V to
                                        (0575)     ; 5V before enabling the Precision Power-On Reset (PPOR).
                                        (0576)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0577)     or   reg[INT_MSK0],INT_MSK0_SLEEP
                                        (0578)     M8C_SetBank1
                                        (0579)     and   reg[OSC_CR0], ~OSC_CR0_SLEEP
                                        (0580)     or    reg[OSC_CR0],  OSC_CR0_SLEEP_512Hz
                                        (0581)     M8C_SetBank0
                                        (0582)     M8C_ClearWDTAndSleep                   ; Restart the sleep timer
                                        (0583)     mov   reg[INT_VC], 0                   ; Clear all pending interrupts
                                        (0584) .WaitFor2ms:
                                        (0585)     tst   reg[INT_CLR0], INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0586)     jz   .WaitFor2ms                       ; Branch fails when 2 msec has passed
                                        (0587) ENDIF ; SMP is operational
                                        (0588) ENDIF ; 5.0V Operation
                                        (0589) 
                                        (0590)     ;-------------------------------
                                        (0591)     ; Set Power-On Reset (POR) Level
                                        (0592)     ;-------------------------------
                                        (0593) 
                                        (0594)     ;  The writes to the VLT_CR register below include setting the POR to VLT_CR_POR_HIGH,
                                        (0595)     ;  VLT_CR_POR_MID or VLT_CR_POR_LOW. Correctly setting this value is critical to the proper
                                        (0596)     ;  operation of the PSoC. The POR protects the M8C from mis-executing when Vdd falls low. These
                                        (0597)     ;  values should not be changed from the settings here. Failure to follow this instruction could 
                                        (0598)     ;  lead to corruption of PSoC flash.
                                        (0599) 
0121: 71 10    OR    F,0x10             (0600)     M8C_SetBank1
                                        (0601) 
                                        (0602) IF (POWER_SETTING & POWER_SET_5V0)          ; 5.0V Operation?
                                        (0603)  IF (POWER_SETTING & POWER_SET_SLOW_IMO)    ; and Slow Mode?
                                        (0604)  ELSE                                       ;    No, fast mode
                                        (0605)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz ) ;    As fast as 24MHz?
                                        (0606)                                             ;       no, set midpoint POR in user code, if desired
                                        (0607)   ELSE ; 24HMz                              ;
0123: 43 E3 20 OR    REG[0xE3],0x20     (0608)     or    reg[VLT_CR],  VLT_CR_POR_HIGH     ;      yes, highest POR trip point required
                                        (0609)   ENDIF ; 24MHz
                                        (0610)  ENDIF ; Slow Mode
                                        (0611) ENDIF ; 5.0V Operation
                                        (0612) 
0126: 70 EF    AND   F,0xEF             (0613)     M8C_SetBank0
                                        (0614) 
                                        (0615)     ;----------------------------
                                        (0616)     ; Wrap up and invoke "main"
                                        (0617)     ;----------------------------
                                        (0618) 
                                        (0619)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                        (0620)     ; no interrupts should be enabled now, so may as well clear the register.
                                        (0621)     ;
0128: 62 E0 00 MOV   REG[0xE0],0x0      (0622)     mov  reg[INT_MSK0],0
                                        (0623) 
                                        (0624)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                        (0625)     ; And put decimator in full mode so it does not consume too much current.
                                        (0626)     ;
012B: 71 10    OR    F,0x10             (0627)     M8C_SetBank1
012D: 62 E0 1B MOV   REG[0xE0],0x1B     (0628)     mov  reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
0130: 43 E7 80 OR    REG[0xE7],0x80     (0629)     or   reg[DEC_CR2],80h                    ; Put decimator in full mode
0133: 70 EF    AND   F,0xEF             (0630)     M8C_SetBank0
                                        (0631) 
                                        (0632)     ; Global Interrupt are NOT enabled, this should be done in main().
                                        (0633)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                        (0634)     ; Global Interrupts should be enabled as soon as possible in main().
                                        (0635)     ;
0135: 62 E2 00 MOV   REG[0xE2],0x0      (0636)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                        (0637)                                    ; have been set during the boot process.
                                        (0638) IF	(TOOLCHAIN & HITECH)
                                        (0639) 	ljmp  startup                  ; Jump to C compiler startup code
                                        (0640) ELSE
                                        (0641) IF ENABLE_LJMP_TO_MAIN
                                        (0642)     ljmp  _main                    ; goto main (no return)
                                        (0643) ELSE
0138: 7C 09 79 LCALL _main|__text_start|_main(0644)     lcall _main                    ; call main
                                        (0645) .Exit:
013B: 8F FF    JMP   0x013B             (0646)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                        (0647) ENDIF
                                        (0648) ENDIF ; TOOLCHAIN
                                        (0649) 
                                        (0650)     ;---------------------------------
                                        (0651)     ; Library Access to Global Parms
                                        (0652)     ;---------------------------------
                                        (0653)     ;
                                        (0654)  bGetPowerSetting:
                                        (0655) _bGetPowerSetting:
                                        (0656)     ; Returns value of POWER_SETTING in the A register.
                                        (0657)     ; No inputs. No Side Effects.
                                        (0658)     ;
013D: 50 10    MOV   A,0x10             (0659)     mov   A, POWER_SETTING
013F: 7F       RET                      (0660)     ret
(0661) 
(0662) IF	(TOOLCHAIN & HITECH)
(0663) ELSE
(0664)     ;---------------------------------
(0665)     ; Order Critical RAM & ROM AREAs
(0666)     ;---------------------------------
(0667)     ;  'TOP' is all that has been defined so far...
(0668) 
(0669)     ;  ROM AREAs for C CONST, static & global items
(0670)     ;
(0671)     AREA lit               (ROM, REL, CON)   ; 'const' definitions
(0672)     AREA idata             (ROM, REL, CON)   ; Constants for initializing RAM
(0673) __idata_start:
(0674) 
(0675)     AREA func_lit          (ROM, REL, CON)   ; Function Pointers
(0676) __func_lit_start:
(0677) 
(0678) IF ( SYSTEM_LARGE_MEMORY_MODEL )
(0679)     ; We use the func_lit area to store a pointer to extended initialized
(0680)     ; data (xidata) area that follows the text area. Func_lit isn't
(0681)     ; relocated by the code compressor, but the text area may shrink and
(0682)     ; that moves xidata around.
(0683)     ;
(0684) __pXIData:         word __text_end           ; ptr to extended idata
(0685) ENDIF
(0686) 
(0687)     AREA psoc_config       (ROM, REL, CON)   ; Configuration Load & Unload
(0688)     AREA UserModules       (ROM, REL, CON)   ; User Module APIs
(0689) 
(0690)     ; CODE segment for general use
(0691)     ;
(0692)     AREA text (ROM, REL, CON)
(0693) __text_start:
(0694) 
(0695)     ; RAM area usage
(0696)     ;
(0697)     AREA data              (RAM, REL, CON)   ; initialized RAM
(0698) __data_start:
(0699) 
(0700)     AREA virtual_registers (RAM, REL, CON)   ; Temp vars of C compiler
(0701)     AREA InterruptRAM      (RAM, REL, CON)   ; Interrupts, on Page 0
(0702)     AREA bss               (RAM, REL, CON)   ; general use
(0703) __bss_start:
(0704) 
(0705) ENDIF ; TOOLCHAIN
(0706) 
(0707) ; end of file boot.asm
FILE: lib\psocconfigtbl.asm
                                        (0001) ; Generated by PSoC Designer 5.0.1127.0
                                        (0002) ;
                                        (0003) include "m8c.inc"
                                        (0004) ;  Personalization tables 
                                        (0005) export LoadConfigTBL_explorersound_Bank1
                                        (0006) export LoadConfigTBL_explorersound_Bank0
                                        (0007) export LoadConfigTBL_explorersound_Ordered
                                        (0008) AREA lit(rom, rel)
                                        (0009) LoadConfigTBL_explorersound_Bank0:
                                        (0010) ;  Instance name ADCINCVR_mes, User Module ADCINCVR
                                        (0011) ;       Instance name ADCINCVR_mes, Block Name ADC(ASD13)
                                        (0012) 	db		8ch, 90h		;ADCINCVR_mes_bfAtoDcr0       (ASD13CR0)
                                        (0013) 	db		8dh, 20h		;ADCINCVR_mes_bfAtoDcr1       (ASD13CR1)
                                        (0014) 	db		8eh, 61h		;ADCINCVR_mes_bfAtoDcr2       (ASD13CR2)
                                        (0015) 	db		8fh, f0h		;ADCINCVR_mes_bfAtoDcr3       (ASD13CR3)
                                        (0016) ;       Instance name ADCINCVR_mes, Block Name CNT(DBB00)
                                        (0017) 	db		23h, 00h		;ADCINCVR_mes_bCounter_CR0    (DBB00CR0)
                                        (0018) 	db		21h, 00h		;ADCINCVR_mes_bPeriod         (DBB00DR1)
                                        (0019) 	db		22h, 00h		;ADCINCVR_mes_bCompare        (DBB00DR2)
                                        (0020) ;       Instance name ADCINCVR_mes, Block Name PWM16_LSB(DBB01)
                                        (0021) 	db		27h, 00h		;ADCINCVR_mes_fPWM_LSB_CR0    (DBB01CR0)
                                        (0022) 	db		25h, 00h		;ADCINCVR_mes_bPWM_Period_LSB (DBB01DR1)
                                        (0023) 	db		26h, 00h		;ADCINCVR_mes_bPWM_IntTime_LSB(DBB01DR2)
                                        (0024) ;       Instance name ADCINCVR_mes, Block Name PWM16_MSB(DCB02)
                                        (0025) 	db		2bh, 00h		;ADCINCVR_mes_fPWM_MSB_CR0    (DCB02CR0)
                                        (0026) 	db		29h, 00h		;ADCINCVR_mes_bPWM_Period_MSB (DCB02DR1)
                                        (0027) 	db		2ah, 00h		;ADCINCVR_mes_bPWM_IntTime_MSB(DCB02DR2)
                                        (0028) ;  Instance name ADCINCVR_pot, User Module ADCINCVR
                                        (0029) ;       Instance name ADCINCVR_pot, Block Name ADC(ASD22)
                                        (0030) 	db		98h, 90h		;ADCINCVR_pot_bfAtoDcr0       (ASD22CR0)
                                        (0031) 	db		99h, 40h		;ADCINCVR_pot_bfAtoDcr1       (ASD22CR1)
                                        (0032) 	db		9ah, 61h		;ADCINCVR_pot_bfAtoDcr2       (ASD22CR2)
                                        (0033) 	db		9bh, f0h		;ADCINCVR_pot_bfAtoDcr3       (ASD22CR3)
                                        (0034) ;       Instance name ADCINCVR_pot, Block Name CNT(DCB03)
                                        (0035) 	db		2fh, 00h		;ADCINCVR_pot_bCounter_CR0    (DCB03CR0)
                                        (0036) 	db		2dh, 00h		;ADCINCVR_pot_bPeriod         (DCB03DR1)
                                        (0037) 	db		2eh, 00h		;ADCINCVR_pot_bCompare        (DCB03DR2)
                                        (0038) ;       Instance name ADCINCVR_pot, Block Name PWM16_LSB(DBB10)
                                        (0039) 	db		33h, 00h		;ADCINCVR_pot_fPWM_LSB_CR0    (DBB10CR0)
                                        (0040) 	db		31h, 00h		;ADCINCVR_pot_bPWM_Period_LSB (DBB10DR1)
                                        (0041) 	db		32h, 00h		;ADCINCVR_pot_bPWM_IntTime_LSB(DBB10DR2)
                                        (0042) ;       Instance name ADCINCVR_pot, Block Name PWM16_MSB(DBB11)
                                        (0043) 	db		37h, 00h		;ADCINCVR_pot_fPWM_MSB_CR0    (DBB11CR0)
                                        (0044) 	db		35h, 00h		;ADCINCVR_pot_bPWM_Period_MSB (DBB11DR1)
                                        (0045) 	db		36h, 00h		;ADCINCVR_pot_bPWM_IntTime_MSB(DBB11DR2)
                                        (0046) ;  Instance name AMUX4_mic, User Module AMUX4
                                        (0047) ;  Instance name BPF4_4KHz, User Module BPF4
                                        (0048) ;       Instance name BPF4_4KHz, Block Name FLFBH(ASD11)
                                        (0049) 	db		84h, 85h		;BPF4_4KHz_FLFBH_CR0(ASD11CR0)
                                        (0050) 	db		85h, 60h		;BPF4_4KHz_FLFBH_CR1(ASD11CR1)
                                        (0051) 	db		86h, 00h		;BPF4_4KHz_FLFBH_CR2(ASD11CR2)
                                        (0052) 	db		87h, 20h		;BPF4_4KHz_FLFBH_CR3(ASD11CR3)
                                        (0053) ;       Instance name BPF4_4KHz, Block Name FLFBL(ASD20)
                                        (0054) 	db		90h, 85h		;BPF4_4KHz_FLFBL_CR0(ASD20CR0)
                                        (0055) 	db		91h, 00h		;BPF4_4KHz_FLFBL_CR1(ASD20CR1)
                                        (0056) 	db		92h, 00h		;BPF4_4KHz_FLFBL_CR2(ASD20CR2)
                                        (0057) 	db		93h, 20h		;BPF4_4KHz_FLFBL_CR3(ASD20CR3)
                                        (0058) ;       Instance name BPF4_4KHz, Block Name FLINH(ASC21)
                                        (0059) 	db		94h, a1h		;BPF4_4KHz_FLINH_CR0(ASC21CR0)
                                        (0060) 	db		95h, 94h		;BPF4_4KHz_FLINH_CR1(ASC21CR1)
                                        (0061) 	db		96h, 85h		;BPF4_4KHz_FLINH_CR2(ASC21CR2)
                                        (0062) 	db		97h, 20h		;BPF4_4KHz_FLINH_CR3(ASC21CR3)
                                        (0063) ;       Instance name BPF4_4KHz, Block Name FLINL(ASC10)
                                        (0064) 	db		80h, a1h		;BPF4_4KHz_FLINL_CR0(ASC10CR0)
                                        (0065) 	db		81h, b3h		;BPF4_4KHz_FLINL_CR1(ASC10CR1)
                                        (0066) 	db		82h, 05h		;BPF4_4KHz_FLINL_CR2(ASC10CR2)
                                        (0067) 	db		83h, 2ch		;BPF4_4KHz_FLINL_CR3(ASC10CR3)
                                        (0068) ;  Instance name I2CHW, User Module I2CHW
                                        (0069) ;  Instance name PGA_out, User Module PGA
                                        (0070) ;       Instance name PGA_out, Block Name GAIN(ACB02)
                                        (0071) 	db		79h, 1dh		;PGA_out_GAIN_CR0(ACB02CR0)
                                        (0072) 	db		7ah, a1h		;PGA_out_GAIN_CR1(ACB02CR1)
                                        (0073) 	db		7bh, 20h		;PGA_out_GAIN_CR2(ACB02CR2)
                                        (0074) 	db		78h, 00h		;PGA_out_GAIN_CR3(ACB02CR3)
                                        (0075) ;  Instance name PGA_pre, User Module PGA
                                        (0076) ;       Instance name PGA_pre, Block Name GAIN(ACB00)
                                        (0077) 	db		71h, 4dh		;PGA_pre_GAIN_CR0(ACB00CR0)
                                        (0078) 	db		72h, a1h		;PGA_pre_GAIN_CR1(ACB00CR1)
                                        (0079) 	db		73h, 20h		;PGA_pre_GAIN_CR2(ACB00CR2)
                                        (0080) 	db		70h, 00h		;PGA_pre_GAIN_CR3(ACB00CR3)
                                        (0081) ;  Instance name RefMux_1, User Module RefMux
                                        (0082) ;       Instance name RefMux_1, Block Name REFMUX(ACB03)
                                        (0083) 	db		7dh, 01h		;RefMux_1_REFMUX_CR0(ACB03CR0)
                                        (0084) 	db		7eh, 09h		;RefMux_1_REFMUX_CR1(ACB03CR1)
                                        (0085) 	db		7fh, 14h		;RefMux_1_REFMUX_CR2(ACB03CR2)
                                        (0086) 	db		7ch, 00h		;RefMux_1_REFMUX_CR3(ACB03CR3)
                                        (0087) ;  Instance name SCBLOCK_inbuff, User Module SCBLOCK
                                        (0088) ;       Instance name SCBLOCK_inbuff, Block Name SCBLK(ASC23)
                                        (0089) 	db		9ch, 10h		;SCBLOCK_inbuff_cr0(ASC23CR0)
                                        (0090) 	db		9dh, 70h		;SCBLOCK_inbuff_cr1(ASC23CR1)
                                        (0091) 	db		9eh, 20h		;SCBLOCK_inbuff_cr2(ASC23CR2)
                                        (0092) 	db		9fh, 3bh		;SCBLOCK_inbuff_cr3(ASC23CR3)
                                        (0093) ;  Global Register values Bank 0
                                        (0094) 	db		60h, e4h		; AnalogColumnInputSelect register (AMX_IN)
                                        (0095) 	db		66h, 00h		; AnalogComparatorControl1 register (CMP_CR1)
                                        (0096) 	db		63h, 57h		; AnalogReferenceControl register (ARF_CR)
                                        (0097) 	db		65h, 00h		; AnalogSyncControl register (ASY_CR)
                                        (0098) 	db		e6h, 00h		; DecimatorControl_0 register (DEC_CR0)
                                        (0099) 	db		e7h, 00h		; DecimatorControl_1 register (DEC_CR1)
                                        (0100) 	db		d6h, 04h		; I2CConfig register (I2C_CFG)
                                        (0101) 	db		b0h, 00h		; Row_0_InputMux register (RDI0RI)
                                        (0102) 	db		b1h, 00h		; Row_0_InputSync register (RDI0SYN)
                                        (0103) 	db		b2h, 00h		; Row_0_LogicInputAMux register (RDI0IS)
                                        (0104) 	db		b3h, 33h		; Row_0_LogicSelect_0 register (RDI0LT0)
                                        (0105) 	db		b4h, 33h		; Row_0_LogicSelect_1 register (RDI0LT1)
                                        (0106) 	db		b5h, 00h		; Row_0_OutputDrive_0 register (RDI0SRO0)
                                        (0107) 	db		b6h, 00h		; Row_0_OutputDrive_1 register (RDI0SRO1)
                                        (0108) 	db		b8h, 55h		; Row_1_InputMux register (RDI1RI)
                                        (0109) 	db		b9h, 00h		; Row_1_InputSync register (RDI1SYN)
                                        (0110) 	db		bah, 10h		; Row_1_LogicInputAMux register (RDI1IS)
                                        (0111) 	db		bbh, 33h		; Row_1_LogicSelect_0 register (RDI1LT0)
                                        (0112) 	db		bch, 33h		; Row_1_LogicSelect_1 register (RDI1LT1)
                                        (0113) 	db		bdh, 00h		; Row_1_OutputDrive_0 register (RDI1SRO0)
                                        (0114) 	db		beh, 00h		; Row_1_OutputDrive_1 register (RDI1SRO1)
                                        (0115) 	db		c0h, 00h		; Row_2_InputMux register (RDI2RI)
                                        (0116) 	db		c1h, 00h		; Row_2_InputSync register (RDI2SYN)
                                        (0117) 	db		c2h, 20h		; Row_2_LogicInputAMux register (RDI2IS)
                                        (0118) 	db		c3h, 33h		; Row_2_LogicSelect_0 register (RDI2LT0)
                                        (0119) 	db		c4h, 33h		; Row_2_LogicSelect_1 register (RDI3LT1)
                                        (0120) 	db		c5h, 00h		; Row_2_OutputDrive_0 register (RDI2SRO0)
                                        (0121) 	db		c6h, 00h		; Row_2_OutputDrive_1 register (RDI2SRO1)
                                        (0122) 	db		c8h, 55h		; Row_3_InputMux register (RDI3RI)
                                        (0123) 	db		c9h, 00h		; Row_3_InputSync register (RDI3SYN)
                                        (0124) 	db		cah, 30h		; Row_3_LogicInputAMux register (RDI3IS)
                                        (0125) 	db		cbh, 33h		; Row_3_LogicSelect_0 register (RDI3LT0)
                                        (0126) 	db		cch, 33h		; Row_3_LogicSelect_1 register (RDI3LT1)
                                        (0127) 	db		cdh, 00h		; Row_3_OutputDrive_0 register (RDI3SRO0)
                                        (0128) 	db		ceh, 00h		; Row_3_OutputDrive_1 register (RDI3SRO1)
                                        (0129) 	db		6ch, 00h		; TMP_DR0 register (TMP_DR0)
                                        (0130) 	db		6dh, 00h		; TMP_DR1 register (TMP_DR1)
                                        (0131) 	db		6eh, 00h		; TMP_DR2 register (TMP_DR2)
                                        (0132) 	db		6fh, 00h		; TMP_DR3 register (TMP_DR3)
                                        (0133) 	db		ffh
                                        (0134) LoadConfigTBL_explorersound_Bank1:
                                        (0135) ;  Instance name ADCINCVR_mes, User Module ADCINCVR
                                        (0136) ;       Instance name ADCINCVR_mes, Block Name ADC(ASD13)
                                        (0137) ;       Instance name ADCINCVR_mes, Block Name CNT(DBB00)
                                        (0138) 	db		20h, 21h		;ADCINCVR_mes_fCounterFN      (DBB00FN)
                                        (0139) 	db		21h, 75h		;ADCINCVR_mes_fCounterSL      (DBB00IN)
                                        (0140) 	db		22h, 40h		;ADCINCVR_mes_fCounterOS      (DBB00OU)
                                        (0141) ;       Instance name ADCINCVR_mes, Block Name PWM16_LSB(DBB01)
                                        (0142) 	db		24h, 01h		;ADCINCVR_mes_bfPWM_LSB_FN    (DBB01FN)
                                        (0143) 	db		25h, 15h		;ADCINCVR_mes_(DBB01IN)
                                        (0144) 	db		26h, 40h		;ADCINCVR_mes_(DBB01OU)
                                        (0145) ;       Instance name ADCINCVR_mes, Block Name PWM16_MSB(DCB02)
                                        (0146) 	db		28h, 21h		;ADCINCVR_mes_bfPWM_MSB_FN    (DCB02FN)
                                        (0147) 	db		29h, 35h		;ADCINCVR_mes_(DCB02IN)
                                        (0148) 	db		2ah, 40h		;ADCINCVR_mes_(DCB02OU)
                                        (0149) ;  Instance name ADCINCVR_pot, User Module ADCINCVR
                                        (0150) ;       Instance name ADCINCVR_pot, Block Name ADC(ASD22)
                                        (0151) ;       Instance name ADCINCVR_pot, Block Name CNT(DCB03)
                                        (0152) 	db		2ch, 21h		;ADCINCVR_pot_fCounterFN      (DCB03FN)
                                        (0153) 	db		2dh, 66h		;ADCINCVR_pot_fCounterSL      (DCB03IN)
                                        (0154) 	db		2eh, 40h		;ADCINCVR_pot_fCounterOS      (DCB03OU)
                                        (0155) ;       Instance name ADCINCVR_pot, Block Name PWM16_LSB(DBB10)
                                        (0156) 	db		30h, 01h		;ADCINCVR_pot_bfPWM_LSB_FN    (DBB10FN)
                                        (0157) 	db		31h, 16h		;ADCINCVR_pot_(DBB10IN)
                                        (0158) 	db		32h, 40h		;ADCINCVR_pot_(DBB10OU)
                                        (0159) ;       Instance name ADCINCVR_pot, Block Name PWM16_MSB(DBB11)
                                        (0160) 	db		34h, 21h		;ADCINCVR_pot_bfPWM_MSB_FN    (DBB11FN)
                                        (0161) 	db		35h, 36h		;ADCINCVR_pot_(DBB11IN)
                                        (0162) 	db		36h, 40h		;ADCINCVR_pot_(DBB11OU)
                                        (0163) ;  Instance name AMUX4_mic, User Module AMUX4
                                        (0164) ;  Instance name BPF4_4KHz, User Module BPF4
                                        (0165) ;       Instance name BPF4_4KHz, Block Name FLFBH(ASD11)
                                        (0166) ;       Instance name BPF4_4KHz, Block Name FLFBL(ASD20)
                                        (0167) ;       Instance name BPF4_4KHz, Block Name FLINH(ASC21)
                                        (0168) ;       Instance name BPF4_4KHz, Block Name FLINL(ASC10)
                                        (0169) ;  Instance name I2CHW, User Module I2CHW
                                        (0170) ;  Instance name PGA_out, User Module PGA
                                        (0171) ;       Instance name PGA_out, Block Name GAIN(ACB02)
                                        (0172) ;  Instance name PGA_pre, User Module PGA
                                        (0173) ;       Instance name PGA_pre, Block Name GAIN(ACB00)
                                        (0174) ;  Instance name RefMux_1, User Module RefMux
                                        (0175) ;       Instance name RefMux_1, Block Name REFMUX(ACB03)
                                        (0176) ;  Instance name SCBLOCK_inbuff, User Module SCBLOCK
                                        (0177) ;       Instance name SCBLOCK_inbuff, Block Name SCBLK(ASC23)
                                        (0178) ;  Global Register values Bank 1
                                        (0179) 	db		61h, 00h		; AnalogClockSelect1 register (CLK_CR1)
                                        (0180) 	db		69h, 00h		; AnalogClockSelect2 register (CLK_CR2)
                                        (0181) 	db		60h, 05h		; AnalogColumnClockSelect register (CLK_CR0)
                                        (0182) 	db		62h, 3dh		; AnalogIOControl_0 register (ABF_CR0)
                                        (0183) 	db		67h, 33h		; AnalogLUTControl0 register (ALT_CR0)
                                        (0184) 	db		68h, 33h		; AnalogLUTControl1 register (ALT_CR1)
                                        (0185) 	db		63h, 00h		; AnalogModulatorControl_0 register (AMD_CR0)
                                        (0186) 	db		66h, 00h		; AnalogModulatorControl_1 register (AMD_CR1)
                                        (0187) 	db		d1h, 00h		; GlobalDigitalInterconnect_Drive_Even_Input register (GDI_E_IN)
                                        (0188) 	db		d3h, 00h		; GlobalDigitalInterconnect_Drive_Even_Output register (GDI_E_OU)
                                        (0189) 	db		d0h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Input register (GDI_O_IN)
                                        (0190) 	db		d2h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Output register (GDI_O_OU)
                                        (0191) 	db		e1h, 4eh		; OscillatorControl_1 register (OSC_CR1)
                                        (0192) 	db		e2h, 00h		; OscillatorControl_2 register (OSC_CR2)
                                        (0193) 	db		dfh, 4ah		; OscillatorControl_3 register (OSC_CR3)
                                        (0194) 	db		deh, 02h		; OscillatorControl_4 register (OSC_CR4)
                                        (0195) 	db		ddh, 00h		; OscillatorGlobalBusEnableControl register (OSC_GO_EN)
                                        (0196) 	db		e7h, 00h		; Type2Decimator_Control register (DEC_CR2)
                                        (0197) 	db		ffh
                                        (0198) LoadConfigTBL_explorersound_Ordered:
                                        (0199) ;  Ordered Global Register values

(0200) 	M8C_SetBank1
02AD: 10       PUSH  X                  
02AE: 62 00 00 MOV   REG[0x0],0x0       (0201) 	mov	reg[00h], 00h		; Port_0_DriveMode_0 register (PRT0DM0)
02B1: 62 01 FF MOV   REG[0x1],0xFF      (0202) 	mov	reg[01h], ffh		; Port_0_DriveMode_1 register (PRT0DM1)
02B4: 70 EF    AND   F,0xEF             (0203) 	M8C_SetBank0
02B6: 62 03 FF MOV   REG[0x3],0xFF      (0204) 	mov	reg[03h], ffh		; Port_0_DriveMode_2 register (PRT0DM2)
02B9: 62 02 00 MOV   REG[0x2],0x0       (0205) 	mov	reg[02h], 00h		; Port_0_GlobalSelect register (PRT0GS)
02BC: 71 10    OR    F,0x10             (0206) 	M8C_SetBank1
02BE: 62 02 00 MOV   REG[0x2],0x0       (0207) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
02C1: 62 03 00 MOV   REG[0x3],0x0       (0208) 	mov	reg[03h], 00h		; Port_0_IntCtrl_1 register (PRT0IC1)
02C4: 70 EF    AND   F,0xEF             (0209) 	M8C_SetBank0
02C6: 62 01 00 MOV   REG[0x1],0x0       (0210) 	mov	reg[01h], 00h		; Port_0_IntEn register (PRT0IE)
02C9: 71 10    OR    F,0x10             (0211) 	M8C_SetBank1
02CB: 62 04 A0 MOV   REG[0x4],0xA0      (0212) 	mov	reg[04h], a0h		; Port_1_DriveMode_0 register (PRT1DM0)
02CE: 62 05 FF MOV   REG[0x5],0xFF      (0213) 	mov	reg[05h], ffh		; Port_1_DriveMode_1 register (PRT1DM1)
02D1: 70 EF    AND   F,0xEF             (0214) 	M8C_SetBank0
02D3: 62 07 FF MOV   REG[0x7],0xFF      (0215) 	mov	reg[07h], ffh		; Port_1_DriveMode_2 register (PRT1DM2)
02D6: 62 06 00 MOV   REG[0x6],0x0       (0216) 	mov	reg[06h], 00h		; Port_1_GlobalSelect register (PRT1GS)
02D9: 71 10    OR    F,0x10             (0217) 	M8C_SetBank1
02DB: 62 06 00 MOV   REG[0x6],0x0       (0218) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
02DE: 62 07 00 MOV   REG[0x7],0x0       (0219) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
02E1: 70 EF    AND   F,0xEF             (0220) 	M8C_SetBank0
02E3: 62 05 00 MOV   REG[0x5],0x0       (0221) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
02E6: 71 10    OR    F,0x10             (0222) 	M8C_SetBank1
02E8: 62 08 00 MOV   REG[0x8],0x0       (0223) 	mov	reg[08h], 00h		; Port_2_DriveMode_0 register (PRT2DM0)
02EB: 62 09 FF MOV   REG[0x9],0xFF      (0224) 	mov	reg[09h], ffh		; Port_2_DriveMode_1 register (PRT2DM1)
02EE: 70 EF    AND   F,0xEF             (0225) 	M8C_SetBank0
02F0: 62 0B FF MOV   REG[0xB],0xFF      (0226) 	mov	reg[0bh], ffh		; Port_2_DriveMode_2 register (PRT2DM2)
02F3: 62 0A 00 MOV   REG[0xA],0x0       (0227) 	mov	reg[0ah], 00h		; Port_2_GlobalSelect register (PRT2GS)
02F6: 71 10    OR    F,0x10             (0228) 	M8C_SetBank1
02F8: 62 0A 00 MOV   REG[0xA],0x0       (0229) 	mov	reg[0ah], 00h		; Port_2_IntCtrl_0 register (PRT2IC0)
02FB: 62 0B 00 MOV   REG[0xB],0x0       (0230) 	mov	reg[0bh], 00h		; Port_2_IntCtrl_1 register (PRT2IC1)
02FE: 70 EF    AND   F,0xEF             (0231) 	M8C_SetBank0
0300: 62 09 00 MOV   REG[0x9],0x0       (0232) 	mov	reg[09h], 00h		; Port_2_IntEn register (PRT2IE)
0303: 71 10    OR    F,0x10             (0233) 	M8C_SetBank1
0305: 62 0C 00 MOV   REG[0xC],0x0       (0234) 	mov	reg[0ch], 00h		; Port_3_DriveMode_0 register (PRT3DM0)
0308: 62 0D 00 MOV   REG[0xD],0x0       (0235) 	mov	reg[0dh], 00h		; Port_3_DriveMode_1 register (PRT3DM1)
030B: 70 EF    AND   F,0xEF             (0236) 	M8C_SetBank0
030D: 62 0F 00 MOV   REG[0xF],0x0       (0237) 	mov	reg[0fh], 00h		; Port_3_DriveMode_2 register (PRT3DM2)
0310: 62 0E 00 MOV   REG[0xE],0x0       (0238) 	mov	reg[0eh], 00h		; Port_3_GlobalSelect register (PRT3GS)
0313: 71 10    OR    F,0x10             (0239) 	M8C_SetBank1
0315: 62 0E 00 MOV   REG[0xE],0x0       (0240) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
0318: 62 0F 00 MOV   REG[0xF],0x0       (0241) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
031B: 70 EF    AND   F,0xEF             (0242) 	M8C_SetBank0
031D: 62 0D 00 MOV   REG[0xD],0x0       (0243) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
0320: 71 10    OR    F,0x10             (0244) 	M8C_SetBank1
0322: 62 10 00 MOV   REG[0x10],0x0      (0245) 	mov	reg[10h], 00h		; Port_4_DriveMode_0 register (PRT4DM0)
0325: 62 11 00 MOV   REG[0x11],0x0      (0246) 	mov	reg[11h], 00h		; Port_4_DriveMode_1 register (PRT4DM1)
0328: 70 EF    AND   F,0xEF             (0247) 	M8C_SetBank0
032A: 62 13 00 MOV   REG[0x13],0x0      (0248) 	mov	reg[13h], 00h		; Port_4_DriveMode_2 register (PRT4DM2)
032D: 62 12 00 MOV   REG[0x12],0x0      (0249) 	mov	reg[12h], 00h		; Port_4_GlobalSelect register (PRT4GS)
0330: 71 10    OR    F,0x10             (0250) 	M8C_SetBank1
0332: 62 12 00 MOV   REG[0x12],0x0      (0251) 	mov	reg[12h], 00h		; Port_4_IntCtrl_0 register (PRT4IC0)
0335: 62 13 00 MOV   REG[0x13],0x0      (0252) 	mov	reg[13h], 00h		; Port_4_IntCtrl_1 register (PRT4IC1)
0338: 70 EF    AND   F,0xEF             (0253) 	M8C_SetBank0
033A: 62 11 00 MOV   REG[0x11],0x0      (0254) 	mov	reg[11h], 00h		; Port_4_IntEn register (PRT4IE)
033D: 71 10    OR    F,0x10             (0255) 	M8C_SetBank1
033F: 62 14 00 MOV   REG[0x14],0x0      (0256) 	mov	reg[14h], 00h		; Port_5_DriveMode_0 register (PRT5DM0)
0342: 62 15 00 MOV   REG[0x15],0x0      (0257) 	mov	reg[15h], 00h		; Port_5_DriveMode_1 register (PRT5DM1)
0345: 70 EF    AND   F,0xEF             (0258) 	M8C_SetBank0
0347: 62 17 00 MOV   REG[0x17],0x0      (0259) 	mov	reg[17h], 00h		; Port_5_DriveMode_2 register (PRT5DM2)
034A: 62 16 00 MOV   REG[0x16],0x0      (0260) 	mov	reg[16h], 00h		; Port_5_GlobalSelect register (PRT5GS)
034D: 71 10    OR    F,0x10             (0261) 	M8C_SetBank1
034F: 62 16 00 MOV   REG[0x16],0x0      (0262) 	mov	reg[16h], 00h		; Port_5_IntCtrl_0 register (PRT5IC0)
0352: 62 17 00 MOV   REG[0x17],0x0      (0263) 	mov	reg[17h], 00h		; Port_5_IntCtrl_1 register (PRT5IC1)
0355: 70 EF    AND   F,0xEF             (0264) 	M8C_SetBank0
0357: 62 15 00 MOV   REG[0x15],0x0      (0265) 	mov	reg[15h], 00h		; Port_5_IntEn register (PRT5IE)
035A: 71 10    OR    F,0x10             (0266) 	M8C_SetBank1
035C: 62 18 00 MOV   REG[0x18],0x0      (0267) 	mov	reg[18h], 00h		; Port_6_DriveMode_0 register (PRT6DM0)
035F: 62 19 00 MOV   REG[0x19],0x0      (0268) 	mov	reg[19h], 00h		; Port_6_DriveMode_1 register (PRT6DM1)
0362: 70 EF    AND   F,0xEF             (0269) 	M8C_SetBank0
0364: 62 1B 00 MOV   REG[0x1B],0x0      (0270) 	mov	reg[1bh], 00h		; Port_6_DriveMode_2 register (PRT6DM2)
0367: 62 1A 00 MOV   REG[0x1A],0x0      (0271) 	mov	reg[1ah], 00h		; Port_6_GlobalSelect register (PRT6GS)
036A: 71 10    OR    F,0x10             (0272) 	M8C_SetBank1
036C: 62 1A 00 MOV   REG[0x1A],0x0      (0273) 	mov	reg[1ah], 00h		; Port_6_IntCtrl_0 register (PRT6IC0)
036F: 62 1B 00 MOV   REG[0x1B],0x0      (0274) 	mov	reg[1bh], 00h		; Port_6_IntCtrl_1 register (PRT6IC1)
0372: 70 EF    AND   F,0xEF             (0275) 	M8C_SetBank0
0374: 62 19 00 MOV   REG[0x19],0x0      (0276) 	mov	reg[19h], 00h		; Port_6_IntEn register (PRT6IE)
0377: 71 10    OR    F,0x10             (0277) 	M8C_SetBank1
0379: 62 1C 00 MOV   REG[0x1C],0x0      (0278) 	mov	reg[1ch], 00h		; Port_7_DriveMode_0 register (PRT7DM0)
037C: 62 1D 00 MOV   REG[0x1D],0x0      (0279) 	mov	reg[1dh], 00h		; Port_7_DriveMode_1 register (PRT7DM1)
037F: 70 EF    AND   F,0xEF             (0280) 	M8C_SetBank0
0381: 62 1F 00 MOV   REG[0x1F],0x0      (0281) 	mov	reg[1fh], 00h		; Port_7_DriveMode_2 register (PRT7DM2)
0384: 62 1E 00 MOV   REG[0x1E],0x0      (0282) 	mov	reg[1eh], 00h		; Port_7_GlobalSelect register (PRT7GS)
0387: 71 10    OR    F,0x10             (0283) 	M8C_SetBank1
0389: 62 1E 00 MOV   REG[0x1E],0x0      (0284) 	mov	reg[1eh], 00h		; Port_7_IntCtrl_0 register (PRT7IC0)
038C: 62 1F 00 MOV   REG[0x1F],0x0      (0285) 	mov	reg[1fh], 00h		; Port_7_IntCtrl_1 register (PRT7IC1)
038F: 70 EF    AND   F,0xEF             (0286) 	M8C_SetBank0
0391: 62 1D 00 MOV   REG[0x1D],0x0      (0287) 	mov	reg[1dh], 00h		; Port_7_IntEn register (PRT7IE)
0394: 70 EF    AND   F,0xEF             (0288) 	M8C_SetBank0
0396: 7F       RET                      (0289) 	ret
(0290) 
(0291) 
(0292) ; PSoC Configuration file trailer PsocConfig.asm
FILE: lib\psocconfig.asm
                                        (0001) ; Generated by PSoC Designer 5.0.1127.0
                                        (0002) ;
                                        (0003) ;==========================================================================
                                        (0004) ;  PSoCConfig.asm
                                        (0005) ;  @PSOC_VERSION
                                        (0006) ;
                                        (0007) ;  Version: 0.85
                                        (0008) ;  Revised: June 22, 2004
                                        (0009) ;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0010) ;
                                        (0011) ;  This file is generated by the Device Editor on Application Generation.
                                        (0012) ;  It contains code which loads the configuration data table generated in
                                        (0013) ;  the file PSoCConfigTBL.asm
                                        (0014) ;
                                        (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                        (0016) ;  Edits to this file will not be preserved.
                                        (0017) ;==========================================================================
                                        (0018) ;
                                        (0019) include "m8c.inc"
                                        (0020) include "memory.inc"
                                        (0021) include "GlobalParams.inc"
                                        (0022) 
                                        (0023) export LoadConfigInit
                                        (0024) export _LoadConfigInit
                                        (0025) export LoadConfig_explorersound
                                        (0026) export _LoadConfig_explorersound
                                        (0027) 
                                        (0028) export NO_SHADOW
                                        (0029) export _NO_SHADOW
                                        (0030) 
                                        (0031) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                        (0032) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                        (0033) 
                                        (0034) AREA psoc_config(rom, rel)
                                        (0035) 
                                        (0036) ;---------------------------------------------------------------------------
                                        (0037) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                        (0038) ;                  parameters handled by boot code, like CPU speed). This
                                        (0039) ;                  function can be called from user code, but typically it
                                        (0040) ;                  is only called from boot.
                                        (0041) ;
                                        (0042) ;       INPUTS: None.
                                        (0043) ;      RETURNS: Nothing.
                                        (0044) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                        (0045) ;               In the large memory model currently only the page
                                        (0046) ;               pointer registers listed below are modified.  This does
                                        (0047) ;               not guarantee that in future implementations of this
                                        (0048) ;               function other page pointer registers will not be
                                        (0049) ;               modified.
                                        (0050) ;          
                                        (0051) ;               Page Pointer Registers Modified: 
                                        (0052) ;               CUR_PP
                                        (0053) ;
                                        (0054) _LoadConfigInit:
                                        (0055)  LoadConfigInit:
                                        (0056)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0057)     

0399: 7C 03 A0 LCALL 0x03A0             (0058) 	lcall	LoadConfig_explorersound
039C: 7C 02 AC LCALL 0x02AC             (0059) 	lcall	LoadConfigTBL_explorersound_Ordered
                                        (0060) 
                                        (0061) 
                                        (0062)     RAM_EPILOGUE RAM_USE_CLASS_4
039F: 7F       RET                      (0063)     ret
                                        (0064) 
                                        (0065) ;---------------------------------------------------------------------------
                                        (0066) ; Load Configuration explorersound
                                        (0067) ;
                                        (0068) ;    Load configuration registers for explorersound.
                                        (0069) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                        (0070) ;
                                        (0071) ;       INPUTS: None.
                                        (0072) ;      RETURNS: Nothing.
                                        (0073) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                        (0074) ;               modified as may the Page Pointer registers!
                                        (0075) ;               In the large memory model currently only the page
                                        (0076) ;               pointer registers listed below are modified.  This does
                                        (0077) ;               not guarantee that in future implementations of this
                                        (0078) ;               function other page pointer registers will not be
                                        (0079) ;               modified.
                                        (0080) ;          
                                        (0081) ;               Page Pointer Registers Modified: 
                                        (0082) ;               CUR_PP
                                        (0083) ;
                                        (0084) _LoadConfig_explorersound:
                                        (0085)  LoadConfig_explorersound:
                                        (0086)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0087) 
03A0: 10       PUSH  X                  (0088) 	push	x
03A1: 70 EF    AND   F,0xEF             (0089)     M8C_SetBank0                    ; Force bank 0
03A3: 50 00    MOV   A,0x0              (0090)     mov     a, 0                    ; Specify bank 0
03A5: 67       ASR   A                  (0091)     asr     a                       ; Store in carry flag
                                        (0092)                                     ; Load bank 0 table:
03A6: 50 01    MOV   A,0x1              (0093)     mov     A, >LoadConfigTBL_explorersound_Bank0
03A8: 57 A0    MOV   X,0xA0             (0094)     mov     X, <LoadConfigTBL_explorersound_Bank0
03AA: 7C 03 BB LCALL 0x03BB             (0095)     lcall   LoadConfig              ; Load the bank 0 values
                                        (0096) 
03AD: 50 01    MOV   A,0x1              (0097)     mov     a, 1                    ; Specify bank 1
03AF: 67       ASR   A                  (0098)     asr     a                       ; Store in carry flag
                                        (0099)                                     ; Load bank 1 table:
03B0: 50 02    MOV   A,0x2              (0100)     mov     A, >LoadConfigTBL_explorersound_Bank1
03B2: 57 63    MOV   X,0x63             (0101)     mov     X, <LoadConfigTBL_explorersound_Bank1
03B4: 7C 03 BB LCALL 0x03BB             (0102)     lcall   LoadConfig              ; Load the bank 1 values
                                        (0103) 
03B7: 70 EF    AND   F,0xEF             (0104)     M8C_SetBank0                    ; Force return to bank 0
03B9: 20       POP   X                  (0105) 	pop		x
                                        (0106) 
                                        (0107)     RAM_EPILOGUE RAM_USE_CLASS_4
03BA: 7F       RET                      (0108)     ret
                                        (0109) 
                                        (0110) 
                                        (0111) 
                                        (0112) 
                                        (0113) ;---------------------------------------------------------------------------
                                        (0114) ; LoadConfig - Set IO registers as specified in ROM table of (address,value)
                                        (0115) ;              pairs. Terminate on address=0xFF.
                                        (0116) ;
                                        (0117) ;  INPUTS:  [A,X] points to the table to be loaded
                                        (0118) ;           Flag Register Carry bit encodes the Register Bank
                                        (0119) ;           (Carry=0 => Bank 0; Carry=1 => Bank 1)
                                        (0120) ;
                                        (0121) ;  RETURNS: nothing.
                                        (0122) ;
                                        (0123) ;  STACK FRAME:  X-4 I/O Bank 0/1 indicator
                                        (0124) ;                X-3 Temporary store for register address
                                        (0125) ;                X-2 LSB of config table address
                                        (0126) ;                X-1 MSB of config table address
                                        (0127) ;
                                        (0128) LoadConfig:
                                        (0129)     RAM_PROLOGUE RAM_USE_CLASS_2
03BB: 38 02    ADD   SP,0x2             (0130)     add     SP, 2                   ; Set up local vars
03BD: 10       PUSH  X                  (0131)     push    X                       ; Save config table address on stack
03BE: 08       PUSH  A                  (0132)     push    A
03BF: 4F       MOV   X,SP               (0133)     mov     X, SP
03C0: 56 FC 00 MOV   [X-4],0x0          (0134)     mov     [X-4], 0                ; Set default Destination to Bank 0
03C3: D0 04    JNC   0x03C8             (0135)     jnc     .BankSelectSaved        ; Carry says Bank 0 is OK
03C5: 56 FC 01 MOV   [X-4],0x1          (0136)     mov     [X-4], 1                ; No Carry: default to Bank 1
                                        (0137) .BankSelectSaved:
03C8: 18       POP   A                  (0138)     pop     A
03C9: 20       POP   X                  (0139)     pop     X
                                        (0140) 
                                        (0141) LoadConfigLp:
03CA: 70 EF    AND   F,0xEF             (0142)     M8C_SetBank0                    ; Switch to bank 0
03CC: 62 E3 00 MOV   REG[0xE3],0x0      (0143)     M8C_ClearWDT                    ; Clear the watchdog for long inits
03CF: 10       PUSH  X                  (0144)     push    X                       ; Preserve the config table address
03D0: 08       PUSH  A                  (0145)     push    A
03D1: 28       ROMX                     (0146)     romx                            ; Load register address from table
03D2: 39 FF    CMP   A,0xFF             (0147)     cmp     A, END_CONFIG_TABLE     ; End of table?
03D4: A0 1F    JZ    0x03F4             (0148)     jz      EndLoadConfig           ;   Yes, go wrap it up
03D6: 4F       MOV   X,SP               (0149)     mov     X, SP                   ;
03D7: 48 FC 01 TST   [X-4],0x1          (0150)     tst     [X-4], 1                ; Loading IO Bank 1?
03DA: A0 03    JZ    0x03DE             (0151)     jz      .IOBankNowSet           ;    No, Bank 0 is fine
03DC: 71 10    OR    F,0x10             (0152)     M8C_SetBank1                    ;   Yes, switch to Bank 1
                                        (0153) .IOBankNowSet:
03DE: 54 FD    MOV   [X-3],A            (0154)     mov     [X-3], A                ; Stash the register address
03E0: 18       POP   A                  (0155)     pop     A                       ; Retrieve the table address
03E1: 20       POP   X                  (0156)     pop     X
03E2: 75       INC   X                  (0157)     inc     X                       ; Advance to the data byte
03E3: 09 00    ADC   A,0x0              (0158)     adc     A, 0
03E5: 10       PUSH  X                  (0159)     push    X                       ; Save the config table address again
03E6: 08       PUSH  A                  (0160)     push    A
03E7: 28       ROMX                     (0161)     romx                            ; load config data from the table
03E8: 4F       MOV   X,SP               (0162)     mov     X, SP                   ; retrieve the register address
03E9: 59 FD    MOV   X,[X-3]            (0163)     mov     X, [X-3]
03EB: 61 00    MOV   REG[X+0x0],A       (0164)     mov     reg[X], A               ; Configure the register
03ED: 18       POP   A                  (0165)     pop     A                       ; retrieve the table address
03EE: 20       POP   X                  (0166)     pop     X
03EF: 75       INC   X                  (0167)     inc     X                       ; advance to next table entry
03F0: 09 00    ADC   A,0x0              (0168)     adc     A, 0
03F2: 8F D7    JMP   0x03CA             (0169)     jmp     LoadConfigLp            ; loop to configure another register
                                        (0170) EndLoadConfig:
03F4: 38 FC    ADD   SP,0xFC            (0171)     add     SP, -4
03F6: 70 3F    AND   F,0x3F             
03F8: 71 C0    OR    F,0xC0             (0172)     RAM_EPILOGUE RAM_USE_CLASS_2
03FA: 7F       RET                      (0173)     ret
(0174) 
(0175) AREA InterruptRAM(ram, rel)
(0176) 
(0177) NO_SHADOW:
(0178) _NO_SHADOW:
FILE: lib\scblock_inbuff.asm
                                        (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   SCBLOCK_inbuff.asm
                                        (0004) ;;  Version: 2.4, Updated on 2009/10/15 at 17:11:37
                                        (0005) ;;  Generated by PSoC Designer 5.0.1127.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: SCBLOCK User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;-----------------------------------------------------------------------------
                                        (0010) ;;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0011) ;;*****************************************************************************
                                        (0012) ;;*****************************************************************************
                                        (0013) 
                                        (0014) 
                                        (0015) ;; -----------------------------------------------------------------
                                        (0016) ;;                         Register Definitions
                                        (0017) ;; -----------------------------------------------------------------
                                        (0018) ;; BIT FIELD            Mask
                                        (0019) ;; -----------------    -----
                                        (0020) ;; CR0.FCap              80
                                        (0021) ;; CR0.ClockPhase        40
                                        (0022) ;; CR0.ASign             20
                                        (0023) ;; CR0.ACap              1F
                                        (0024) ;;
                                        (0025) ;; CR1.AMux              C0   SCB
                                        (0026) ;; CR1.ACMux             C0   SCA
                                        (0027) ;; CR1.BCap              1F
                                        (0028) ;;
                                        (0029) ;; CR2.AnalogBus         80
                                        (0030) ;; CR2.CmpBus            40
                                        (0031) ;; CR2.AutoZero          20
                                        (0032) ;; CR2.CCap              1F
                                        (0033) ;;
                                        (0034) ;; CR3.RefSelect         C0
                                        (0035) ;; CR3.FSW1              20
                                        (0036) ;; CR3.FSW0              10
                                        (0037) ;; CR3.BSW               08   SCB
                                        (0038) ;; CR3.BMux              04   SCB
                                        (0039) ;; CR3.BMux              0C   SCA
                                        (0040) ;; CR3.Power             03
                                        (0041) ;;
                                        (0042) 
                                        (0043) include "SCBLOCK_inbuff.inc"
                                        (0044) include "m8c.inc"
                                        (0045) include "memory.inc"
                                        (0046) 
                                        (0047) ;-----------------------------------------------
                                        (0048) ;  Global Symbols
                                        (0049) ;-----------------------------------------------
                                        (0050) export  SCBLOCK_inbuff_Start
                                        (0051) export _SCBLOCK_inbuff_Start
                                        (0052) export  SCBLOCK_inbuff_SetPower
                                        (0053) export _SCBLOCK_inbuff_SetPower
                                        (0054) export  SCBLOCK_inbuff_Stop
                                        (0055) export _SCBLOCK_inbuff_Stop
                                        (0056) 
                                        (0057) AREA UserModules (ROM, REL)
                                        (0058) 
                                        (0059) .SECTION
                                        (0060) ;-----------------------------------------------------------------------------
                                        (0061) ;  FUNCTION NAME: SCBLOCK_inbuff_Start
                                        (0062) ;  FUNCTION NAME: SCBLOCK_inbuff_SetPower
                                        (0063) ;
                                        (0064) ;  DESCRIPTION:
                                        (0065) ;    Applies power setting to the module's analog PSoc block.
                                        (0066) ;
                                        (0067) ;-----------------------------------------------------------------------------
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:
                                        (0070) ;    A  contains the power setting 0-3
                                        (0071) ;
                                        (0072) ;  RETURNS:  NA
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    The A and X registers may be modified by this or future implementations
                                        (0076) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0077) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0078) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0079) ;    functions.
                                        (0080) ;
                                        (0081)  SCBLOCK_inbuff_Start:
                                        (0082) _SCBLOCK_inbuff_Start:
                                        (0083)  SCBLOCK_inbuff_SetPower:
                                        (0084) _SCBLOCK_inbuff_SetPower:
                                        (0085)    RAM_PROLOGUE RAM_USE_CLASS_2
03FB: 21 03    AND   A,0x3              (0086)    and  A,03h
03FD: 10       PUSH  X                  (0087)    push X
03FE: 4F       MOV   X,SP               (0088)    mov  X,SP
                                        (0089) 
03FF: 08       PUSH  A                  (0090)    push A
0400: 5D 9F    MOV   A,REG[0x9F]        (0091)    mov  A,reg[SCBLOCK_inbuff_cr3]
0402: 21 FC    AND   A,0xFC             (0092)    and  A,~03h
0404: 2B 00    OR    A,[X+0]            (0093)    or   A,[X]
0406: 60 9F    MOV   REG[0x9F],A        (0094)    mov  reg[SCBLOCK_inbuff_cr3],A
0408: 18       POP   A                  (0095)    pop  A
0409: 20       POP   X                  (0096)    pop  X
040A: 70 3F    AND   F,0x3F             
040C: 71 C0    OR    F,0xC0             (0097)    RAM_EPILOGUE RAM_USE_CLASS_2
040E: 7F       RET                      (0098)    ret
                                        (0099) .ENDSECTION
                                        (0100) 
                                        (0101) .SECTION
                                        (0102) ;-----------------------------------------------------------------------------
                                        (0103) ;  FUNCTION NAME: SCBLOCK_inbuff_Stop
                                        (0104) ;
                                        (0105) ;  DESCRIPTION:
                                        (0106) ;    Removes power from the module's analog PSoC block
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;
                                        (0109) ;  ARGUMENTS: None
                                        (0110) ;
                                        (0111) ;  RETURNS:  NA
                                        (0112) ;
                                        (0113) ;  SIDE EFFECTS:
                                        (0114) ;    The A and X registers may be modified by this or future implementations
                                        (0115) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0116) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0117) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0118) ;    functions.
                                        (0119) ;
                                        (0120)  SCBLOCK_inbuff_Stop:
                                        (0121) _SCBLOCK_inbuff_Stop:
                                        (0122)    RAM_PROLOGUE RAM_USE_CLASS_1
040F: 41 9F FC AND   REG[0x9F],0xFC     (0123)    and  reg[SCBLOCK_inbuff_cr3],~03h
                                        (0124)    RAM_EPILOGUE RAM_USE_CLASS_1
0412: 7F       RET                      (0125)    ret
(0126) .ENDSECTION
(0127) 
(0128) ; End of File SCBLOCK_inbuff.asm
FILE: lib\refmux_1.asm
                                        (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   RefMux_1.asm
                                        (0004) ;;  Version: 1.3, Updated on 2009/10/15 at 17:11:37
                                        (0005) ;;  Generated by PSoC Designer 5.0.1127.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: RefMux User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "RefMux_1.inc"
                                        (0023) include "m8c.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  RefMux_1_Start
                                        (0030) export _RefMux_1_Start
                                        (0031) 
                                        (0032) export  RefMux_1_SetPower
                                        (0033) export _RefMux_1_SetPower
                                        (0034) 
                                        (0035) export  RefMux_1_Stop
                                        (0036) export _RefMux_1_Stop
                                        (0037) 
                                        (0038) export  RefMux_1_RefSelect
                                        (0039) export _RefMux_1_RefSelect
                                        (0040) 
                                        (0041) ;-----------------------------------------------
                                        (0042) ;  EQUATES
                                        (0043) ;-----------------------------------------------
                                        (0044) TMUX_MASK:        equ 1Ch              ; Mask for Test Mux control
                                        (0045) POWERMASK:        equ 03h
                                        (0046) 
                                        (0047) AREA UserModules (ROM, REL)
                                        (0048) .SECTION
                                        (0049) ;-----------------------------------------------------------------------------
                                        (0050) ;  FUNCTION NAME: RefMux_1_Start
                                        (0051) ;  FUNCTION NAME: RefMux_1_SetPower
                                        (0052) ;
                                        (0053) ;  DESCRIPTION:
                                        (0054) ;   Applies power setting to the module's PSoC block
                                        (0055) ;
                                        (0056) ;-----------------------------------------------------------------------------
                                        (0057) ;
                                        (0058) ;  ARGUMENTS:
                                        (0059) ;  A  Contains the power setting; 0 = Off
                                        (0060) ;                                 1 = Low
                                        (0061) ;                                 2 = Med
                                        (0062) ;                                 3 = High
                                        (0063) ;
                                        (0064) ;  RETURNS:  NA
                                        (0065) ;
                                        (0066) ;  SIDE EFFECTS:
                                        (0067) ;    The A and X registers may be modified by this or future implementations
                                        (0068) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0069) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0070) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0071) ;    functions.
                                        (0072) ;
                                        (0073)  RefMux_1_Start:
                                        (0074) _RefMux_1_Start:
                                        (0075)  RefMux_1_SetPower:
                                        (0076) _RefMux_1_SetPower:
                                        (0077)     RAM_PROLOGUE RAM_USE_CLASS_2
0413: 21 03    AND   A,0x3              (0078)     and  A, POWERMASK                  ; mask A to protect unchanged bits
0415: 4F       MOV   X,SP               (0079)     mov  X, SP                         ; define temp store location
                                        (0080) 
0416: 08       PUSH  A                  (0081)     push A                             ; put power value in temp store
0417: 5D 7F    MOV   A,REG[0x7F]        (0082)     mov  A, reg[RefMux_1_REFMUX_CR2]   ; read power value
0419: 21 FC    AND   A,0xFC             (0083)     and  A, ~POWERMASK                 ; clear power bits in A
041B: 2B 00    OR    A,[X+0]            (0084)     or   A, [X]                        ; combine power value with balance of reg.
041D: 60 7F    MOV   REG[0x7F],A        (0085)     mov  reg[RefMux_1_REFMUX_CR2], A   ; move complete value back to register
041F: 18       POP   A                  (0086)     pop  A
0420: 70 3F    AND   F,0x3F             
0422: 71 C0    OR    F,0xC0             (0087)     RAM_EPILOGUE RAM_USE_CLASS_2
0424: 7F       RET                      (0088)     ret
                                        (0089) .ENDSECTION
                                        (0090) 
                                        (0091) .SECTION
                                        (0092) ;-----------------------------------------------------------------------------
                                        (0093) ;  FUNCTION NAME: RefMux_1_Stop
                                        (0094) ;
                                        (0095) ;  DESCRIPTION:
                                        (0096) ;   Turn off power to user module
                                        (0097) ;
                                        (0098) ;-----------------------------------------------------------------------------
                                        (0099) ;
                                        (0100) ;  ARGUMENTS: None
                                        (0101) ;
                                        (0102) ;  RETURNS:  NA
                                        (0103) ;
                                        (0104) ;  SIDE EFFECTS:
                                        (0105) ;    The A and X registers may be modified by this or future implementations
                                        (0106) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0107) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0108) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0109) ;    functions.
                                        (0110) ;
                                        (0111)  RefMux_1_Stop:
                                        (0112) _RefMux_1_Stop:
                                        (0113)     RAM_PROLOGUE RAM_USE_CLASS_1
0425: 41 7F FC AND   REG[0x7F],0xFC     (0114)     and REG[RefMux_1_REFMUX_CR2], ~POWERMASK
                                        (0115)     RAM_EPILOGUE RAM_USE_CLASS_1
0428: 7F       RET                      (0116)     ret
                                        (0117) .ENDSECTION
                                        (0118) 
                                        (0119) .SECTION
                                        (0120) ;-----------------------------------------------------------------------------
                                        (0121) ;  FUNCTION NAME: RefMux_1_InputSelect
                                        (0122) ;
                                        (0123) ;  DESCRIPTION:
                                        (0124) ;   Select one of the input of the TestMux to be connected to the Analog
                                        (0125) ;   Column bus.
                                        (0126) ;
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;
                                        (0129) ;  ARGUMENTS:
                                        (0130) ;   A  contains value to select desired RefMux output.
                                        (0131) ;         Input              Code
                                        (0132) ;         Off                 00h
                                        (0133) ;         PMuxOut             10h
                                        (0134) ;         AGND                14h  (Power must be applied)
                                        (0135) ;         REFLO               18h
                                        (0136) ;         REFHI               1Ch
                                        (0137) ;
                                        (0138) ;  RETURNS:  NA
                                        (0139) ;
                                        (0140) ;  SIDE EFFECTS:
                                        (0141) ;    The A and X registers may be modified by this or future implementations
                                        (0142) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0143) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0144) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0145) ;    functions.
                                        (0146) ;
                                        (0147)  RefMux_1_RefSelect:
                                        (0148) _RefMux_1_RefSelect:
                                        (0149)     RAM_PROLOGUE RAM_USE_CLASS_2
0429: 21 1C    AND   A,0x1C             (0150)     and  A,TMUX_MASK                   ; Mask off test mux control
042B: 4F       MOV   X,SP               (0151)     mov  X,SP                          ; Get stack location
042C: 08       PUSH  A                  (0152)     push A
042D: 5D 7F    MOV   A,REG[0x7F]        (0153)     mov  A,reg[RefMux_1_REFMUX_CR2]    ; Write register Test Mux register to select reference
042F: 21 E3    AND   A,0xE3             (0154)     and  A, ~TMUX_MASK                 ; Clear Mux control bits
0431: 2B 00    OR    A,[X+0]            (0155)     or   A,[X]                         ; Or in the new setting
0433: 60 7F    MOV   REG[0x7F],A        (0156)     mov  reg[RefMux_1_REFMUX_CR2],A    ; Write register Test Mux register to select reference
0435: 18       POP   A                  (0157)     pop  A                             ; Restore the stack
0436: 70 3F    AND   F,0x3F             
0438: 71 C0    OR    F,0xC0             (0158)     RAM_EPILOGUE RAM_USE_CLASS_2
043A: 7F       RET                      (0159)     ret
(0160) .ENDSECTION
(0161) 
(0162) 
(0163) ; End of File RefMux_1.asm
FILE: lib\pga_pre.asm
                                        (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   PGA_pre.asm  ( PGA )
                                        (0004) ;;  Version: 3.2, Updated on 2009/10/13 at 23:59:44
                                        (0005) ;;  Generated by PSoC Designer 5.0.1127.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION:  PGA User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) ;; -----------------------------------------------------------------
                                        (0023) ;;                         Register Definitions
                                        (0024) ;;
                                        (0025) ;; Uses 1 Continuous Time Block configured as shown.
                                        (0026) ;;
                                        (0027) ;; * For a Mask/Val pair, this indicates that the value is
                                        (0028) ;;   determined by the user either through config-time parameteriza-
                                        (0029) ;;   tion or run-time manipulation.
                                        (0030) ;;
                                        (0031) ;; BIT FIELD             Mask/Val Function
                                        (0032) ;; -----------------            -----   --------------------
                                        (0033) ;; GAIN_CR0.RES_RATIO_T2B       F0/*    User Parameter (by table)
                                        (0034) ;; GAIN_CR0.GAIN_ATTEN          08/*    Gain (by table)
                                        (0035) ;; GAIN_CR0.RES_SOURCE          04/1    Res source to output
                                        (0036) ;; GAIN_CR0.RES_REF             03/*    Res ref
                                        (0037) ;;
                                        (0038) ;; GAIN_CR1.A_OUT               80/*    User Parameter (Output bus)
                                        (0039) ;; GAIN_CR1.COMP_EN             40/0    Comparator bus disabled
                                        (0040) ;; GAIN_CR1.CT_NEG_INPUT_MUX    38/4    Neg mux to analog f.b. tap
                                        (0041) ;; GAIN_CR1.CT_POS_INPUT_MUX    07/*    Pos mux, typically to col. input mux
                                        (0042) ;;
                                        (0043) ;; GAIN_CR2.CP_COMP             80/0    Latch transparent on PH1
                                        (0044) ;; GAIN_CR2.CK_COMP             40/0    Latch transparent
                                        (0045) ;; GAIN_CR2.CC_COMP             20/1    Mode OP-AMP (not comparator)
                                        (0046) ;; GAIN_CR2.BYPASS_OBUS         1C/0    Bypass OFF
                                        (0047) ;; GAIN_CR2.PWR_SELECT          03/*    Power OFF (0h) at start-up
                                        (0048) ;;
                                        (0049) ;; --------------------------------------------------------------------
                                        (0050) 
                                        (0051) include "PGA_pre.inc"
                                        (0052) include "m8c.inc"
                                        (0053) include "memory.inc"
                                        (0054) 
                                        (0055) 
                                        (0056) ;-----------------------------------------------
                                        (0057) ;  Global Symbols
                                        (0058) ;-----------------------------------------------
                                        (0059) export  PGA_pre_Start
                                        (0060) export _PGA_pre_Start
                                        (0061) export  PGA_pre_SetPower
                                        (0062) export _PGA_pre_SetPower
                                        (0063) 
                                        (0064) export  PGA_pre_SetGain
                                        (0065) export _PGA_pre_SetGain
                                        (0066) 
                                        (0067) export  PGA_pre_Stop
                                        (0068) export _PGA_pre_Stop
                                        (0069) 
                                        (0070) ;-----------------------------------------------
                                        (0071) ;  EQUATES
                                        (0072) ;-----------------------------------------------
                                        (0073) POWERMASK:     equ 03h
                                        (0074) GAINREGMASK:   equ f8h
                                        (0075) GAINMASK:      equ fCh
                                        (0076) HIGHGAIN:      equ 04h
                                        (0077) HIGHGAINMASK:  equ 18h
                                        (0078) EXGAIN:        equ 01h
                                        (0079) 
                                        (0080) AREA UserModules (ROM, REL)
                                        (0081) .SECTION
                                        (0082) ;-----------------------------------------------------------------------------
                                        (0083) ;  FUNCTION NAME: PGA_pre_Start
                                        (0084) ;  FUNCTION NAME: PGA_pre_SetPower
                                        (0085) ;
                                        (0086) ;  DESCRIPTION:
                                        (0087) ;    Applies power setting to the module's PSoC block.
                                        (0088) ;-----------------------------------------------------------------------------
                                        (0089) ;
                                        (0090) ;  ARGUMENTS:
                                        (0091) ;  A  Contains the power settings 0=Off, 1=Low, 2=Med, and 3=High
                                        (0092) ;
                                        (0093) ;  RETURNS:  NA
                                        (0094) ;
                                        (0095) ;  SIDE EFFECTS:
                                        (0096) ;    The A and X registers may be modified by this or future implementations
                                        (0097) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0098) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0099) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0100) ;    functions.
                                        (0101) ;
                                        (0102)  PGA_pre_Start:
                                        (0103) _PGA_pre_Start:
                                        (0104)  PGA_pre_SetPower:
                                        (0105) _PGA_pre_SetPower:
                                        (0106) 
                                        (0107)    RAM_PROLOGUE RAM_USE_CLASS_2
043B: 21 03    AND   A,0x3              (0108)    and  A, POWERMASK                                 ; mask A to protect unchanged bits
043D: 4F       MOV   X,SP               (0109)    mov  X, SP                                        ; define temp store location
                                        (0110) ;
043E: 08       PUSH  A                  (0111)    push A                                            ; put power value in temp store
043F: 5D 73    MOV   A,REG[0x73]        (0112)    mov  A, reg[PGA_pre_GAIN_CR2]                           ; read power value
0441: 21 FC    AND   A,0xFC             (0113)    and  A, ~POWERMASK                                ; clear power bits in A
0443: 2B 00    OR    A,[X+0]            (0114)    or   A, [X]                                       ; combine power value with balance of reg.
0445: 60 73    MOV   REG[0x73],A        (0115)    mov  reg[PGA_pre_GAIN_CR2], A                      ; move complete value back to register
0447: 18       POP   A                  (0116)    pop  A
0448: 70 3F    AND   F,0x3F             
044A: 71 C0    OR    F,0xC0             (0117)    RAM_EPILOGUE RAM_USE_CLASS_2
044C: 7F       RET                      (0118)    ret
                                        (0119) .ENDSECTION
                                        (0120) 
                                        (0121) .SECTION
                                        (0122) ;-----------------------------------------------------------------------------
                                        (0123) ;  FUNCTION NAME: PGA_pre_SetGain
                                        (0124) ;
                                        (0125) ;  DESCRIPTION:
                                        (0126) ;    This function sets the Gain/Atten of the amplifier.  Valid gain settings
                                        (0127) ;    are defined in the .inc file.
                                        (0128) ;
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;
                                        (0131) ;  ARGUMENTS:
                                        (0132) ;    A  Contains gain settings.
                                        (0133) ;
                                        (0134) ;    Gain values shown are for example. (See .inc file for gain equates)
                                        (0135) ;
                                        (0136) ;  RETURNS:  NA
                                        (0137) ;
                                        (0138) ;  SIDE EFFECTS:
                                        (0139) ;    The A and X registers may be modified by this or future implementations
                                        (0140) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0141) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0142) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0143) ;    functions.
                                        (0144) ;
                                        (0145)  PGA_pre_SetGain:
                                        (0146) _PGA_pre_SetGain:
                                        (0147) 
                                        (0148)    RAM_PROLOGUE RAM_USE_CLASS_2
044D: 21 FC    AND   A,0xFC             (0149)    and  A, GAINMASK                                       ; mask A to protect unchanged bits
044F: 4F       MOV   X,SP               (0150)    mov  X, SP                                             ; define temp store location
                                        (0151) ;
0450: 08       PUSH  A                  (0152)    push A                                                 ; put gain value in temp store
0451: 5D 71    MOV   A,REG[0x71]        (0153)    mov  A, reg[PGA_pre_GAIN_CR0]                           ; read mux settings
0453: 21 07    AND   A,0x7              (0154)    and  A, ~GAINREGMASK                                   ; clear gain bits in A
0455: 48 00 04 TST   [X+0],0x4          (0155)    tst  [X],HIGHGAIN                                      ; See if High Gain is set
0458: B0 0E    JNZ   0x0467             (0156)    jnz  .SETHIGHGAIN
045A: 41 70 FE AND   REG[0x70],0xFE     (0157)    and  reg[PGA_pre_GAIN_CR3],~EXGAIN                      ; Clear High Gain bit.
045D: 2B 00    OR    A,[X+0]            (0158)    or   A, [X]                                            ; combine gain value with balance of reg.
045F: 60 71    MOV   REG[0x71],A        (0159)    mov  reg[PGA_pre_GAIN_CR0], A                           ; move complete value back to register
0461: 18       POP   A                  (0160)    pop  A
0462: 70 3F    AND   F,0x3F             
0464: 71 C0    OR    F,0xC0             (0161)    RAM_EPILOGUE RAM_USE_CLASS_2
0466: 7F       RET                      (0162)    ret
                                        (0163) 
                                        (0164) .SETHIGHGAIN:
0467: 27 00 18 AND   [X+0],0x18         (0165)    and  [X],HIGHGAINMASK                                  ; Make sure we have a valid high gain
046A: 2B 00    OR    A,[X+0]            (0166)    or   A, [X]                                            ; combine gain value with balance of reg.
046C: 60 71    MOV   REG[0x71],A        (0167)    mov  reg[PGA_pre_GAIN_CR0], A                           ; move complete value back to register
046E: 43 70 01 OR    REG[0x70],0x1      (0168)    or   reg[PGA_pre_GAIN_CR3], EXGAIN                      ; Set High Gain bit.
0471: 18       POP   A                  (0169)    pop  A
0472: 70 3F    AND   F,0x3F             
0474: 71 C0    OR    F,0xC0             (0170)    RAM_EPILOGUE RAM_USE_CLASS_2
0476: 7F       RET                      (0171)    ret
                                        (0172) .ENDSECTION
                                        (0173) 
                                        (0174) .SECTION
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) ;  FUNCTION NAME: PGA_pre_Stop
                                        (0177) ;
                                        (0178) ;  DESCRIPTION:
                                        (0179) ;    Turns off the power to the amplifier.
                                        (0180) ;
                                        (0181) ;-----------------------------------------------------------------------------
                                        (0182) ;
                                        (0183) ;  ARGUMENTS: None
                                        (0184) ;
                                        (0185) ;  RETURNS:  NA
                                        (0186) ;
                                        (0187) ;  SIDE EFFECTS:
                                        (0188) ;    The A and X registers may be modified by this or future implementations
                                        (0189) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0190) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0191) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0192) ;    functions.
                                        (0193) ;
                                        (0194)  PGA_pre_Stop:
                                        (0195) _PGA_pre_Stop:
                                        (0196) 
                                        (0197)    RAM_PROLOGUE RAM_USE_CLASS_1
0477: 41 73 FC AND   REG[0x73],0xFC     (0198)    and REG[PGA_pre_GAIN_CR2], ~POWERMASK
                                        (0199)    RAM_EPILOGUE RAM_USE_CLASS_1
047A: 7F       RET                      (0200)    ret
(0201) .ENDSECTION
(0202) ; End of File PGA_pre.asm
FILE: lib\pga_out.asm
                                        (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   PGA_out.asm  ( PGA )
                                        (0004) ;;  Version: 3.2, Updated on 2009/10/13 at 23:59:44
                                        (0005) ;;  Generated by PSoC Designer 5.0.1127.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION:  PGA User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) ;; -----------------------------------------------------------------
                                        (0023) ;;                         Register Definitions
                                        (0024) ;;
                                        (0025) ;; Uses 1 Continuous Time Block configured as shown.
                                        (0026) ;;
                                        (0027) ;; * For a Mask/Val pair, this indicates that the value is
                                        (0028) ;;   determined by the user either through config-time parameteriza-
                                        (0029) ;;   tion or run-time manipulation.
                                        (0030) ;;
                                        (0031) ;; BIT FIELD             Mask/Val Function
                                        (0032) ;; -----------------            -----   --------------------
                                        (0033) ;; GAIN_CR0.RES_RATIO_T2B       F0/*    User Parameter (by table)
                                        (0034) ;; GAIN_CR0.GAIN_ATTEN          08/*    Gain (by table)
                                        (0035) ;; GAIN_CR0.RES_SOURCE          04/1    Res source to output
                                        (0036) ;; GAIN_CR0.RES_REF             03/*    Res ref
                                        (0037) ;;
                                        (0038) ;; GAIN_CR1.A_OUT               80/*    User Parameter (Output bus)
                                        (0039) ;; GAIN_CR1.COMP_EN             40/0    Comparator bus disabled
                                        (0040) ;; GAIN_CR1.CT_NEG_INPUT_MUX    38/4    Neg mux to analog f.b. tap
                                        (0041) ;; GAIN_CR1.CT_POS_INPUT_MUX    07/*    Pos mux, typically to col. input mux
                                        (0042) ;;
                                        (0043) ;; GAIN_CR2.CP_COMP             80/0    Latch transparent on PH1
                                        (0044) ;; GAIN_CR2.CK_COMP             40/0    Latch transparent
                                        (0045) ;; GAIN_CR2.CC_COMP             20/1    Mode OP-AMP (not comparator)
                                        (0046) ;; GAIN_CR2.BYPASS_OBUS         1C/0    Bypass OFF
                                        (0047) ;; GAIN_CR2.PWR_SELECT          03/*    Power OFF (0h) at start-up
                                        (0048) ;;
                                        (0049) ;; --------------------------------------------------------------------
                                        (0050) 
                                        (0051) include "PGA_out.inc"
                                        (0052) include "m8c.inc"
                                        (0053) include "memory.inc"
                                        (0054) 
                                        (0055) 
                                        (0056) ;-----------------------------------------------
                                        (0057) ;  Global Symbols
                                        (0058) ;-----------------------------------------------
                                        (0059) export  PGA_out_Start
                                        (0060) export _PGA_out_Start
                                        (0061) export  PGA_out_SetPower
                                        (0062) export _PGA_out_SetPower
                                        (0063) 
                                        (0064) export  PGA_out_SetGain
                                        (0065) export _PGA_out_SetGain
                                        (0066) 
                                        (0067) export  PGA_out_Stop
                                        (0068) export _PGA_out_Stop
                                        (0069) 
                                        (0070) ;-----------------------------------------------
                                        (0071) ;  EQUATES
                                        (0072) ;-----------------------------------------------
                                        (0073) POWERMASK:     equ 03h
                                        (0074) GAINREGMASK:   equ f8h
                                        (0075) GAINMASK:      equ fCh
                                        (0076) HIGHGAIN:      equ 04h
                                        (0077) HIGHGAINMASK:  equ 18h
                                        (0078) EXGAIN:        equ 01h
                                        (0079) 
                                        (0080) AREA UserModules (ROM, REL)
                                        (0081) .SECTION
                                        (0082) ;-----------------------------------------------------------------------------
                                        (0083) ;  FUNCTION NAME: PGA_out_Start
                                        (0084) ;  FUNCTION NAME: PGA_out_SetPower
                                        (0085) ;
                                        (0086) ;  DESCRIPTION:
                                        (0087) ;    Applies power setting to the module's PSoC block.
                                        (0088) ;-----------------------------------------------------------------------------
                                        (0089) ;
                                        (0090) ;  ARGUMENTS:
                                        (0091) ;  A  Contains the power settings 0=Off, 1=Low, 2=Med, and 3=High
                                        (0092) ;
                                        (0093) ;  RETURNS:  NA
                                        (0094) ;
                                        (0095) ;  SIDE EFFECTS:
                                        (0096) ;    The A and X registers may be modified by this or future implementations
                                        (0097) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0098) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0099) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0100) ;    functions.
                                        (0101) ;
                                        (0102)  PGA_out_Start:
                                        (0103) _PGA_out_Start:
                                        (0104)  PGA_out_SetPower:
                                        (0105) _PGA_out_SetPower:
                                        (0106) 
                                        (0107)    RAM_PROLOGUE RAM_USE_CLASS_2
047B: 21 03    AND   A,0x3              (0108)    and  A, POWERMASK                                 ; mask A to protect unchanged bits
047D: 4F       MOV   X,SP               (0109)    mov  X, SP                                        ; define temp store location
                                        (0110) ;
047E: 08       PUSH  A                  (0111)    push A                                            ; put power value in temp store
047F: 5D 7B    MOV   A,REG[0x7B]        (0112)    mov  A, reg[PGA_out_GAIN_CR2]                           ; read power value
0481: 21 FC    AND   A,0xFC             (0113)    and  A, ~POWERMASK                                ; clear power bits in A
0483: 2B 00    OR    A,[X+0]            (0114)    or   A, [X]                                       ; combine power value with balance of reg.
0485: 60 7B    MOV   REG[0x7B],A        (0115)    mov  reg[PGA_out_GAIN_CR2], A                      ; move complete value back to register
0487: 18       POP   A                  (0116)    pop  A
0488: 70 3F    AND   F,0x3F             
048A: 71 C0    OR    F,0xC0             (0117)    RAM_EPILOGUE RAM_USE_CLASS_2
048C: 7F       RET                      (0118)    ret
                                        (0119) .ENDSECTION
                                        (0120) 
                                        (0121) .SECTION
                                        (0122) ;-----------------------------------------------------------------------------
                                        (0123) ;  FUNCTION NAME: PGA_out_SetGain
                                        (0124) ;
                                        (0125) ;  DESCRIPTION:
                                        (0126) ;    This function sets the Gain/Atten of the amplifier.  Valid gain settings
                                        (0127) ;    are defined in the .inc file.
                                        (0128) ;
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;
                                        (0131) ;  ARGUMENTS:
                                        (0132) ;    A  Contains gain settings.
                                        (0133) ;
                                        (0134) ;    Gain values shown are for example. (See .inc file for gain equates)
                                        (0135) ;
                                        (0136) ;  RETURNS:  NA
                                        (0137) ;
                                        (0138) ;  SIDE EFFECTS:
                                        (0139) ;    The A and X registers may be modified by this or future implementations
                                        (0140) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0141) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0142) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0143) ;    functions.
                                        (0144) ;
                                        (0145)  PGA_out_SetGain:
                                        (0146) _PGA_out_SetGain:
                                        (0147) 
                                        (0148)    RAM_PROLOGUE RAM_USE_CLASS_2
048D: 21 FC    AND   A,0xFC             (0149)    and  A, GAINMASK                                       ; mask A to protect unchanged bits
048F: 4F       MOV   X,SP               (0150)    mov  X, SP                                             ; define temp store location
                                        (0151) ;
0490: 08       PUSH  A                  (0152)    push A                                                 ; put gain value in temp store
0491: 5D 79    MOV   A,REG[0x79]        (0153)    mov  A, reg[PGA_out_GAIN_CR0]                           ; read mux settings
0493: 21 07    AND   A,0x7              (0154)    and  A, ~GAINREGMASK                                   ; clear gain bits in A
0495: 48 00 04 TST   [X+0],0x4          (0155)    tst  [X],HIGHGAIN                                      ; See if High Gain is set
0498: B0 0E    JNZ   0x04A7             (0156)    jnz  .SETHIGHGAIN
049A: 41 78 FE AND   REG[0x78],0xFE     (0157)    and  reg[PGA_out_GAIN_CR3],~EXGAIN                      ; Clear High Gain bit.
049D: 2B 00    OR    A,[X+0]            (0158)    or   A, [X]                                            ; combine gain value with balance of reg.
049F: 60 79    MOV   REG[0x79],A        (0159)    mov  reg[PGA_out_GAIN_CR0], A                           ; move complete value back to register
04A1: 18       POP   A                  (0160)    pop  A
04A2: 70 3F    AND   F,0x3F             
04A4: 71 C0    OR    F,0xC0             (0161)    RAM_EPILOGUE RAM_USE_CLASS_2
04A6: 7F       RET                      (0162)    ret
                                        (0163) 
                                        (0164) .SETHIGHGAIN:
04A7: 27 00 18 AND   [X+0],0x18         (0165)    and  [X],HIGHGAINMASK                                  ; Make sure we have a valid high gain
04AA: 2B 00    OR    A,[X+0]            (0166)    or   A, [X]                                            ; combine gain value with balance of reg.
04AC: 60 79    MOV   REG[0x79],A        (0167)    mov  reg[PGA_out_GAIN_CR0], A                           ; move complete value back to register
04AE: 43 78 01 OR    REG[0x78],0x1      (0168)    or   reg[PGA_out_GAIN_CR3], EXGAIN                      ; Set High Gain bit.
04B1: 18       POP   A                  (0169)    pop  A
04B2: 70 3F    AND   F,0x3F             
04B4: 71 C0    OR    F,0xC0             (0170)    RAM_EPILOGUE RAM_USE_CLASS_2
04B6: 7F       RET                      (0171)    ret
                                        (0172) .ENDSECTION
                                        (0173) 
                                        (0174) .SECTION
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) ;  FUNCTION NAME: PGA_out_Stop
                                        (0177) ;
                                        (0178) ;  DESCRIPTION:
                                        (0179) ;    Turns off the power to the amplifier.
                                        (0180) ;
                                        (0181) ;-----------------------------------------------------------------------------
                                        (0182) ;
                                        (0183) ;  ARGUMENTS: None
                                        (0184) ;
                                        (0185) ;  RETURNS:  NA
                                        (0186) ;
                                        (0187) ;  SIDE EFFECTS:
                                        (0188) ;    The A and X registers may be modified by this or future implementations
                                        (0189) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0190) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0191) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0192) ;    functions.
                                        (0193) ;
                                        (0194)  PGA_out_Stop:
                                        (0195) _PGA_out_Stop:
                                        (0196) 
                                        (0197)    RAM_PROLOGUE RAM_USE_CLASS_1
04B7: 41 7B FC AND   REG[0x7B],0xFC     (0198)    and REG[PGA_out_GAIN_CR2], ~POWERMASK
                                        (0199)    RAM_EPILOGUE RAM_USE_CLASS_1
04BA: 7F       RET                      (0200)    ret
(0201) .ENDSECTION
(0202) ; End of File PGA_out.asm
FILE: lib\i2chwrsrcinits.asm
                                        (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: I2CHW.asm
                                        (0004) ;;   Version: 1.6, Updated on 2009/10/15 at 17:11:37
                                        (0005) ;;  Generated by PSoC Designer 5.0.1127.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: I2Cs User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "I2CHWCommon.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ; include instance specific register definitions
                                        (0028) ;-----------------------------------------------
                                        (0029) 
                                        (0030) ;-----------------------------------------------
                                        (0031) ;  Global Symbols
                                        (0032) ;-----------------------------------------------
                                        (0033) ;-------------------------------------------------------------------
                                        (0034) ;  Declare the functions global for both assembler and C compiler.
                                        (0035) ;
                                        (0036) ;  Note that there are two names for each API. First name is
                                        (0037) ;  assembler reference. Name with underscore is name refence for
                                        (0038) ;  C compiler.  Calling function in C source code does not require
                                        (0039) ;  the underscore.
                                        (0040) ;-------------------------------------------------------------------
                                        (0041) 
                                        (0042) export    I2CHW_ResumeInt
                                        (0043) export   _I2CHW_ResumeInt
                                        (0044) export    I2CHW_EnableInt
                                        (0045) export   _I2CHW_EnableInt
                                        (0046) export    I2CHW_ClearInt
                                        (0047) export   _I2CHW_ClearInt
                                        (0048) export    I2CHW_EnableSlave
                                        (0049) export   _I2CHW_EnableSlave
                                        (0050) export    I2CHW_EnableMstr
                                        (0051) export   _I2CHW_EnableMstr
                                        (0052) export    I2CHW_Start
                                        (0053) export   _I2CHW_Start
                                        (0054) export    I2CHW_DisableInt
                                        (0055) export   _I2CHW_DisableInt
                                        (0056) export    I2CHW_DisableSlave
                                        (0057) export   _I2CHW_DisableSlave
                                        (0058) export    I2CHW_DisableMstr
                                        (0059) export   _I2CHW_DisableMstr
                                        (0060) export    I2CHW_Stop
                                        (0061) export   _I2CHW_Stop
                                        (0062) 
                                        (0063) 
                                        (0064) AREA UserModules (ROM, REL)
                                        (0065) 
                                        (0066) .SECTION
                                        (0067) 
                                        (0068) ;-----------------------------------------------------------------------------
                                        (0069) ;  FUNCTION NAME: I2CHW_Start
                                        (0070) ;
                                        (0071) ;  DESCRIPTION:
                                        (0072) ;   Initialize the I2CHW I2C bus interface.
                                        (0073) ;
                                        (0074) ;-----------------------------------------------------------------------------
                                        (0075) ;
                                        (0076) ;  ARGUMENTS:
                                        (0077) ;
                                        (0078) ;  RETURNS: none
                                        (0079) ;
                                        (0080) ;  SIDE EFFECTS:
                                        (0081) ;    The A and X registers may be modified by this or future implementations
                                        (0082) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0083) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0084) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0085) ;    functions.
                                        (0086) ;          
                                        (0087)  I2CHW_Start:
                                        (0088) _I2CHW_Start:
                                        (0089)     RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0090)     RAM_EPILOGUE RAM_USE_CLASS_1
04BB: 7F       RET                      (0091)     ret
                                        (0092) .ENDSECTION
                                        (0093) 
                                        (0094) .SECTION
                                        (0095) ;-----------------------------------------------------------------------------
                                        (0096) ;  FUNCTION NAME: I2CHW_ResumeInt
                                        (0097) ;
                                        (0098) ;  DESCRIPTION:
                                        (0099) ;     reEnables SDA interrupt allowing start condition detection. 
                                        (0100) ;     Skips clearing INT_CLR3 by entering the EnableInt at ResumeIntEntry:.
                                        (0101) ;     Remember to call the global interrupt enable function by using
                                        (0102) ;     the macro: M8C_EnableGInt.
                                        (0103) ;-----------------------------------------------------------------------------
                                        (0104) ;  ARGUMENTS: none
                                        (0105) ;
                                        (0106) ;  RETURNS: none
                                        (0107) ;
                                        (0108) ;  SIDE EFFECTS:
                                        (0109) ;    The A and X registers may be modified by this or future implementations
                                        (0110) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0111) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0112) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0113) ;    functions.
                                        (0114) ;-----------------------------------------------------------------------------
                                        (0115)  I2CHW_ResumeInt:
                                        (0116) _I2CHW_ResumeInt:
                                        (0117)     RAM_PROLOGUE RAM_USE_CLASS_1
04BC: 08       PUSH  A                  (0118)     push A
04BD: 80 08    JMP   0x04C6             (0119)     jmp ResumeIntEntry
                                        (0120)     
                                        (0121) ;-----------------------------------------------------------------------------
                                        (0122) ;  FUNCTION NAME: I2CHW_EnableInt
                                        (0123) ;
                                        (0124) ;  DESCRIPTION:
                                        (0125) ;     Enables SDA interrupt allowing start condition detection. Remember to call the
                                        (0126) ;     global interrupt enable function by using the macro: M8C_EnableGInt.
                                        (0127) ;
                                        (0128) ;-----------------------------------------------------------------------------
                                        (0129) ;
                                        (0130) ;  ARGUMENTS: none
                                        (0131) ;
                                        (0132) ;  RETURNS: none
                                        (0133) ;
                                        (0134) ;  SIDE EFFECTS:
                                        (0135) ;    The A and X registers may be modified by this or future implementations
                                        (0136) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0137) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0138) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0139) ;    functions.
                                        (0140) ;-----------------------------------------------------------------------------
                                        (0141)  I2CHW_EnableInt:
                                        (0142) _I2CHW_EnableInt:
                                        (0143)     RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0144)     ;first clear any pending interrupts
04BF: 08       PUSH  A                  (0145)     push A
04C0: 5D DD    MOV   A,REG[0xDD]        (0146)     mov A, reg[INT_CLR3]
04C2: 21 FE    AND   A,0xFE             (0147)     and A, ~I2CHW_INT_MASK
04C4: 60 DD    MOV   REG[0xDD],A        (0148)     mov reg[INT_CLR3], A
                                        (0149) ResumeIntEntry:
04C6: 43 DE 01 OR    REG[0xDE],0x1      (0150)     M8C_EnableIntMask I2CHW_INT_REG, I2CHW_INT_MASK
04C9: 18       POP   A                  (0151)     pop A
                                        (0152)     RAM_EPILOGUE RAM_USE_CLASS_1
04CA: 7F       RET                      (0153)     ret
                                        (0154) 
                                        (0155) .ENDSECTION
                                        (0156) 
                                        (0157) .SECTION
                                        (0158) ;-----------------------------------------------------------------------------
                                        (0159) ;  FUNCTION NAME: I2CHW_ClearInt
                                        (0160) ;
                                        (0161) ;  DESCRIPTION:
                                        (0162) ;     Clears only the I2C interrupt in the INT_CLR3 register.
                                        (0163) ;
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;
                                        (0166) ;  ARGUMENTS: none
                                        (0167) ;
                                        (0168) ;  RETURNS: none
                                        (0169) ;
                                        (0170) ;  SIDE EFFECTS:
                                        (0171) ;    The A and X registers may be modified by this or future implementations
                                        (0172) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0173) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0174) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0175) ;    functions.
                                        (0176) ;          
                                        (0177)  I2CHW_ClearInt:
                                        (0178) _I2CHW_ClearInt:
                                        (0179)     RAM_PROLOGUE RAM_USE_CLASS_1
04CB: 08       PUSH  A                  (0180)     push A
04CC: 5D DD    MOV   A,REG[0xDD]        (0181)     mov A, reg[INT_CLR3]
04CE: 21 FE    AND   A,0xFE             (0182)     and A, ~I2CHW_INT_MASK
04D0: 60 DD    MOV   REG[0xDD],A        (0183)     mov reg[INT_CLR3], A
04D2: 18       POP   A                  (0184)     pop A
                                        (0185)     RAM_EPILOGUE RAM_USE_CLASS_1
04D3: 7F       RET                      (0186)     ret
                                        (0187)     
                                        (0188) .ENDSECTION
                                        (0189) 
                                        (0190) .SECTION
                                        (0191) ;-----------------------------------------------------------------------------
                                        (0192) ;  FUNCTION NAME: I2CHW_EnableMstr
                                        (0193) ;
                                        (0194) ;  DESCRIPTION:
                                        (0195) ;     Enables SDA interrupt allowing start condition detection. Remember to call the
                                        (0196) ;     global interrupt enable function by using the macro: M8C_EnableGInt.
                                        (0197) ;
                                        (0198) ;-----------------------------------------------------------------------------
                                        (0199) ;
                                        (0200) ;  ARGUMENTS: none
                                        (0201) ;
                                        (0202) ;  RETURNS: none
                                        (0203) ;
                                        (0204) ;  SIDE EFFECTS:
                                        (0205) ;    The A and X registers may be modified by this or future implementations
                                        (0206) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0207) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0208) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0209) ;    functions.
                                        (0210) ;          
                                        (0211)  I2CHW_EnableMstr:
                                        (0212) _I2CHW_EnableMstr:
                                        (0213)     RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0214) 	;;CDT 28399
04D4: 62 D0 00 MOV   REG[0xD0],0x0      (0215) 	RAM_SETPAGE_CUR >I2CHW_bStatus
04D7: 26 00 7F AND   [0x0],0x7F         (0216) 	and [I2CHW_bStatus], ~0x80 ;; ~I2CHW_ISR_ACTIVE
04DA: 62 D0 00 MOV   REG[0xD0],0x0      (0217) 	RAM_SETPAGE_CUR >I2CHW_RsrcStatus
04DD: 26 01 7F AND   [0x1],0x7F         (0218)     and    [I2CHW_RsrcStatus], ~0x80;;~I2CHW_ISR_ACTIVE        ; Make sure internal control variables weren't corrupted previous to start.
04E0: 43 D6 02 OR    REG[0xD6],0x2      (0219)     BitSetI2CHW_CFG I2C_M_EN                                         ;Enable SDA interupt
                                        (0220)     RAM_EPILOGUE RAM_USE_CLASS_1
04E3: 7F       RET                      (0221)     ret
                                        (0222) 
                                        (0223) .ENDSECTION
                                        (0224) 
                                        (0225) .SECTION
                                        (0226) ;-----------------------------------------------------------------------------
                                        (0227) ;  FUNCTION NAME: I2CHW_EnableSlave
                                        (0228) ;
                                        (0229) ;  DESCRIPTION:
                                        (0230) ;     Enables SDA interrupt allowing start condition detection. Remember to call the
                                        (0231) ;     global interrupt enable function by using the macro: M8C_EnableGInt.
                                        (0232) ;
                                        (0233) ;-----------------------------------------------------------------------------
                                        (0234) ;
                                        (0235) ;  ARGUMENTS: none
                                        (0236) ;
                                        (0237) ;  RETURNS: none
                                        (0238) ;
                                        (0239) ;  SIDE EFFECTS:
                                        (0240) ;    The A and X registers may be modified by this or future implementations
                                        (0241) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0242) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0243) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0244) ;    functions.
                                        (0245) ;          
                                        (0246)  I2CHW_EnableSlave:
                                        (0247) _I2CHW_EnableSlave:
                                        (0248)     RAM_PROLOGUE RAM_USE_CLASS_1
04E4: 43 D6 01 OR    REG[0xD6],0x1      (0249)     BitSetI2CHW_CFG I2C_S_EN                                         ;Enable SDA interupt
                                        (0250)     RAM_EPILOGUE RAM_USE_CLASS_1
04E7: 7F       RET                      (0251)     ret
                                        (0252) 
                                        (0253) .ENDSECTION
                                        (0254) 
                                        (0255) .SECTION
                                        (0256) ;-----------------------------------------------------------------------------
                                        (0257) ;  FUNCTION NAME: I2CHW_DisableInt
                                        (0258) ;  FUNCTION NAME: I2CHW_Stop
                                        (0259) ;
                                        (0260) ;  DESCRIPTION:
                                        (0261) ;     Disables I2CHW slave by disabling SDA interrupt
                                        (0262) ;
                                        (0263) ;-----------------------------------------------------------------------------
                                        (0264) ;
                                        (0265) ;  ARGUMENTS: none
                                        (0266) ;
                                        (0267) ;  RETURNS: none
                                        (0268) ;
                                        (0269) ;  SIDE EFFECTS:
                                        (0270) ;    The A and X registers may be modified by this or future implementations
                                        (0271) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0272) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0273) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0274) ;    functions.
                                        (0275) ;          
                                        (0276)  I2CHW_DisableInt:
                                        (0277) _I2CHW_DisableInt:
                                        (0278)  I2CHW_Stop:
                                        (0279) _I2CHW_Stop:
                                        (0280)     RAM_PROLOGUE RAM_USE_CLASS_1
04E8: 41 DE FE AND   REG[0xDE],0xFE     (0281)     M8C_DisableIntMask I2CHW_INT_REG, I2CHW_INT_MASK
                                        (0282)     RAM_EPILOGUE RAM_USE_CLASS_1
04EB: 7F       RET                      (0283)     ret
                                        (0284) 
                                        (0285) .ENDSECTION
                                        (0286) 
                                        (0287) .SECTION
                                        (0288) ;-----------------------------------------------------------------------------
                                        (0289) ;  FUNCTION NAME: I2CHW_DisableSlave
                                        (0290) ;
                                        (0291) ;  DESCRIPTION:
                                        (0292) ;     Disables I2CHW slave by disabling SDA interrupt
                                        (0293) ;
                                        (0294) ;-----------------------------------------------------------------------------
                                        (0295) ;
                                        (0296) ;  ARGUMENTS: none
                                        (0297) ;
                                        (0298) ;  RETURNS: none
                                        (0299) ;
                                        (0300) ;  SIDE EFFECTS:
                                        (0301) ;    The A and X registers may be modified by this or future implementations
                                        (0302) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0303) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0304) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0305) ;    functions.
                                        (0306) ;          
                                        (0307)  I2CHW_DisableSlave:
                                        (0308) _I2CHW_DisableSlave:
                                        (0309)     RAM_PROLOGUE RAM_USE_CLASS_1
04EC: 41 D6 FE AND   REG[0xD6],0xFE     (0310)     BitClrI2CHW_CFG I2C_S_EN                                         ;Disable the Slave
                                        (0311)     RAM_EPILOGUE RAM_USE_CLASS_1
04EF: 7F       RET                      (0312)     ret
                                        (0313) 
                                        (0314) .ENDSECTION
                                        (0315) 
                                        (0316) .SECTION
                                        (0317) ;-----------------------------------------------------------------------------
                                        (0318) ;  FUNCTION NAME: I2CHW_DisableMstr
                                        (0319) ;
                                        (0320) ;  DESCRIPTION:
                                        (0321) ;     Disables I2CHW slave by disabling SDA interrupt
                                        (0322) ;
                                        (0323) ;-----------------------------------------------------------------------------
                                        (0324) ;
                                        (0325) ;  ARGUMENTS: none
                                        (0326) ;
                                        (0327) ;  RETURNS: none
                                        (0328) ;
                                        (0329) ;  SIDE EFFECTS:
                                        (0330) ;    The A and X registers may be modified by this or future implementations
                                        (0331) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0332) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0333) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0334) ;    functions.
                                        (0335) ;          
                                        (0336)  I2CHW_DisableMstr:
                                        (0337) _I2CHW_DisableMstr:
                                        (0338)     RAM_PROLOGUE RAM_USE_CLASS_1
04F0: 41 D6 FD AND   REG[0xD6],0xFD     (0339)     BitClrI2CHW_CFG I2C_M_EN                                         ;Disable the Master
                                        (0340)     RAM_EPILOGUE RAM_USE_CLASS_1
04F3: 7F       RET                      (0341)    ret
(0342) 
(0343) .ENDSECTION
(0344) 
(0345) ; End of File I2CHW.asm
FILE: lib\i2chwint.asm
                                        (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: I2CHWINT.asm
                                        (0004) ;;   Version: 1.6, Updated on 2009/10/15 at 17:11:37
                                        (0005) ;;  Generated by PSoC Designer 5.0.1127.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: I2CHW (Slave) Interrupt Service Routine.
                                        (0008) ;;  This is the interrupt seveice routine for the Slave I2C function.
                                        (0009) ;;-----------------------------------------------------------------------------
                                        (0010) ;;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0011) ;;*****************************************************************************
                                        (0012) ;;*****************************************************************************
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "I2CHWSlave.inc"
                                        (0016) include "I2CHWCommon.inc"
                                        (0017) 
                                        (0018) 
                                        (0019) ;-----------------------------------------------
                                        (0020) ;  Global Symbols
                                        (0021) ;-----------------------------------------------
                                        (0022) export     I2CHW_RsrcStatus                                          ; upper (7x) bits write status, lower 3 bits read status
                                        (0023) export    _I2CHW_RsrcStatus                                          ; upper (7x) bits write status, lower 3 bits read status
                                        (0024) export     I2CHW_Read_Count
                                        (0025) export    _I2CHW_Read_Count
                                        (0026) export     I2CHW_Write_Count
                                        (0027) export    _I2CHW_Write_Count
                                        (0028) export    pI2CHW_Read_BufLO
                                        (0029) export   _pI2CHW_Read_BufLO
                                        (0030) export    pI2CHW_Write_BufLO
                                        (0031) export   _pI2CHW_Write_BufLO
                                        (0032) export   _I2CHW_bStatus
                                        (0033) export    I2CHW_bStatus
                                        (0034) 
                                        (0035) ;-----------------------------------------------
                                        (0036) ; WARNING: The variables below are deprecated
                                        (0037) ; and have been replaced with Read_BufLO
                                        (0038) ; and Write_BufLO
                                        (0039) ;-----------------------------------------------
                                        (0040) export    pI2CHW_Read_Buf
                                        (0041) export   _pI2CHW_Read_Buf
                                        (0042) export    pI2CHW_Write_Buf
                                        (0043) export   _pI2CHW_Write_Buf
                                        (0044) ;-----------------------------------------------
                                        (0045) ; END WARNING
                                        (0046) ;-----------------------------------------------
                                        (0047) 
                                        (0048) area InterruptRAM(RAM, REL, CON)	 
                                        (0049) 
                                        (0050) ;-----------------------------------------------
                                        (0051) ; Variable Allocation
                                        (0052) ;-----------------------------------------------
                                        (0053) 
                                        (0054)  _I2CHW_bStatus:
                                        (0055)   I2CHW_bStatus:                             blk 1
                                        (0056)   I2CHW_RsrcStatus:
                                        (0057)  _I2CHW_RsrcStatus:                          blk     1
                                        (0058)   I2CHW_Write_Count:
                                        (0059)  _I2CHW_Write_Count:                         blk    1
                                        (0060) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0061) export    pI2CHW_Write_BufHI
                                        (0062) export   _pI2CHW_Write_BufHI
                                        (0063) 
                                        (0064)  pI2CHW_Write_BufHI:
                                        (0065) _pI2CHW_Write_BufHI:                         blk     1
                                        (0066) ENDIF
                                        (0067) ;-----------------------------------------------
                                        (0068) ; WARNING: The variable below is deprecated
                                        (0069) ; and has been replaced Write_BufLO
                                        (0070) ;-----------------------------------------------
                                        (0071)  pI2CHW_Write_Buf:
                                        (0072) _pI2CHW_Write_Buf:
                                        (0073) ;-----------------------------------------------
                                        (0074) ; END WARNING
                                        (0075) ;-----------------------------------------------
                                        (0076)  pI2CHW_Write_BufLO:
                                        (0077) _pI2CHW_Write_BufLO:                         blk      1
                                        (0078) 
                                        (0079) IF I2CHW_READ_FLASH
                                        (0080) export    pI2CHW_Read_BufHI
                                        (0081) export   _pI2CHW_Read_BufHI
                                        (0082) 
                                        (0083)  pI2CHW_Read_BufHI:
                                        (0084) _pI2CHW_Read_BufHI:                          blk     1
                                        (0085) ELSE
                                        (0086) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0087) export    pI2CHW_Read_BufHI
                                        (0088) export   _pI2CHW_Read_BufHI
                                        (0089) 
                                        (0090)  pI2CHW_Read_BufHI:
                                        (0091) _pI2CHW_Read_BufHI:                          blk     1
                                        (0092) ENDIF
                                        (0093) ENDIF
                                        (0094) 
                                        (0095) ;-----------------------------------------------
                                        (0096) ; WARNING: The variable below is deprecated
                                        (0097) ; and has been replaced Read_BufLO
                                        (0098) ;-----------------------------------------------
                                        (0099)  pI2CHW_Read_Buf:
                                        (0100) _pI2CHW_Read_Buf:
                                        (0101) ;-----------------------------------------------
                                        (0102) ; END WARNING
                                        (0103) ;-----------------------------------------------
                                        (0104)  pI2CHW_Read_BufLO:
                                        (0105) _pI2CHW_Read_BufLO:                          blk       1
                                        (0106) 
                                        (0107) IF I2CHW_READ_FLASH
                                        (0108) export    I2CHW_Read_CountHI
                                        (0109) export   _I2CHW_Read_CountHI
                                        (0110) 
                                        (0111)  I2CHW_Read_CountHI:
                                        (0112) _I2CHW_Read_CountHI:                         blk    1
                                        (0113) ENDIF
                                        (0114) 
                                        (0115)  I2CHW_Read_Count:
                                        (0116) _I2CHW_Read_Count:                           blk      1
                                        (0117) 
                                        (0118) 
                                        (0119) IF I2CHW_POLLED_PROCESS
                                        (0120) 
                                        (0121) I2CHW_Poll_Status:                             blk      1  ;internal variable used for polled operation
                                        (0122) ;bit 0 - Write transaction started begin looking for the STOP state to terminate the transaction
                                        (0123) I2C_WRITE_STARTED:       equ     0x01
                                        (0124) ;bit 1 - Undefined
                                        (0125) ;bit 2 - Undefined
                                        (0126) ;bit 3 - Undefined
                                        (0127) ;bit 4 - Undefined
                                        (0128) ;bit 5 - Undefined
                                        (0129) ;bit 6 - Undefined
                                        (0130) ;bit 7 - Undefined
                                        (0131) 
                                        (0132) ENDIF
                                        (0133) 
                                        (0134) 
                                        (0135) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0136) ;---------------------------------------------------
                                        (0137) ; Insert your custom declarations below this banner
                                        (0138) ;---------------------------------------------------
                                        (0139) 
                                        (0140) ;------------------------
                                        (0141) ; Includes
                                        (0142) ;------------------------
                                        (0143) 
                                        (0144) 	
                                        (0145) ;------------------------
                                        (0146) ;  Constant Definitions
                                        (0147) ;------------------------
                                        (0148) 
                                        (0149) 
                                        (0150) ;------------------------
                                        (0151) ; Variable Allocation
                                        (0152) ;------------------------
                                        (0153) 
                                        (0154) 
                                        (0155) ;---------------------------------------------------
                                        (0156) ; Insert your custom declarations above this banner
                                        (0157) ;---------------------------------------------------
                                        (0158) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0159) 
                                        (0160) 
                                        (0161) 
                                        (0162) 
                                        (0163) AREA UserModules (ROM, REL)
                                        (0164) 
                                        (0165) export _I2CHW_ISR
                                        (0166) export _I2CHW_Poll
                                        (0167) export  I2CHW_Poll
                                        (0168) 
                                        (0169) ;;****************************************************
                                        (0170) ;; I2C_ISR  main entry point from vector 60h
                                        (0171) ;;
                                        (0172) ;;****************************************************
                                        (0173) 
                                        (0174) IF I2CHW_POLLED_PROCESS
                                        (0175) 
                                        (0176) _I2CHW_ISR:
                                        (0177)     reti ; stub out the ISR if this is going to be a polled function
                                        (0178) 
                                        (0179)  
                                        (0180)  
                                        (0181)  I2CHW_Poll:
                                        (0182) _I2CHW_Poll:
                                        (0183) ;    cases are:
                                        (0184) ;    1. Stop state after a Master write to this slave
                                        (0185) ;    2. possible Stop condition COMBINED with a new transaction is not a problem since the Stop will only flag that the 
                                        (0186) ;       previous write has been completed. (so just call the I2CA_Process routine for this case and let the process routine take
                                        (0187) ;       care of it.
                                        (0188)     ;case 1
                                        (0189)     RAM_SETPAGE_CUR	( >I2CHW_Poll_Status )
                                        (0190) 
                                        (0191)     tst [I2CHW_Poll_Status], I2C_WRITE_STARTED
                                        (0192)     jz  NOT_I2C_Write
                                        (0193)     tst reg[ I2CHW_SCR], I2C_STOP_ST
                                        (0194)     jz  NOT_I2C_Write
                                        (0195)     ;make sure the pushes and pops 'line up' or die horribly
                                        (0196)     push A
                                        (0197)     push X
                                        (0198) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0199)     REG_PRESERVE IDX_PP
                                        (0200) ENDIF
                                        (0201)     jmp STOPTRAP
                                        (0202)     
                                        (0203) NOT_I2C_Write:    
                                        (0204)     tst reg[ I2CHW_SCR], I2C_BYTE_COMPL
                                        (0205)     jnz  I2CHW_Process   ;if no other critical eventa are in evidence, process an I2C byte if it's done
                                        (0206)     ret
                                        (0207) 
                                        (0208)  I2CHW_Process:
                                        (0209) _I2CHW_Process:  ;don't need to export user will call I2CA_POLL which will call the I2CA_Process routine if necessary
                                        (0210) 
                                        (0211) 
                                        (0212) 
                                        (0213) ELSE
                                        (0214) ;; STUB for polling function when it's un-defined
                                        (0215)  I2CHW_Poll:
                                        (0216) _I2CHW_Poll:
04F4: 7F       RET                      (0217)     ret
                                        (0218) 
                                        (0219) 
                                        (0220) ;;*****************************************************************************************
                                        (0221) ;;                 I2C_MASTER  main entry point from vector 60h
                                        (0222) ;;*****************************************************************************************
                                        (0223) 
                                        (0224) _I2CHW_ISR:
                                        (0225) ENDIF
04F5: 08       PUSH  A                  (0226)     push A
04F6: 10       PUSH  X                  (0227)     push X
                                        (0228) 
                                        (0229) IF SYSTEM_LARGE_MEMORY_MODEL
04F7: 5D D3    MOV   A,REG[0xD3]        
04F9: 08       PUSH  A                  (0230)     REG_PRESERVE IDX_PP
                                        (0231) ENDIF
                                        (0232) 
                                        (0233) Process_REENTRY:
                                        (0234) 
                                        (0235) ;******************************************************************************************
                                        (0236) ;Before doing anything else check for the presence of a STOP_ST in combination with the
                                        (0237) ;STOP Interrupt Enable (STOPIE).  If this is what happened set appropriate bits, 
                                        (0238) ;clear and reset the main I2CHW interrupt to assure that we haven't missed a BYTE_COMPLETE
                                        (0239) ;interrupt and exit the interrupt.  If a BYTE_COMPLETE interrupt is concurrent with the STOP 
                                        (0240) ;interrupt the next entry to this interrupt will be immediate and the STOPIE bit will now be 
                                        (0241) ;cleared.  This removes the possibility of trying to process two different events within one 
                                        (0242) ;interrupt.
                                        (0243) ;          
                                        (0244) ;******************************************************************************************
                                        (0245) ; Check the Stop Bit in SCR only if the Stop Interrupt is enabled.    
                                        (0246)     IF(I2CHW_USED_I2C_BLOCK)
                                        (0247)     M8C_SetBank1
                                        (0248)     tst reg[I2CHW_CFG],I2C_STOPIE
                                        (0249)     M8C_SetBank0
                                        (0250)     ELSE
04FA: 49 D6 10 TST   REG[0xD6],0x10     (0251)     tst reg[I2CHW_CFG],I2C_STOPIE
                                        (0252)     ENDIF
04FD: A0 06    JZ    0x0504             (0253)     jz  ByteComplProcess
04FF: 49 D7 20 TST   REG[0xD7],0x20     (0254)     tst reg[I2CHW_SCR],I2C_STOP_ST                         ; Test if the Interrupt is due to Stop Condition
                                        (0255) ;conditions that must be met here are Slave-enabled, STOP int enabled (STOPIE), and STOP_ST (status bit set)
0502: B0 EB    JNZ   0x05EE             (0256)     jnz STOPTRAP                                       ; If yes process Stop Trap
                                        (0257) 
                                        (0258) ByteComplProcess:
                                        (0259) ;*********END TEST OF STOP STATUS**********************************************************       
                                        (0260) 
                                        (0261) ;       file stored in Slave directory of user module
                                        (0262) ;program flow would likely be to first determine what 'mode' the device is in.  I.e. is Master and Slave mode enabled?
                                        (0263) ; control of program flow must take more into account when all more modes are enabled.
                                        (0264) ;
                                        (0265) ;* Slave only
                                        (0266)     ;very first thing to test is the I2C_ADDRIN bit.  If set then we are getting an address after a START
0504: 49 D7 08 TST   REG[0xD7],0x8      (0267)     tst reg[I2CHW_SCR], I2C_ADDRIN
0507: B0 74    JNZ   0x057C             (0268)     jnz I2C_EvaluateADDRIN
                                        (0269) 
                                        (0270)     ; if slave didn't recieve an address, then this must be data for it to deal with
0509: 49 D7 04 TST   REG[0xD7],0x4      (0271)     tst reg[I2CHW_SCR], I2C_TX  ;if set we are transmitting => this is at end of byte to eval the ACK
050C: B0 BE    JNZ   0x05CB             (0272)     jnz I2C_EvaluateACKIN
                                        (0273)     ; if slave NOT transmitting and NOT an address then data is being recieved
                                        (0274)     ; ack it and process it.
                                        (0275) 
                                        (0276)     ;UNLESS the stop bit turns out to have been set...
050E: 49 D7 20 TST   REG[0xD7],0x20     (0277)     tst reg[I2CHW_SCR], I2C_STOP_ST
0511: B0 DC    JNZ   0x05EE             (0278)     jnz STOPTRAP
                                        (0279)     ; if slave NOT transmitting and NOT an address and Master is NOT terminating the then data is being recieved
                                        (0280)     ; ack it and process it.
                                        (0281) 
                                        (0282) ;;code snipped from old SW I2C below
                                        (0283) ;
                                        (0284) ; MASTER WRITE to SLAVE
                                        (0285) ;
                                        (0286) ;@PSoC_UserCode_BODY1@ (Do not change this line.)
                                        (0287) ;---------------------------------------------------
                                        (0288) ; Insert your custom code below this banner
                                        (0289) ;---------------------------------------------------
                                        (0290) ; By modifying the section from here down to the next comment block
                                        (0291) ; a user could process data for a custom I2C WRITE application
                                        (0292) ; NOTE: I2C handshakes (ACK/NAK may be effected by any introduced bugs)
                                        (0293) ;********************************************************
0513: 47 00 04 TST   [0x0],0x4          (0294)    tst   [I2CHW_bStatus], fI2C_NAKnextWr
0516: B0 14    JNZ   0x052B             (0295)    jnz   WrStoreData
                                        (0296)    ;
                                        (0297)    ;process write data here
                                        (0298)    ;
0518: 7A 02    DEC   [0x2]              (0299)    dec   [I2CHW_Write_Count]
051A: C0 39    JC    0x0554             (0300)    jc    I2CHW_WriteOverflow                                         ; carry set if value became -1
                                        (0301)    ;jz    WrStoreData
051C: 3C 02 00 CMP   [0x2],0x0          (0302)    cmp   [I2CHW_Write_Count], 00                                     ;set nak flag, dec count, and store data
051F: A0 03    JZ    0x0523             (0303)    jz    WrNakNextByte
0521: 80 06    JMP   0x0528             (0304)    jmp   WrNotBufEnd
                                        (0305) WrNakNextByte:                                                       ;set the nakflag in I2CHW_bStatus
0523: 2E 00 04 OR    [0x0],0x4          (0306)    or    [I2CHW_bStatus], fI2C_NAKnextWr
0526: 80 04    JMP   0x052B             (0307)    jmp   WrStoreData
                                        (0308) WrNotBufEnd:
0528: 26 00 FB AND   [0x0],0xFB         (0309)    and   [I2CHW_bStatus], ~fI2C_NAKnextWr                            ;clear the nak flag in case it was set from a previous operation
                                        (0310) WrStoreData:
                                        (0311)    ;This is the ONLY place this bit is set  This bit should never be cleared by the isr ONLY by the API ClrWrStatus()
052B: 2E 01 10 OR    [0x1],0x10         (0312)    or    [I2CHW_RsrcStatus], I2CHW_WR_NOERR                          ;set current status
                                        (0313) IF SYSTEM_LARGE_MEMORY_MODEL
052E: 51 03    MOV   A,[0x3]            (0314)    mov   A, [pI2CHW_Write_BufHI]
                                        (0315) ENDIF
0530: 60 D3    MOV   REG[0xD3],A        (0316)    RAM_SETPAGE_IDX A
0532: 58 04    MOV   X,[0x4]            (0317)    mov   X, [pI2CHW_Write_BufLO]
0534: 5D D8    MOV   A,REG[0xD8]        (0318)    mov   A, reg[I2CHW_DR]
0536: 70 3F    AND   F,0x3F             
0538: 71 80    OR    F,0x80             (0319)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
053A: 54 00    MOV   [X+0],A            (0320)    mov   [X], A
053C: 70 3F    AND   F,0x3F             
053E: 71 00    OR    F,0x0              (0321)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
0540: 76 04    INC   [0x4]              (0322)    inc   [pI2CHW_Write_BufLO]
                                        (0323) 
0542: 47 00 04 TST   [0x0],0x4          (0324)    tst   [I2CHW_bStatus], fI2C_NAKnextWr
0545: B0 16    JNZ   0x055C             (0325)    jnz   NAK_this_one
                                        (0326) 
                                        (0327) 
                                        (0328) ;---------------------------------------------------
                                        (0329) ; End user I2C WRITE Customization
                                        (0330) ; Insert your custom code above this banner
                                        (0331) ;---------------------------------------------------
                                        (0332) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0333) ;;code snipped form SW I2C to maintain api compatibility above
                                        (0334) 
                                        (0335) ;
                                        (0336) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (0337) ;
0547: 62 D7 10 MOV   REG[0xD7],0x10     (0338)     SetI2CHW_SCR  (I2C_ACKOUT )
                                        (0339) 
                                        (0340) 
                                        (0341) IF SYSTEM_LARGE_MEMORY_MODEL
054A: 18       POP   A                  
054B: 60 D3    MOV   REG[0xD3],A        (0342)     REG_RESTORE IDX_PP
                                        (0343) ENDIF
054D: 20       POP   X                  (0344)     pop X
054E: 18       POP   A                  (0345)     pop A
054F: 70 3F    AND   F,0x3F             
0551: 71 C0    OR    F,0xC0             (0346)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
0553: 7E       RETI                     (0347)     I2CHW_SERVICE_RETURN
                                        (0348) 
                                        (0349) 
                                        (0350) ;
                                        (0351) ;ram-write-overflow label here, just rewrite the last location in the buffer
                                        (0352) ;    and set the overflow flag
                                        (0353) ;
                                        (0354) I2CHW_WriteOverflow:
0554: 2E 01 20 OR    [0x1],0x20         (0355)    or    [I2CHW_RsrcStatus], I2CHW_WR_OVERFLOW                       ; flag the overflow
0557: 26 01 EF AND   [0x1],0xEF         (0356)    and   [I2CHW_RsrcStatus], ~I2CHW_WR_NOERR
055A: 76 02    INC   [0x2]              (0357)    inc   [I2CHW_Write_Count]                                         ; put it back to zero
                                        (0358)    ;If data is to be Nak'ed
                                        (0359) NAK_this_one:
055C: 26 00 FB AND   [0x0],0xFB         (0360)    and   [I2CHW_bStatus], ~fI2C_NAKnextWr                            ;clear the nak flag in case it was set from a previous operation
                                        (0361) 
                                        (0362) ;
                                        (0363) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (0364) ;
055F: 62 D7 00 MOV   REG[0xD7],0x0      (0365)     SetI2CHW_SCR ( 0 )
                                        (0366) 
                                        (0367) 
                                        (0368) IF SYSTEM_LARGE_MEMORY_MODEL
0562: 18       POP   A                  
0563: 60 D3    MOV   REG[0xD3],A        (0369)     REG_RESTORE IDX_PP
                                        (0370) ENDIF
0565: 20       POP   X                  (0371)     pop X
0566: 18       POP   A                  (0372)     pop A
0567: 70 3F    AND   F,0x3F             
0569: 71 C0    OR    F,0xC0             (0373)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
056B: 7E       RETI                     (0374)     I2CHW_SERVICE_RETURN                                                              ;return and wait for the next interrupt (on data)
                                        (0375) 
                                        (0376) 
                                        (0377) ;********************************************************
                                        (0378) ; Treat the case where the Slave will be continuing to
                                        (0379) ; receive data after receiving the address
                                        (0380) ;********************************************************
                                        (0381) I2C_AckAddr_RXdata:
                                        (0382) IF I2CHW_POLLED_PROCESS
                                        (0383)     or [I2CHW_Poll_Status], I2C_WRITE_STARTED
                                        (0384) ELSE
056C: 43 D6 10 OR    REG[0xD6],0x10     (0385)     BitSetI2CHW_CFG ( I2C_STOPIE )
                                        (0386) ENDIF
                                        (0387) 
                                        (0388) ;
                                        (0389) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (0390) ;
056F: 62 D7 10 MOV   REG[0xD7],0x10     (0391)     SetI2CHW_SCR ( I2C_ACKOUT )
                                        (0392) 
                                        (0393) 
                                        (0394) IF SYSTEM_LARGE_MEMORY_MODEL
0572: 18       POP   A                  
0573: 60 D3    MOV   REG[0xD3],A        (0395)     REG_RESTORE IDX_PP
                                        (0396) ENDIF
0575: 20       POP   X                  (0397)     pop X
0576: 18       POP   A                  (0398)     pop A
0577: 70 3F    AND   F,0x3F             
0579: 71 C0    OR    F,0xC0             (0399)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
057B: 7E       RETI                     (0400)     I2CHW_SERVICE_RETURN
                                        (0401) 
                                        (0402) ;********************************************************
                                        (0403) ; Look to see if the address is us or someone else
                                        (0404) ; use the carry flag to idendify a READ or WRITE address
                                        (0405) ;********************************************************
                                        (0406) I2C_EvaluateADDRIN:
057C: 51 01    MOV   A,[0x1]            (0407)     mov A, [I2CHW_RsrcStatus]
057E: 21 30    AND   A,0x30             (0408)     and A, (I2CHW_WR_NOERR | I2CHW_WR_OVERFLOW)
0580: A0 07    JZ    0x0588             (0409)     jz  NewADDRNotSet                                                                                             ;set new addr only if previous data appears to be in buffer
0582: 2E 01 40 OR    [0x1],0x40         (0410)     or  [I2CHW_RsrcStatus], I2CHW_WR_COMPLETE                        ;Same bit as I2CHW_ISR_NEW_ADDR
                                        (0411) 
                                        (0412) IF I2CHW_POLLED_PROCESS						                                ;if a new addr was received it's OK to terminate stop detection
                                        (0413)     and [I2CHW_Poll_Status], ~I2C_WRITE_STARTED              ;used to determine the end of a Master write to a slave.
                                        (0414) ELSE			
0585: 41 D6 EF AND   REG[0xD6],0xEF     (0415)     BitClrI2CHW_CFG I2C_STOPIE
                                        (0416) ENDIF
                                        (0417)                                                                                                                                           ;SET WR_COMPL bit if it appears there was write taking place just previous
                                        (0418) NewADDRNotSet:                                                       ;may use as a way to tag the end of a master write to slave
                                        (0419) ;@PSoC_UserCode_BODY4@ (Do not change this line.)
                                        (0420) ;---------------------------------------------------
                                        (0421) ; Insert your custom code below this banner
                                        (0422) ;---------------------------------------------------
                                        (0423) ; By replacing the section from here down to the next block
                                        (0424) ; a user could process I2C addresses differently
                                        (0425) ;********************************************************
                                        (0426)                                                                                                                                           ;to this new address by looking at the status bits
                                        (0427)     ;inc [rec_cnt]
0588: 5D D8    MOV   A,REG[0xD8]        (0428)     mov A, reg[I2CHW_DR]
058A: 70 F9    AND   F,0xF9             (0429)     and F, 0xF9                                                      ;clear Carry (C) AND Zero (Z) in Flag reg
058C: 6D       RRC   A                  (0430)     rrc A                                                            ;carry now holds bit 0 (r/~w) from addr byte
                                        (0431) IF (I2CHW_AUTO_ADDR_CHECK^1)   ;; for CY8C28X45 chip: skip address comparison and NACK sending stage-hardware will do this for us  if AutoAddressCompare feature is enabled.
                                        (0432)                                           ;; The code in this pre-compiler directive will be executed for all chips except CY8C28X45.
058D: 31 00    XOR   A,0x0              (0433)     xor A,  I2CHW_SLAVE_ADDR                                         ;for an equate
058F: B0 4E    JNZ   0x05DE             (0434)     jnz I2C_Terminate
                                        (0435) ENDIF
0591: 2E 01 80 OR    [0x1],0x80         (0436)     or [I2CHW_RsrcStatus], I2CHW_ISR_ACTIVE
                                        (0437) 
                                        (0438) ;********************************************************
                                        (0439) ; User could modify this section to allow the I2C routine
                                        (0440) ; to respond to multiple addresses, ram addresses, i/o pin
                                        (0441) ; based addresses, etc.
                                        (0442) ;********************************************************
                                        (0443) ;---------------------------------------------------
                                        (0444) ; End user I2C ADDR Compare Customization
                                        (0445) ; Insert your custom code above this banner
                                        (0446) ;---------------------------------------------------
                                        (0447) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0448) 
                                        (0449) I2CHW_send_ack:                                                      ;slave send adress ack
                                        (0450) 
                                        (0451) 
                                        (0452)     ;OK so the addreses were the same was it a read (c=1) or a write (c=0)
0594: DF D7    JNC   0x056C             (0453)     jnc I2C_AckAddr_RXdata ;(Master Write/Slave Receive) for this case we receive data and ack it
                                        (0454) 
                                        (0455) ;********************************************************
                                        (0456) ;Master Read (Master Read/Slave Transmit) Ack the address too.
                                        (0457) ;for this case the master has just sent us OUR read address which must be Ack'ed and will
                                        (0458) ;subsequently be reading from us (which the master will Ack.  So for the first bit we must
                                        (0459) ; set the I2C_TX AND the ACK bits in the I2C_SCR (first byte only)
                                        (0460) ; THEN we'll just be reading the ACK from the master as it reads our data
                                        (0461) ;********************************************************
                                        (0462) 
0596: 26 01 FB AND   [0x1],0xFB         (0463)     and [I2CHW_RsrcStatus], ~I2CHW_RD_COMPLETE                       ;Master will NAK us at the end of transaction
                                        (0464) 
0599: 50 14    MOV   A,0x14             (0465)     mov A, (I2C_ACKOUT | I2C_TX)
059B: 08       PUSH  A                  (0466)     push A
                                        (0467) 
                                        (0468) 
                                        (0469) ;
                                        (0470) ;MASTER is READING FROM SLAVE (ram or flash buffer)
                                        (0471) ;
                                        (0472) ;;code snipped from old SW I2C below
                                        (0473) 
                                        (0474) I2C_ObtainReadData:
                                        (0475) 
                                        (0476) ;********************************************************
                                        (0477) ; here we need to get the next data to output (master-read)
                                        (0478) ; also set the status byte for use on exit
                                        (0479) ;********************************************************
                                        (0480) IF I2CHW_READ_FLASH
                                        (0481) ;@PSoC_UserCode_BODY2@ (Do not change this line.)
                                        (0482) ;---------------------------------------------------
                                        (0483) ; Insert your custom code below this banner
                                        (0484) ; User flash read customization could take place within
                                        (0485) ; this area
                                        (0486) ;---------------------------------------------------
                                        (0487)     tst  [I2CHW_RsrcStatus],I2CHW_READFLASH
                                        (0488)     jz   ReadRamData
                                        (0489) 
                                        (0490)     ;
                                        (0491)     ;get the data
                                        (0492)     ;
                                        (0493)     mov  X, [pI2CHW_Read_BufLO]
                                        (0494)     mov  A, [pI2CHW_Read_BufHI]
                                        (0495)     romx
                                        (0496)     mov  reg[I2CHW_DR],A
                                        (0497)     dec  [I2CHW_Read_Count]                                          ;calc addr lsb
                                        (0498)     jnc  NoDecHighCount
                                        (0499)     dec  [I2CHW_Read_CountHI]
                                        (0500)     jc   FlashRdOverflow
                                        (0501) 
                                        (0502) NoDecHighCount:
                                        (0503) 
                                        (0504)     inc  [pI2CHW_Read_BufLO]                                         ;set the next flash address to read
                                        (0505)     jnc  NoIncHiAddr
                                        (0506)     inc  [pI2CHW_Read_BufHI]
                                        (0507) NoIncHiAddr:
                                        (0508)    jmp   I2CNormalRead
                                        (0509) 
                                        (0510) FlashRdOverflow:
                                        (0511)     ;deal with the over flow cond by resending last data byte (dec the low order addr byte)
                                        (0512) 
                                        (0513)    or    [I2CHW_RsrcStatus], I2CHW_RD_OVERFLOW
                                        (0514)    and   [I2CHW_RsrcStatus], ~I2CHW_RD_NOERR
                                        (0515)    ;set count back to 0
                                        (0516)    mov   [I2CHW_Read_CountHI], 0                                     ;functionally the same as incrementing ffff and less instructions
                                        (0517)    mov   [I2CHW_Read_Count], 0
                                        (0518)    jmp   I2CNormalRead
                                        (0519) ;---------------------------------------------------
                                        (0520) ; Insert your custom code above this banner
                                        (0521) ; END User flash read customization
                                        (0522) ;---------------------------------------------------
                                        (0523) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0524) ENDIF
                                        (0525) ;@PSoC_UserCode_BODY3@ (Do not change this line.)
                                        (0526) ;---------------------------------------------------
                                        (0527) ; Insert your custom code below this banner
                                        (0528) ;---------------------------------------------------
                                        (0529) ; By replacing the section from here down to the next block
                                        (0530) ; a user could process data for a custom I2C READ application
                                        (0531) ;********************************************************
                                        (0532) ReadRamData:
                                        (0533)    ;read the current data byte
                                        (0534) IF SYSTEM_LARGE_MEMORY_MODEL
059C: 51 05    MOV   A,[0x5]            (0535)    mov   A, [pI2CHW_Read_BufHI]
                                        (0536) ENDIF
059E: 60 D3    MOV   REG[0xD3],A        (0537)    RAM_SETPAGE_IDX A
05A0: 58 06    MOV   X,[0x6]            (0538)    mov   X, [pI2CHW_Read_BufLO]
05A2: 70 3F    AND   F,0x3F             
05A4: 71 80    OR    F,0x80             (0539)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
05A6: 52 00    MOV   A,[X+0]            (0540)    mov   A, [X]
05A8: 70 3F    AND   F,0x3F             
05AA: 71 00    OR    F,0x0              (0541)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
05AC: 60 D8    MOV   REG[0xD8],A        (0542)    mov   reg[I2CHW_DR], A
05AE: 7A 07    DEC   [0x7]              (0543)    dec   [I2CHW_Read_Count]
05B0: C0 05    JC    0x05B6             (0544)    jc    I2CHW_readOverflow
05B2: 76 06    INC   [0x6]              (0545)    inc   [pI2CHW_Read_BufLO]
05B4: 80 09    JMP   0x05BE             (0546)    jmp   I2CNormalRead
                                        (0547) ;
                                        (0548) ;ram read overflow detected here, just resend the last location in the buffer
                                        (0549) ;
                                        (0550) I2CHW_readOverflow:
05B6: 2E 01 02 OR    [0x1],0x2          (0551)    or    [I2CHW_RsrcStatus], I2CHW_RD_OVERFLOW
05B9: 26 01 FE AND   [0x1],0xFE         (0552)    and   [I2CHW_RsrcStatus], ~I2CHW_RD_NOERR
05BC: 76 07    INC   [0x7]              (0553)    inc   [I2CHW_Read_Count]                                          ; set back to zero
                                        (0554) 
                                        (0555) ;********************************************************
                                        (0556) ; End user I2C READ customization section
                                        (0557) ;********************************************************
                                        (0558) ; Insert your custom code above this banner
                                        (0559) ;---------------------------------------------------
                                        (0560) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0561) 
                                        (0562) ;;code snipped form SW I2C to maintain api compatibility above
                                        (0563) I2CNormalRead:
                                        (0564) 
                                        (0565)         ;load the bits to set in the I2C_ISR from the stack, The proper bit pattern was previously determined
                                        (0566)         ;and place there based on whether or not the previous transmission was our I2C address.
05BE: 18       POP   A                  (0567)         pop A
                                        (0568) 
                                        (0569) ;
                                        (0570) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (0571) ;
05BF: 60 D7    MOV   REG[0xD7],A        (0572)     SetI2CHW_SCR A     ;set read bit as (bit0) and Addr bit (bit7)in the I2C_SCR
                                        (0573) 
                                        (0574) 
                                        (0575) IF SYSTEM_LARGE_MEMORY_MODEL
05C1: 18       POP   A                  
05C2: 60 D3    MOV   REG[0xD3],A        (0576)     REG_RESTORE IDX_PP
                                        (0577) ENDIF
05C4: 20       POP   X                  (0578)     pop X
05C5: 18       POP   A                  (0579)     pop A
05C6: 70 3F    AND   F,0x3F             
05C8: 71 C0    OR    F,0xC0             (0580)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
05CA: 7E       RETI                     (0581)     I2CHW_SERVICE_RETURN ;return and wait for the next interrupt (on data)
                                        (0582) 
                                        (0583) 
                                        (0584) 
                                        (0585) I2C_EvaluateACKIN:
                                        (0586) 
05CB: 49 D7 02 TST   REG[0xD7],0x2      (0587)     tst reg[I2CHW_SCR], I2C_LST_BIT
05CE: B0 06    JNZ   0x05D5             (0588)     jnz I2C_LastByteToMstr  ;NAK recd on TX so this is the end set mode to interrup only on ADDR IN
                                        (0589)     ; got here we were ACK'ed so send another byte
05D0: 50 04    MOV   A,0x4              (0590)     mov A, ( I2C_TX )
                                        (0591)         ;load the bits to set in the I2C_ISR from the stack, The proper bit pattern was previously determined
                                        (0592)         ;and place there based on whether or not the previous transmission was our I2C address.
05D2: 08       PUSH  A                  (0593)         push A
05D3: 8F C8    JMP   0x059C             (0594)         jmp I2C_ObtainReadData
                                        (0595) 
                                        (0596) 
                                        (0597) I2C_LastByteToMstr:
05D5: 2E 01 01 OR    [0x1],0x1          (0598)     or  [I2CHW_RsrcStatus], I2CHW_RD_NOERR                           ;Master NAK'ed us at the end of transaction
05D8: 2E 01 04 OR    [0x1],0x4          (0599)     or  [I2CHW_RsrcStatus], I2CHW_RD_COMPLETE
05DB: 26 01 7F AND   [0x1],0x7F         (0600)     and [I2CHW_RsrcStatus], ~I2CHW_ISR_ACTIVE
                                        (0601) 
                                        (0602) I2C_Terminate:
05DE: 26 01 7F AND   [0x1],0x7F         (0603)     and [I2CHW_RsrcStatus], ~I2CHW_ISR_ACTIVE
                                        (0604) 
                                        (0605) ;
                                        (0606) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (0607) ;
05E1: 62 D7 00 MOV   REG[0xD7],0x0      (0608)     SetI2CHW_SCR 0     ;the default mode to wait for an address
                                        (0609) 
                                        (0610) 
                                        (0611) IF SYSTEM_LARGE_MEMORY_MODEL
05E4: 18       POP   A                  
05E5: 60 D3    MOV   REG[0xD3],A        (0612)     REG_RESTORE IDX_PP
                                        (0613) ENDIF
05E7: 20       POP   X                  (0614)     pop X
05E8: 18       POP   A                  (0615)     pop A
05E9: 70 3F    AND   F,0x3F             
05EB: 71 C0    OR    F,0xC0             (0616)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
05ED: 7E       RETI                     (0617)     I2CHW_SERVICE_RETURN
                                        (0618) 
                                        (0619) STOPTRAP:
                                        (0620)     ;I2C stop detected
                                        (0621) ;@PSoC_UserCode_BODY6@ (Do not change this line.)
                                        (0622) ;---------------------------------------------------
                                        (0623) ; Insert your custom code below this banner
                                        (0624) ; by modifying the block of code here a user could address key operational considerations
                                        (0625) ; at the point that a termination of a write command is detected.
                                        (0626) ; stop interrupt is automatically enabled on write so that the end of the write can be determined.
                                        (0627) ; stop interrupt is not enabled when a read transaction occurs
                                        (0628) ;---------------------------------------------------
                                        (0629) ;
                                        (0630) ; set a flag to indicate END OF TRANSMISSION
                                        (0631) ;
05EE: 2E 01 40 OR    [0x1],0x40         (0632)     or  [I2CHW_RsrcStatus], I2CHW_WR_COMPLETE                        ;only SET by ISR USER must clear.
05F1: 26 01 7F AND   [0x1],0x7F         (0633)     and [I2CHW_RsrcStatus], ~I2CHW_ISR_ACTIVE
                                        (0634) 
                                        (0635) IF I2CHW_POLLED_PROCESS
                                        (0636)     and [I2CHW_Poll_Status], ~I2C_WRITE_STARTED
                                        (0637)     jmp ExitISR
                                        (0638) ELSE
05F4: 41 D6 EF AND   REG[0xD6],0xEF     (0639)     BitClrI2CHW_CFG I2C_STOPIE
05F7: 49 D7 01 TST   REG[0xD7],0x1      (0640)     tst reg[I2CHW_SCR], I2C_BYTE_COMPL
                                        (0641) ;;if BYTE_COMPL is set, there's an excellent chance to lose an ISR.  Because of the way they are
                                        (0642) ;; latched into the INT_MSK.  Therefore clear the applicable bit (STOPIE) and jump directly to the 
                                        (0643) ;; top of this routing since the bus is currently stalled.  Just in case the ISR is properly latched,
                                        (0644) ;; clear the mask bit since it's is serviced manually.
05FA: A0 06    JZ    0x0601             (0645)     jz ExitISR
05FC: 41 DD FE AND   REG[0xDD],0xFE     (0646)     and  reg[INT_CLR3], ~0x01                                ;clear the I2C interrupt
                                        (0647) ENDIF
                                        (0648) 
05FF: 8E FA    JMP   0x04FA             (0649) 	jmp Process_REENTRY
                                        (0650) 
                                        (0651) ExitISR:
                                        (0652) 
                                        (0653) IF SYSTEM_LARGE_MEMORY_MODEL
0601: 18       POP   A                  
0602: 60 D3    MOV   REG[0xD3],A        (0654)     REG_RESTORE IDX_PP
                                        (0655) ENDIF
0604: 20       POP   X                  (0656)     pop X
0605: 18       POP   A                  (0657)     pop A
0606: 70 3F    AND   F,0x3F             
0608: 71 C0    OR    F,0xC0             (0658)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
060A: 7E       RETI                     (0659)     I2CHW_SERVICE_RETURN
(0660) 
(0661) ;---------------------------------------------------
(0662) ; End user boot loader entry Customization
(0663) ; Insert your custom code above this banner
(0664) ;---------------------------------------------------
(0665) ;@PSoC_UserCode_END@ (Do not change this line.)
(0666) 
(0667) ; end of file I2CHWINT.asm
FILE: lib\bpf4_4khz.asm
                                        (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: BPF4_4KHz.asm
                                        (0004) ;;  Version: 1.0, Updated on 2009/10/15 at 17:11:37
                                        (0005) ;;  Generated by PSoC Designer 5.0.1127.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Asm source for 4 Pole Band Pass Filter
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "BPF4_4KHz.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  BPF4_4KHz_Start
                                        (0030) export _BPF4_4KHz_Start
                                        (0031) export  BPF4_4KHz_SetPower
                                        (0032) export _BPF4_4KHz_SetPower
                                        (0033) export  BPF4_4KHz_Stop
                                        (0034) export _BPF4_4KHz_Stop
                                        (0035) 
                                        (0036) export  BPF4_4KHz_SetC1L
                                        (0037) export _BPF4_4KHz_SetC1L
                                        (0038) export  BPF4_4KHz_SetC2L
                                        (0039) export _BPF4_4KHz_SetC2L
                                        (0040) export  BPF4_4KHz_SetC3L
                                        (0041) export _BPF4_4KHz_SetC3L
                                        (0042) export  BPF4_4KHz_SetC4L
                                        (0043) export _BPF4_4KHz_SetC4L
                                        (0044) 
                                        (0045) export  BPF4_4KHz_SetC1H
                                        (0046) export _BPF4_4KHz_SetC1H
                                        (0047) export  BPF4_4KHz_SetC2H
                                        (0048) export _BPF4_4KHz_SetC2H
                                        (0049) export  BPF4_4KHz_SetC3H
                                        (0050) export _BPF4_4KHz_SetC3H
                                        (0051) export  BPF4_4KHz_SetC4H
                                        (0052) export _BPF4_4KHz_SetC4H
                                        (0053) 
                                        (0054) ;-----------------------------------------------
                                        (0055) ;  EQUATES
                                        (0056) ;-----------------------------------------------
                                        (0057) BPF4_4KHz_POWERMASK:    equ 03h                  ; Power field mask for CR3
                                        (0058) BPF4_4KHz_CNUMMASK:     equ 1fh                  ; Mask for A, B & C Caps
                                        (0059) 
                                        (0060) BPF4_4KHz_IfCond:       equ BPF4_4KHz_AMD_MSK & 0x01
                                        (0061) 
                                        (0062) IF (BPF4_4KHz_AMD_VAL)
                                        (0063)  IF (BPF4_4KHz_IfCond)
                                        (0064)   BPF4_4KHz_AMD:        equ BPF4_4KHz_AMD_VAL
                                        (0065)  ELSE
                                        (0066)   BPF4_4KHz_AMD:        equ BPF4_4KHz_AMD_VAL << 4
                                        (0067)  ENDIF
                                        (0068) ENDIF
                                        (0069) 
                                        (0070) AREA UserModules (ROM,REL)
                                        (0071) 
                                        (0072) .SECTION
                                        (0073) ;-----------------------------------------------------------------------------
                                        (0074) ;  FUNCTION NAME: BPF4_4KHz_Start
                                        (0075) ;
                                        (0076) ;  DESCRIPTION: Applies power setting to the module's PSoC blocks
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) ;  ARGUMENTS:    A register contains the power setting (constant)
                                        (0079) ;  RETURNS:      Nothing
                                        (0080) ;  SIDE EFFECTS: 
                                        (0081) ;    The A and X registers may be modified by this or future implementations
                                        (0082) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0083) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0084) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0085) ;    functions.
                                        (0086) 
                                        (0087) 
                                        (0088)  BPF4_4KHz_Start:
                                        (0089) _BPF4_4KHz_Start:
                                        (0090)  BPF4_4KHz_SetPower:
                                        (0091) _BPF4_4KHz_SetPower:
                                        (0092)    RAM_PROLOGUE RAM_USE_CLASS_2
060B: 21 03    AND   A,0x3              (0093)    and   A, BPF4_4KHz_POWERMASK                  ; mask A to protect unchanged bits
060D: 4F       MOV   X,SP               (0094)    mov   X, SP                                   ; define temp store location
060E: 08       PUSH  A                  (0095)    push  A                                       ; put power value in temp store
                                        (0096) 
                                        (0097) IF (BPF4_4KHz_AMD_VAL)
                                        (0098)    M8C_SetBank1
                                        (0099)    mov   A, reg[BPF4_4KHz_AMD_REG]               ; read modulator register
                                        (0100)    and   A, ~BPF4_4KHz_AMD_MSK                   ; clear modulator bittfield in A
                                        (0101)    or    A, BPF4_4KHz_AMD                        ; combine modulator value with balance of register
                                        (0102)    mov   reg[BPF4_4KHz_AMD_REG], A               ; move complete value back to register
                                        (0103)    M8C_SetBank0
                                        (0104) ENDIF
                                        (0105)    
060F: 5D 83    MOV   A,REG[0x83]        (0106)    mov   A, reg[BPF4_4KHz_FLINL_CR3]             ; read power value
0611: 21 FC    AND   A,0xFC             (0107)    and   A, ~BPF4_4KHz_POWERMASK                 ; clear power bits in A
0613: 2B 00    OR    A,[X+0]            (0108)    or    A, [X]                                  ; combine power value with balance of reg.
0615: 60 83    MOV   REG[0x83],A        (0109)    mov   reg[BPF4_4KHz_FLINL_CR3], A             ; move complete value back to register
                                        (0110) 
0617: 5D 93    MOV   A,REG[0x93]        (0111)    mov   A, reg[BPF4_4KHz_FLFBL_CR3]             ; read power value
0619: 21 FC    AND   A,0xFC             (0112)    and   A, ~BPF4_4KHz_POWERMASK                 ; clear power bits in A
061B: 2B 00    OR    A,[X+0]            (0113)    or    A, [X]                                  ; combine power value with balance of reg.
061D: 60 93    MOV   REG[0x93],A        (0114)    mov   reg[BPF4_4KHz_FLFBL_CR3], A             ; move complete value back to register
                                        (0115) 
061F: 5D 97    MOV   A,REG[0x97]        (0116)    mov   A, reg[BPF4_4KHz_FLINH_CR3]             ; read power value
0621: 21 FC    AND   A,0xFC             (0117)    and   A, ~BPF4_4KHz_POWERMASK                 ; clear power bits in A
0623: 2B 00    OR    A,[X+0]            (0118)    or    A, [X]                                  ; combine power value with balance of reg.
0625: 60 97    MOV   REG[0x97],A        (0119)    mov   reg[BPF4_4KHz_FLINH_CR3], A             ; move complete value back to register
                                        (0120) 
0627: 5D 87    MOV   A,REG[0x87]        (0121)    mov   A, reg[BPF4_4KHz_FLFBH_CR3]             ; read power value
0629: 21 FC    AND   A,0xFC             (0122)    and   A, ~BPF4_4KHz_POWERMASK                 ; clear power bits in A
062B: 2B 00    OR    A,[X+0]            (0123)    or    A, [X]                                  ; combine power value with balance of reg.
062D: 60 87    MOV   REG[0x87],A        (0124)    mov   reg[BPF4_4KHz_FLFBH_CR3], A             ; move complete value back to register
                                        (0125) 
062F: 18       POP   A                  (0126)    pop   A
0630: 70 3F    AND   F,0x3F             
0632: 71 C0    OR    F,0xC0             (0127)    RAM_EPILOGUE RAM_USE_CLASS_2
0634: 7F       RET                      (0128)    ret
                                        (0129) .ENDSECTION
                                        (0130) 
                                        (0131) .SECTION
                                        (0132) ;-----------------------------------------------------------------------------
                                        (0133) ;  FUNCTION NAME: BPF4_4KHz_Stop
                                        (0134) ;
                                        (0135) ;  DESCRIPTION: Cuts power to the user module.
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;  ARGUMENTS:     None
                                        (0138) ;  RETURNS:       Nothing
                                        (0139) ;  SIDE EFFECTS: 
                                        (0140) ;    The A and X registers may be modified by this or future implementations
                                        (0141) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0142) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0143) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0144) ;    functions.
                                        (0145) 
                                        (0146)  BPF4_4KHz_Stop:
                                        (0147) _BPF4_4KHz_Stop:
                                        (0148)    RAM_PROLOGUE RAM_USE_CLASS_1
0635: 41 83 FC AND   REG[0x83],0xFC     (0149)    and   reg[BPF4_4KHz_FLINL_CR3], ~BPF4_4KHz_POWERMASK
0638: 41 93 FC AND   REG[0x93],0xFC     (0150)    and   reg[BPF4_4KHz_FLFBL_CR3], ~BPF4_4KHz_POWERMASK
063B: 41 97 FC AND   REG[0x97],0xFC     (0151)    and   reg[BPF4_4KHz_FLINH_CR3], ~BPF4_4KHz_POWERMASK
063E: 41 87 FC AND   REG[0x87],0xFC     (0152)    and   reg[BPF4_4KHz_FLFBH_CR3], ~BPF4_4KHz_POWERMASK
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_1
0641: 7F       RET                      (0154)    ret
                                        (0155) .ENDSECTION
                                        (0156) 
                                        (0157) .SECTION
                                        (0158) ;-----------------------------------------------------------------------------
                                        (0159) ;  FUNCTION NAME: BPF4_4KHz_SetC1L
                                        (0160) ;
                                        (0161) ;  DESCRIPTION:   Alters the filter transfer function by modifying the value
                                        (0162) ;                 of the capacitor C1L
                                        (0163) ;-----------------------------------------------------------------------------
                                        (0164) ;  ARGUMENTS:    The A register contains a non-negative integer less than 32
                                        (0165) ;  RETURNS:
                                        (0166) ;  SIDE EFFECTS: 
                                        (0167) ;    The A and X registers may be modified by this or future implementations
                                        (0168) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0169) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0170) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0171) ;    functions.
                                        (0172) 
                                        (0173)  BPF4_4KHz_SetC1L:
                                        (0174) _BPF4_4KHz_SetC1L:
                                        (0175)    RAM_PROLOGUE RAM_USE_CLASS_2
0642: 21 1F    AND   A,0x1F             (0176)    and   A, BPF4_4KHz_CNUMMASK                   ; mask A to protect unchanged bits
0644: 4F       MOV   X,SP               (0177)    mov   X, SP                                   ; define temp store location
0645: 08       PUSH  A                  (0178)    push  A                                       ; put C1L value in temp store
0646: 5D 80    MOV   A,REG[0x80]        (0179)    mov   A, reg[BPF4_4KHz_FILT_C1L_REG]          ; read current C1L
0648: 21 E0    AND   A,0xE0             (0180)    and   A, ~BPF4_4KHz_CNUMMASK                  ; clear C1L bits in A
064A: 2B 00    OR    A,[X+0]            (0181)    or    A, [X]                                  ; combine C1L value with balance of reg.
064C: 60 80    MOV   REG[0x80],A        (0182)    mov   reg[BPF4_4KHz_FILT_C1L_REG], A          ; move complete value back to register
064E: 18       POP   A                  (0183)    pop   A
064F: 70 3F    AND   F,0x3F             
0651: 71 C0    OR    F,0xC0             (0184)    RAM_EPILOGUE RAM_USE_CLASS_2
0653: 7F       RET                      (0185)    ret
                                        (0186) .ENDSECTION
                                        (0187)    
                                        (0188) .SECTION
                                        (0189) ;-----------------------------------------------------------------------------
                                        (0190) ;  FUNCTION NAME: BPF4_4KHz_SetC2L
                                        (0191) ;
                                        (0192) ;  DESCRIPTION:   Alters the filter transfer function by modifying the value
                                        (0193) ;                 of the capacitor C2L
                                        (0194) ;-----------------------------------------------------------------------------
                                        (0195) ;  ARGUMENTS:    The A register contains a non-negative integer less than 32
                                        (0196) ;  RETURNS:
                                        (0197) ;  SIDE EFFECTS: 
                                        (0198) ;    The A and X registers may be modified by this or future implementations
                                        (0199) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0200) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0201) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0202) ;    functions.
                                        (0203) 
                                        (0204)  BPF4_4KHz_SetC2L:
                                        (0205) _BPF4_4KHz_SetC2L:
                                        (0206)    RAM_PROLOGUE RAM_USE_CLASS_2
0654: 21 1F    AND   A,0x1F             (0207)    and   A, BPF4_4KHz_CNUMMASK                   ; mask A to protect unchanged bits
0656: 4F       MOV   X,SP               (0208)    mov   X, SP                                   ; define temp store location
0657: 08       PUSH  A                  (0209)    push  A                                       ; put C2L value in temp store
0658: 5D 81    MOV   A,REG[0x81]        (0210)    mov   A, reg[BPF4_4KHz_FILT_C2L_REG]          ; read current C2L
065A: 21 E0    AND   A,0xE0             (0211)    and   A, ~BPF4_4KHz_CNUMMASK                  ; clear C2L bits in A
065C: 2B 00    OR    A,[X+0]            (0212)    or    A, [X]                                  ; combine C2L value with balance of reg.
065E: 60 81    MOV   REG[0x81],A        (0213)    mov   reg[BPF4_4KHz_FILT_C2L_REG], A          ; move complete value back to register
0660: 18       POP   A                  (0214)    pop   A
0661: 70 3F    AND   F,0x3F             
0663: 71 C0    OR    F,0xC0             (0215)    RAM_EPILOGUE RAM_USE_CLASS_2
0665: 7F       RET                      (0216)    ret
                                        (0217) .ENDSECTION
                                        (0218)    
                                        (0219) .SECTION
                                        (0220) ;-----------------------------------------------------------------------------
                                        (0221) ;  FUNCTION NAME: BPF4_4KHz_SetC3L
                                        (0222) ;
                                        (0223) ;  DESCRIPTION:   Alters the filter transfer function by modifying the value
                                        (0224) ;                 of the capacitor C3L
                                        (0225) ;-----------------------------------------------------------------------------
                                        (0226) ;  ARGUMENTS:    The A register contains a non-negative integer less than 32
                                        (0227) ;  RETURNS:
                                        (0228) ;  SIDE EFFECTS: 
                                        (0229) ;    The A and X registers may be modified by this or future implementations
                                        (0230) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0231) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0232) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0233) ;    functions.
                                        (0234)    
                                        (0235)  BPF4_4KHz_SetC3L:
                                        (0236) _BPF4_4KHz_SetC3L:
                                        (0237)    RAM_PROLOGUE RAM_USE_CLASS_2
0666: 21 1F    AND   A,0x1F             (0238)    and   A, BPF4_4KHz_CNUMMASK                   ; mask A to protect unchanged bits
0668: 4F       MOV   X,SP               (0239)    mov   X, SP                                   ; define temp store location
0669: 08       PUSH  A                  (0240)    push  A                                       ; put C3L value in temp store
066A: 5D 90    MOV   A,REG[0x90]        (0241)    mov   A, reg[BPF4_4KHz_FILT_C3L_REG]          ; read current C3L
066C: 21 E0    AND   A,0xE0             (0242)    and   A, ~BPF4_4KHz_CNUMMASK                  ; clear C3L bits in A
066E: 2B 00    OR    A,[X+0]            (0243)    or    A, [X]                                  ; combine C3L value with balance of reg.
0670: 60 90    MOV   REG[0x90],A        (0244)    mov   reg[BPF4_4KHz_FILT_C3L_REG], A          ; move complete value back to register
0672: 18       POP   A                  (0245)    pop   A
0673: 70 3F    AND   F,0x3F             
0675: 71 C0    OR    F,0xC0             (0246)    RAM_EPILOGUE RAM_USE_CLASS_2
0677: 7F       RET                      (0247)    ret
                                        (0248) .ENDSECTION
                                        (0249)    
                                        (0250) .SECTION
                                        (0251) ;-----------------------------------------------------------------------------
                                        (0252) ;  FUNCTION NAME: BPF4_4KHz_SetC4L
                                        (0253) ;
                                        (0254) ;  DESCRIPTION:   Alters the filter transfer function by modifying the value
                                        (0255) ;                 of the capacitor C4L
                                        (0256) ;-----------------------------------------------------------------------------
                                        (0257) ;  ARGUMENTS:    The A register contains a non-negative integer less than 32
                                        (0258) ;  RETURNS:
                                        (0259) ;  SIDE EFFECTS: 
                                        (0260) ;    The A and X registers may be modified by this or future implementations
                                        (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0264) ;    functions. 
                                        (0265) 
                                        (0266)  BPF4_4KHz_SetC4L:
                                        (0267) _BPF4_4KHz_SetC4L:
                                        (0268)    RAM_PROLOGUE RAM_USE_CLASS_2
0678: 21 1F    AND   A,0x1F             (0269)    and   A, BPF4_4KHz_CNUMMASK                   ; mask A to protect unchanged bits
067A: 4F       MOV   X,SP               (0270)    mov   X, SP                                   ; define temp store location
067B: 08       PUSH  A                  (0271)    push  A                                       ; put C4L value in temp store
067C: 5D 92    MOV   A,REG[0x92]        (0272)    mov   A, reg[BPF4_4KHz_FILT_C4L_REG]          ; read current C4L
067E: 21 E0    AND   A,0xE0             (0273)    and   A, ~BPF4_4KHz_CNUMMASK                  ; clear C4L bits in A
0680: 2B 00    OR    A,[X+0]            (0274)    or    A, [X]                                  ; combine C4L value with balance of reg.
0682: 60 92    MOV   REG[0x92],A        (0275)    mov   reg[BPF4_4KHz_FILT_C4L_REG], A          ; move complete value back to register
0684: 18       POP   A                  (0276)    pop   A
0685: 70 3F    AND   F,0x3F             
0687: 71 C0    OR    F,0xC0             (0277)    RAM_EPILOGUE RAM_USE_CLASS_2
0689: 7F       RET                      (0278)    ret
                                        (0279) .ENDSECTION 
                                        (0280)   
                                        (0281) .SECTION
                                        (0282) ;-----------------------------------------------------------------------------
                                        (0283) ;  FUNCTION NAME: BPF4_4KHz_SetC1H
                                        (0284) ;
                                        (0285) ;  DESCRIPTION:   Alters the filter transfer function by modifying the value
                                        (0286) ;                 of the capacitor C1H
                                        (0287) ;-----------------------------------------------------------------------------
                                        (0288) ;  ARGUMENTS:    The A register contains a non-negative integer less than 32
                                        (0289) ;  RETURNS:
                                        (0290) ;  SIDE EFFECTS: 
                                        (0291) ;    The A and X registers may be modified by this or future implementations
                                        (0292) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0293) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0294) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0295) ;    functions.
                                        (0296) 
                                        (0297)  BPF4_4KHz_SetC1H:
                                        (0298) _BPF4_4KHz_SetC1H:
                                        (0299)    RAM_PROLOGUE RAM_USE_CLASS_2
068A: 21 1F    AND   A,0x1F             (0300)    and   A, BPF4_4KHz_CNUMMASK                   ; mask A to protect unchanged bits
068C: 4F       MOV   X,SP               (0301)    mov   X, SP                                   ; define temp store location
068D: 08       PUSH  A                  (0302)    push  A                                       ; put C1H value in temp store
068E: 5D 94    MOV   A,REG[0x94]        (0303)    mov   A, reg[BPF4_4KHz_FILT_C1H_REG]          ; read current C1H
0690: 21 E0    AND   A,0xE0             (0304)    and   A, ~BPF4_4KHz_CNUMMASK                  ; clear C1H bits in A
0692: 2B 00    OR    A,[X+0]            (0305)    or    A, [X]                                  ; combine C1H value with balance of reg.
0694: 60 94    MOV   REG[0x94],A        (0306)    mov   reg[BPF4_4KHz_FILT_C1H_REG], A          ; move complete value back to register
0696: 18       POP   A                  (0307)    pop   A
0697: 70 3F    AND   F,0x3F             
0699: 71 C0    OR    F,0xC0             (0308)    RAM_EPILOGUE RAM_USE_CLASS_2
069B: 7F       RET                      (0309)    ret
                                        (0310) .ENDSECTION
                                        (0311)    
                                        (0312) .SECTION
                                        (0313) ;-----------------------------------------------------------------------------
                                        (0314) ;  FUNCTION NAME: BPF4_4KHz_SetC2H
                                        (0315) ;
                                        (0316) ;  DESCRIPTION:   Alters the filter transfer function by modifying the value
                                        (0317) ;                 of the capacitor C2H
                                        (0318) ;-----------------------------------------------------------------------------
                                        (0319) ;  ARGUMENTS:    The A register contains a non-negative integer less than 32
                                        (0320) ;  RETURNS:
                                        (0321) ;  SIDE EFFECTS: 
                                        (0322) ;    The A and X registers may be modified by this or future implementations
                                        (0323) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0324) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0325) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0326) ;    functions.
                                        (0327)    
                                        (0328)  BPF4_4KHz_SetC2H:
                                        (0329) _BPF4_4KHz_SetC2H:
                                        (0330)    RAM_PROLOGUE RAM_USE_CLASS_2
069C: 21 1F    AND   A,0x1F             (0331)    and   A, BPF4_4KHz_CNUMMASK                   ; mask A to protect unchanged bits
069E: 4F       MOV   X,SP               (0332)    mov   X, SP                                   ; define temp store location
069F: 08       PUSH  A                  (0333)    push  A                                       ; put C2H value in temp store
06A0: 5D 95    MOV   A,REG[0x95]        (0334)    mov   A, reg[BPF4_4KHz_FILT_C2H_REG]          ; read current C2H
06A2: 21 E0    AND   A,0xE0             (0335)    and   A, ~BPF4_4KHz_CNUMMASK                  ; clear C2H bits in A
06A4: 2B 00    OR    A,[X+0]            (0336)    or    A, [X]                                  ; combine C2H value with balance of reg.
06A6: 60 95    MOV   REG[0x95],A        (0337)    mov   reg[BPF4_4KHz_FILT_C2H_REG], A          ; move complete value back to register
06A8: 18       POP   A                  (0338)    pop   A
06A9: 70 3F    AND   F,0x3F             
06AB: 71 C0    OR    F,0xC0             (0339)    RAM_EPILOGUE RAM_USE_CLASS_2
06AD: 7F       RET                      (0340)    ret
                                        (0341) .ENDSECTION
                                        (0342)    
                                        (0343) .SECTION
                                        (0344) ;-----------------------------------------------------------------------------
                                        (0345) ;  FUNCTION NAME: BPF4_4KHz_SetC3H
                                        (0346) ;
                                        (0347) ;  DESCRIPTION:   Alters the filter transfer function by modifying the value
                                        (0348) ;                 of the capacitor C3H
                                        (0349) ;-----------------------------------------------------------------------------
                                        (0350) ;  ARGUMENTS:    The A register contains a non-negative integer less than 32
                                        (0351) ;  RETURNS:
                                        (0352) ;  SIDE EFFECTS: 
                                        (0353) ;    The A and X registers may be modified by this or future implementations
                                        (0354) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0355) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0356) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0357) ;    functions.
                                        (0358)    
                                        (0359)  BPF4_4KHz_SetC3H:
                                        (0360) _BPF4_4KHz_SetC3H:
                                        (0361)    RAM_PROLOGUE RAM_USE_CLASS_2
06AE: 21 1F    AND   A,0x1F             (0362)    and   A, BPF4_4KHz_CNUMMASK                   ; mask A to protect unchanged bits
06B0: 4F       MOV   X,SP               (0363)    mov   X, SP                                   ; define temp store location
06B1: 08       PUSH  A                  (0364)    push  A                                       ; put C3H value in temp store
06B2: 5D 84    MOV   A,REG[0x84]        (0365)    mov   A, reg[BPF4_4KHz_FILT_C3H_REG]          ; read current C3H
06B4: 21 E0    AND   A,0xE0             (0366)    and   A, ~BPF4_4KHz_CNUMMASK                  ; clear C3H bits in A
06B6: 2B 00    OR    A,[X+0]            (0367)    or    A, [X]                                  ; combine C3H value with balance of reg.
06B8: 60 84    MOV   REG[0x84],A        (0368)    mov   reg[BPF4_4KHz_FILT_C3H_REG], A          ; move complete value back to register
06BA: 18       POP   A                  (0369)    pop   A
06BB: 70 3F    AND   F,0x3F             
06BD: 71 C0    OR    F,0xC0             (0370)    RAM_EPILOGUE RAM_USE_CLASS_2
06BF: 7F       RET                      (0371)    ret
                                        (0372) .ENDSECTION
                                        (0373)    
                                        (0374) .SECTION
                                        (0375) ;-----------------------------------------------------------------------------
                                        (0376) ;  FUNCTION NAME: BPF4_4KHz_SetC4H
                                        (0377) ;
                                        (0378) ;  DESCRIPTION:   Alters the filter transfer function by modifying the value
                                        (0379) ;                 of the capacitor C4H
                                        (0380) ;-----------------------------------------------------------------------------
                                        (0381) ;  ARGUMENTS:    The A register contains a non-negative integer less than 32
                                        (0382) ;  RETURNS:
                                        (0383) ;  SIDE EFFECTS: 
                                        (0384) ;    The A and X registers may be modified by this or future implementations
                                        (0385) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0386) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0387) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0388) ;    functions.
                                        (0389)    
                                        (0390)  BPF4_4KHz_SetC4H:
                                        (0391) _BPF4_4KHz_SetC4H:
                                        (0392)    RAM_PROLOGUE RAM_USE_CLASS_2
06C0: 21 1F    AND   A,0x1F             (0393)    and   A, BPF4_4KHz_CNUMMASK                   ; mask A to protect unchanged bits
06C2: 4F       MOV   X,SP               (0394)    mov   X, SP                                   ; define temp store location
06C3: 08       PUSH  A                  (0395)    push  A                                       ; put C4H value in temp store
06C4: 5D 86    MOV   A,REG[0x86]        (0396)    mov   A, reg[BPF4_4KHz_FILT_C4H_REG]          ; read current C4H
06C6: 21 E0    AND   A,0xE0             (0397)    and   A, ~BPF4_4KHz_CNUMMASK                  ; clear C4H bits in A
06C8: 2B 00    OR    A,[X+0]            (0398)    or    A, [X]                                  ; combine C4H value with balance of reg.
06CA: 60 86    MOV   REG[0x86],A        (0399)    mov   reg[BPF4_4KHz_FILT_C4H_REG], A          ; move complete value back to register
06CC: 18       POP   A                  (0400)    pop   A
06CD: 70 3F    AND   F,0x3F             
06CF: 71 C0    OR    F,0xC0             (0401)    RAM_EPILOGUE RAM_USE_CLASS_2
06D1: 7F       RET                      (0402)    ret
(0403) .ENDSECTION
(0404) 
(0405) ; End of File BPF4_4KHz.asm
FILE: lib\amux4_mic.asm
                                        (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   AMUX4_mic.asm
                                        (0004) ;;  Version: 1.4, Updated on 2009/10/15 at 17:11:37
                                        (0005) ;;  Generated by PSoC Designer 5.0.1127.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: AMux4 User Module software implementation file devices.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) 
                                        (0023) include "AMUX4_mic.inc"
                                        (0024) include "m8c.inc"
                                        (0025) include "memory.inc"
                                        (0026) 
                                        (0027) ;-----------------------------------------------
                                        (0028) ;  Global Symbols
                                        (0029) ;-----------------------------------------------
                                        (0030) export  AMUX4_mic_InputSelect
                                        (0031) export _AMUX4_mic_InputSelect
                                        (0032) 
                                        (0033) export  AMUX4_mic_Start
                                        (0034) export _AMUX4_mic_Start
                                        (0035) 
                                        (0036) export  AMUX4_mic_Stop
                                        (0037) export _AMUX4_mic_Stop
                                        (0038) 
                                        (0039) ;-----------------------------------------------
                                        (0040) ;  EQUATES
                                        (0041) ;-----------------------------------------------
                                        (0042) 
                                        (0043) MUXMASK:                     equ 03h
                                        (0044) 
                                        (0045) AREA UserModules (ROM, REL)
                                        (0046) .SECTION
                                        (0047) ;-----------------------------------------------------------------------------
                                        (0048) ;  FUNCTION NAME: AMUX4_mic_InputSelect
                                        (0049) ;
                                        (0050) ;  DESCRIPTION:
                                        (0051) ;    Place the signal from one of four port0 pins on the Analog Column bus.
                                        (0052) ;
                                        (0053) ;-----------------------------------------------------------------------------
                                        (0054) ;
                                        (0055) ;  ARGUMENTS:
                                        (0056) ;    A contains the mux input control value
                                        (0057) ;
                                        (0058) ;      Input           Code
                                        (0059) ;   Mux input 0,1       00h
                                        (0060) ;   Mux input 2,3       01h
                                        (0061) ;   Mux input 4,5       02h
                                        (0062) ;   Mux input 6,7       03h
                                        (0063) ;
                                        (0064) ;  RETURNS: none
                                        (0065) ;
                                        (0066) ;  SIDE EFFECTS:
                                        (0067) ;    The A and X registers may be modified by this or future implementations
                                        (0068) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0069) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0070) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0071) ;    functions.
                                        (0072) ;
                                        (0073)  AMUX4_mic_InputSelect:
                                        (0074) _AMUX4_mic_InputSelect:
                                        (0075)     RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0076) 	
                                        (0077) IF (AMUX4_mic_COL_COUNT)
                                        (0078) 	M8C_SetBank1      ; ACE_AMX_IN is in Bank 1
                                        (0079) ENDIF
                                        (0080) 	
06D2: 21 03    AND   A,0x3              (0081)     and  A, MUXMASK                    ; Mask off only valid port0 input bits
06D4: 57 00    MOV   X,0x0              (0082)     mov  X,AMUX4_mic_MUX_COL
                                        (0083) .AMUX4_ShiftIt:                         ; Shift value to correct bit position for Mux
06D6: 79       DEC   X                  (0084)     dec  X
06D7: C0 05    JC    0x06DD             (0085)     jc   .AMUX4_SetIt
06D9: 64       ASL   A                  (0086)     asl  A
06DA: 64       ASL   A                  (0087)     asl  A
06DB: 8F FA    JMP   0x06D6             (0088)     jmp  .AMUX4_ShiftIt                ; Loop until bits shifted to 2 LSBs
                                        (0089) 
                                        (0090) .AMUX4_SetIt:
06DD: 4F       MOV   X,SP               (0091)     mov  X,SP                          ; Get current stack location
06DE: 08       PUSH  A                  (0092)     push A                             ; Save a to OR it to AMX_IN later	
                                        (0093) IF (AMUX4_mic_COL_COUNT)
                                        (0094) 	mov  A, reg[ACE_AMX_IN]                 ; Get current value of mux control register    
                                        (0095) ELSE
06DF: 5D 60    MOV   A,REG[0x60]        (0096) 	mov  A, reg[AMX_IN]                 ; Get current value of mux control register
                                        (0097) ENDIF
06E1: 21 FC    AND   A,0xFC             (0098)     and  A,~AMUX4_mic_MUX_MASK         ; Mask off the bits for this Mux
06E3: 2B 00    OR    A,[X+0]            (0099)     or   A,[X]                         ; OR in the mux control bits
                                        (0100) IF (AMUX4_mic_COL_COUNT)
                                        (0101) 	mov  reg[ACE_AMX_IN], A                 ; Get current value of mux control register    
                                        (0102) ELSE
06E5: 60 60    MOV   REG[0x60],A        (0103) 	mov  reg[AMX_IN], A                 ; Write out mux value to mux control register
                                        (0104) ENDIF	
06E7: 18       POP   A                  (0105)     pop  A                             ; Restore the stack
                                        (0106) 	
                                        (0107) IF (AMUX4_mic_COL_COUNT)
                                        (0108) 	M8C_SetBank0
                                        (0109) ENDIF
06E8: 70 3F    AND   F,0x3F             
06EA: 71 C0    OR    F,0xC0             (0110)     RAM_EPILOGUE RAM_USE_CLASS_2
06EC: 7F       RET                      (0111)     ret
                                        (0112) .ENDSECTION
                                        (0113) 
                                        (0114) .SECTION
                                        (0115) ;-----------------------------------------------------------------------------
                                        (0116) ;  FUNCTION NAME: AMUX4_mic_Start
                                        (0117) ;
                                        (0118) ;  DESCRIPTION:
                                        (0119) ;   This function does nothing at this time.  It is only here for
                                        (0120) ;   future compatibility.
                                        (0121) ;
                                        (0122) ;-----------------------------------------------------------------------------
                                        (0123) ;
                                        (0124) ;  ARGUMENTS: none
                                        (0125) ;
                                        (0126) ;  RETURNS: none
                                        (0127) ;
                                        (0128) ;  SIDE EFFECTS:
                                        (0129) ;    The A and X registers may be modified by this or future implementations
                                        (0130) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0131) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0132) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0133) ;    functions.
                                        (0134) ;
                                        (0135)  AMUX4_mic_Start:
                                        (0136) _AMUX4_mic_Start:
                                        (0137)     RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0138)     RAM_EPILOGUE RAM_USE_CLASS_1
06ED: 7F       RET                      (0139)     ret
                                        (0140) .ENDSECTION
                                        (0141) 
                                        (0142) .SECTION
                                        (0143) ;-----------------------------------------------------------------------------
                                        (0144) ;  FUNCTION NAME: AMUX4_mic_Stop
                                        (0145) ;
                                        (0146) ;  DESCRIPTION:
                                        (0147) ;   This function does nothing at this time.  It is only here for
                                        (0148) ;   future compatibility.
                                        (0149) ;
                                        (0150) ;-----------------------------------------------------------------------------
                                        (0151) ;
                                        (0152) ;  ARGUMENTS:  none
                                        (0153) ;
                                        (0154) ;  RETURNS: none
                                        (0155) ;
                                        (0156) ;  SIDE EFFECTS:
                                        (0157) ;    The A and X registers may be modified by this or future implementations
                                        (0158) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0159) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0160) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0161) ;    functions.
                                        (0162) ;
                                        (0163)  AMUX4_mic_Stop:
                                        (0164) _AMUX4_mic_Stop:
                                        (0165)     RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0166)     RAM_EPILOGUE RAM_USE_CLASS_1
06EE: 7F       RET                      (0167)     ret
(0168) .ENDSECTION
(0169) ; End of File AMUX4_mic.asm
FILE: lib\adcincvr_potint.asm
                                        (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   ADCINCVR_potINT.asm
                                        (0004) ;;  Version: 3.1, Updated on 2009/10/15 at 17:11:37
                                        (0005) ;;  Generated by PSoC Designer 5.0.1127.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: ADCINCVR Interrupt Service Routines
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "ADCINCVR_pot.inc"
                                        (0016) 
                                        (0017) ;-----------------------------------------------
                                        (0018) ;  Global Symbols
                                        (0019) ;-----------------------------------------------
                                        (0020) export _ADCINCVR_pot_CNT_ISR
                                        (0021) export _ADCINCVR_pot_PWM16_ISR
                                        (0022) export  ADCINCVR_pot_cCounterU
                                        (0023) export _ADCINCVR_pot_iResult
                                        (0024) export  ADCINCVR_pot_iResult
                                        (0025) export _ADCINCVR_pot_bfStatus
                                        (0026) export  ADCINCVR_pot_bfStatus
                                        (0027) export  ADCINCVR_pot_bSampC
                                        (0028) 
                                        (0029) ;-----------------------------------------------
                                        (0030) ; Variable Allocation
                                        (0031) ;-----------------------------------------------
                                        (0032) AREA InterruptRAM(RAM, REL, CON)
                                        (0033) 
                                        (0034)  ADCINCVR_pot_cCounterU:     BLK   1  ;The Upper byte of the Counter
                                        (0035) _ADCINCVR_pot_iResult:
                                        (0036)  ADCINCVR_pot_iResult:       BLK   2  ;A/D value
                                        (0037) _ADCINCVR_pot_bfStatus:
                                        (0038)  ADCINCVR_pot_bfStatus:      BLK   1  ;Data Valid Flag
                                        (0039)  ADCINCVR_pot_bSampC:        BLK   1  ;# of times to run A/D
                                        (0040) 
                                        (0041) 
                                        (0042) ;-----------------------------------------------
                                        (0043) ;  EQUATES and TABLES
                                        (0044) ;-----------------------------------------------
                                        (0045) LowByte:   equ 1
                                        (0046) HighByte:  equ 0
                                        (0047) 
                                        (0048) 
                                        (0049) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0050) ;---------------------------------------------------
                                        (0051) ; Insert your custom declarations below this banner
                                        (0052) ;---------------------------------------------------
                                        (0053) 
                                        (0054) ;------------------------
                                        (0055) ; Includes
                                        (0056) ;------------------------
                                        (0057) 
                                        (0058) 	
                                        (0059) ;------------------------
                                        (0060) ;  Constant Definitions
                                        (0061) ;------------------------
                                        (0062) 
                                        (0063) 
                                        (0064) ;------------------------
                                        (0065) ; Variable Allocation
                                        (0066) ;------------------------
                                        (0067) 
                                        (0068) 
                                        (0069) ;---------------------------------------------------
                                        (0070) ; Insert your custom declarations above this banner
                                        (0071) ;---------------------------------------------------
                                        (0072) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0073) 
                                        (0074) AREA UserModules (ROM, REL)
                                        (0075) 
                                        (0076) .LITERAL
                                        (0077) ADCINCVR_potMaxNegX4Table:
                                        (0078) ; Bits  7    8    9   10   11   12   13
                                        (0079)    DB  FFh, FEh, FCh, F8h, F0h, E0h, C0h
                                        (0080) 
                                        (0081) ADCINCVR_potMaxPosX4Table:
                                        (0082) IF (ADCINCVR_pot_DATA_FORMAT)
                                        (0083) ; Bits (signed)    7    8    9   10   11   12   13
                                        (0084)               DB  01h, 02h, 04h, 08h, 10h, 20h, 40h
                                        (0085) ELSE
                                        (0086) ; Bits (unsigned)  7    8    9   10   11   12   13
                                        (0087)               DB  02h, 04h, 08h, 10h, 20h, 40h, 80h
                                        (0088) 
                                        (0089)  ENDIF
                                        (0090) .ENDLITERAL
                                        (0091) 
                                        (0092) ;-----------------------------------------------------------------------------
                                        (0093) ;  FUNCTION NAME: _ADCINCVR_pot_CNT_ISR (Counter8 Interrupt)
                                        (0094) ;
                                        (0095) ;
                                        (0096) ;  DESCRIPTION:
                                        (0097) ;     Increment the upper (software) half on the counter whenever the
                                        (0098) ;     lower (hardware) half of the counter underflows.  This counter
                                        (0099) ;     should start out at the most negative value (0xFF).
                                        (0100) ;
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;
                                        (0103) _ADCINCVR_pot_CNT_ISR:

06FD: 76 08    INC   [0x8]              (0104)    inc [ADCINCVR_pot_cCounterU]
                                        (0105)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (0106)    ;---------------------------------------------------
                                        (0107)    ; Insert your custom code below this banner
                                        (0108)    ;---------------------------------------------------
                                        (0109)    ;   NOTE: interrupt service routines must preserve
                                        (0110)    ;   the values of the A and X CPU registers.
                                        (0111) 
                                        (0112)    ;---------------------------------------------------
                                        (0113)    ; Insert your custom code above this banner
                                        (0114)    ;---------------------------------------------------
                                        (0115)    ;@PSoC_UserCode_END@ (Do not change this line.)
06FF: 7E       RETI                     (0116)    reti
                                        (0117) 
                                        (0118) 
                                        (0119) ;-----------------------------------------------------------------------------
                                        (0120) ;  FUNCTION NAME: _ADCINCVR_pot_PWM16_ISR  (PWM16 Interrupt)
                                        (0121) ;
                                        (0122) ;  DESCRIPTION:
                                        (0123) ;     This ISR is called when the ADC has completed and integrate cycle.
                                        (0124) ;     The ADC value is calculated and stored in a global location before
                                        (0125) ;     the end of the ISR.
                                        (0126) ;
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;
                                        (0129) _ADCINCVR_pot_PWM16_ISR:
0700: 41 2F FE AND   REG[0x2F],0xFE     (0130)    and   reg[ADCINCVR_pot_bCounter_CR0], ~ADCINCVR_pot_fDBLK_ENABLE  ; Disable Counter
                                        (0131) IF ADCINCVR_pot_NoAZ
0703: 43 9A 20 OR    REG[0x9A],0x20     (0132)    or    reg[ADCINCVR_pot_bfAtoDcr2], ADCINCVR_pot_fAutoZero      ; Put Integrator in AutoZero
                                        (0133) ENDIF
0706: 43 9B 10 OR    REG[0x9B],0x10     (0134)    or   reg[ADCINCVR_pot_bfAtoDcr3],ADCINCVR_pot_fFSW0        ; Put Integrator in reset
                                        (0135) 
                                        (0136)                                                            ; Enable interrupts for a short period of time just in case.
                                        (0137)                                                            ; Make sure we didn't have a counter interrupt ready to fire
0709: 71 01    OR    F,0x1              (0138)    M8C_EnableGInt
070B: 40       NOP                      (0139)    nop                                                     ; Wait a couple cycles
070C: 70 FE    AND   F,0xFE             (0140)    M8C_DisableGInt                                         ; Disable interrupt, read to complete processing
070E: 08       PUSH  A                  (0141)    push  A                                                 ; Save the Accumulator
070F: 5D 2C    MOV   A,REG[0x2C]        (0142)    mov   A,reg[ADCINCVR_pot_bCount]                        ; Read counter value  (Bogus read puts value in Period register)
0711: 5D 2E    MOV   A,REG[0x2E]        (0143)    mov   A,reg[ADCINCVR_pot_bCompare]                      ; Read counter value
0713: 78       DEC   A                  (0144)    dec   A                                                 ; Decrement by one to make sure we didn't miss a count
0714: 73       CPL   A                  (0145)    cpl   A                                                 ; Invert the value
0715: D0 03    JNC   0x0719             (0146)    jnc   ADCINCVR_pot_INT_CALCV                            ; if carry, then inc MSB as well
0717: 76 08    INC   [0x8]              (0147)    inc   [ADCINCVR_pot_cCounterU]
                                        (0148) ADCINCVR_pot_INT_CALCV:
0719: 53 0A    MOV   [0xA],A            (0149)    mov   [(ADCINCVR_pot_iResult + LowByte)], A             ; Store LSB value
071B: 51 08    MOV   A,[0x8]            (0150)    mov   A, [ADCINCVR_pot_cCounterU]                       ; Store MSB from temp counter
071D: 53 09    MOV   [0x9],A            (0151)    mov   [(ADCINCVR_pot_iResult + HighByte)], A
                                        (0152)                                                            ; The new value has been stored,
                                        (0153)                                                            ; so get counters ready for next reading first.
071F: 62 2D FF MOV   REG[0x2D],0xFF     (0154)    mov   reg[ADCINCVR_pot_bPeriod], ffh                    ; Initialize counter to FF - Set to overflow after 256 counts
0722: 43 2F 01 OR    REG[0x2F],0x1      (0155)    or    reg[ADCINCVR_pot_bCounter_CR0],ADCINCVR_pot_fDBLK_ENABLE  ; Enable Counter
                                        (0156) 
                                        (0157) IF (ADCINCVR_pot_DATA_FORMAT)                              ; Only check for Negative numbers if SIGNED result
0725: 51 0B    MOV   A,[0xB]            (0158)    mov   A, [ADCINCVR_pot_bfStatus]                        ; Get Status with Resolution
0727: 21 0F    AND   A,0xF              (0159)    and   A, ADCINCVR_pot_bRES_MASK                         ; Mask of resolution
0729: FF C4    INDEX 0x06EF             (0160)    index ADCINCVR_potMaxNegX4Table                         ; Get Maximum negative value from table
072B: 53 08    MOV   [0x8],A            (0161)    mov   [ADCINCVR_pot_cCounterU], A                       ; Place result back into MSB of counter
                                        (0162) ELSE
                                        (0163)    mov   [ADCINCVR_pot_cCounterU], 00h                     ; Place result back into MSB of counter
                                        (0164) ENDIF
                                        (0165) 
                                        (0166)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                        (0167)    ;---------------------------------------------------
                                        (0168)    ; If the input is muxed with multiple inputs
                                        (0169)    ; this is a good place to change inputs.
                                        (0170)    ; Insert your custom code below this banner
                                        (0171)    ;---------------------------------------------------
                                        (0172)    ;   NOTE: interrupt service routines must preserve
                                        (0173)    ;   the values of the A and X CPU registers. At this
                                        (0174)    ;   point A is already preserved and will be restored;
                                        (0175)    ;   however, if you use X, you must take care of it
                                        (0176)    ;   here!
                                        (0177) 
                                        (0178)    ;---------------------------------------------------
                                        (0179)    ; Insert your custom code above this banner
                                        (0180)    ;---------------------------------------------------
                                        (0181)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0182) 
072D: 41 9B EF AND   REG[0x9B],0xEF     (0183)    and   reg[ADCINCVR_pot_bfAtoDcr3],~ADCINCVR_pot_fFSW0   ; Take Integrator out of reset
                                        (0184) IF ADCINCVR_pot_NoAZ
0730: 41 9A DF AND   REG[0x9A],0xDF     (0185)    and   reg[ADCINCVR_pot_bfAtoDcr2],~ADCINCVR_pot_fAutoZero  ; Take Integrator out of AutoZero
                                        (0186) ENDIF
                                        (0187) 
                                        (0188)    ;****************************************************************************
                                        (0189)    ;M8C_EnableGInt            ; May want to re-enable interrupts at this point,
                                        (0190)    ;                          ; if stack space isn't at a premium.
                                        (0191)    ; NOTE:  this will make system more responsive but, will increase the
                                        (0192)    ;        overall processing time of the A/D calctime.  If an interrupt is
                                        (0193)    ;        taken, it must return within the specified CalcTime to guarantee
                                        (0194)    ;        successful acquisition of the next byte.
                                        (0195)    ;****************************************************************************
                                        (0196) IF (ADCINCVR_pot_DATA_FORMAT)                    ; Only check for Negative numbers if SIGNED result
                                        (0197) 
                                        (0198)                                                  ; Negative Overflow Check
0733: 47 09 80 TST   [0x9],0x80         (0199)    tst   [(ADCINCVR_pot_iResult + HighByte)],80h
0736: B0 17    JNZ   0x074E             (0200)    jnz   ADCINCVR_pot_NOT_POVFL2
                                        (0201) 
                                        (0202) ENDIF
                                        (0203)                                                  ; Postive Overflow Check
                                        (0204)                                                  ; Get MSB of Max Positive value x4 + 1
0738: 51 0B    MOV   A,[0xB]            (0205)    mov   A,[ADCINCVR_pot_bfStatus]               ; Get Status with Resolution
073A: 21 0F    AND   A,0xF              (0206)    and   A,ADCINCVR_pot_bRES_MASK                ; Mask of resolution normalized to 0
073C: FF B8    INDEX 0x06F6             (0207)    index ADCINCVR_potMaxPosX4Table               ; Get Maximum positive value x4 + 1 from table
073E: 08       PUSH  A                  (0208)    push  A
073F: 22 09    AND   A,[0x9]            (0209)    and   A, [(ADCINCVR_pot_iResult + HighByte)]
0741: A0 0B    JZ    0x074D             (0210)    jz    ADCINCVR_pot_NOT_POVFL
                                        (0211)                                                  ; Positive overflow, fix it - set to Max Positive + 1
0743: 18       POP   A                  (0212)    pop   A
0744: 11 01    SUB   A,0x1              (0213)    sub   A, 01h
                                        (0214) 
                                        (0215)                                                  ; Force most positive * 4 into result
0746: 53 09    MOV   [0x9],A            (0216)    mov   [(ADCINCVR_pot_iResult + HighByte)], A
0748: 55 0A FF MOV   [0xA],0xFF         (0217)    mov   [(ADCINCVR_pot_iResult + LowByte)], ffh
074B: 80 02    JMP   0x074E             (0218)    jmp   ADCINCVR_pot_NOT_POVFL2
                                        (0219) ADCINCVR_pot_NOT_POVFL:
074D: 18       POP   A                  (0220)    pop   A
                                        (0221) 
                                        (0222) ADCINCVR_pot_NOT_POVFL2:
074E: 68 09    ASR   [0x9]              (0223)    asr   [(ADCINCVR_pot_iResult + HighByte)]     ; Shift MSB and LSB right twice to divide by four
0750: 6E 0A    RRC   [0xA]              (0224)    rrc   [(ADCINCVR_pot_iResult + LowByte)]      ; Remember digital clock 4 times analog clock
0752: 68 09    ASR   [0x9]              (0225)    asr   [(ADCINCVR_pot_iResult + HighByte)]
0754: 6E 0A    RRC   [0xA]              (0226)    rrc   [(ADCINCVR_pot_iResult + LowByte)]
                                        (0227) 
                                        (0228)    ;@PSoC_UserCode_BODY_3@ (Do not change this line.)
                                        (0229)    ;---------------------------------------------------
                                        (0230)    ; Data is ready at this point.
                                        (0231)    ; If processing Data at Interrupt level - add
                                        (0232)    ; User Code to handle the data below this banner
                                        (0233)    ;---------------------------------------------------
                                        (0234)    ;   NOTE: interrupt service routines must preserve
                                        (0235)    ;   the values of the A and X CPU registers. At this
                                        (0236)    ;   point A is already preserved and will be restored;
                                        (0237)    ;   however, if you use X, you must take care of it
                                        (0238)    ;   here!
                                        (0239) 
                                        (0240)    ;---------------------------------------------------
                                        (0241)    ; Insert your custom code above this banner
                                        (0242)    ;---------------------------------------------------
                                        (0243)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0244) 
0756: 18       POP   A                  (0245)    pop   A                                       ; Restore A, not used any more
                                        (0246) 
0757: 2E 0B 10 OR    [0xB],0x10         (0247)    or    [ADCINCVR_pot_bfStatus],ADCINCVR_pot_fDATA_READY  ; Set Data ready bit
                                        (0248) 
075A: 47 0C FF TST   [0xC],0xFF         (0249)    tst   [ADCINCVR_pot_bSampC], ffh              ; If sample_counter == 0 -->> continuous data collection
075D: A0 17    JZ    0x0775             (0250)    jz    ADCINCVR_pot_END_PWM16_ISR
                                        (0251) 
075F: 7A 0C    DEC   [0xC]              (0252)    dec   [ADCINCVR_pot_bSampC]                   ; Dec sample counter and check for zero
0761: B0 13    JNZ   0x0775             (0253)    jnz   ADCINCVR_pot_END_PWM16_ISR
                                        (0254) 
                                        (0255)    ;**********************************************
                                        (0256)    ; Turn off ADC
                                        (0257)    ;**********************************************
0763: 41 33 FE AND   REG[0x33],0xFE     (0258)    and   reg[ADCINCVR_pot_fPWM_LSB_CR0], ~ADCINCVR_pot_fDBLK_ENABLE     ; Disable the PWM
0766: 41 2F FE AND   REG[0x2F],0xFE     (0259)    and   reg[ADCINCVR_pot_bCounter_CR0], ~ADCINCVR_pot_fDBLK_ENABLE           ; Disable the Counter
                                        (0260) IF ADCINCVR_pot_NoAZ
0769: 43 9A 20 OR    REG[0x9A],0x20     (0261)    or    reg[ADCINCVR_pot_bfAtoDcr2], ADCINCVR_pot_fAutoZero   ; Put the Integrator into Autozero mode
                                        (0262) ENDIF
076C: 43 9B 10 OR    REG[0x9B],0x10     (0263)    or    reg[ADCINCVR_pot_bfAtoDcr3], ADCINCVR_pot_fFSW0       ; Put Integrator into reset
076F: 41 E1 DF AND   REG[0xE1],0xDF     (0264)    and   reg[ADCINCVR_pot_bfPWM16_INT_REG], ~ADCINCVR_pot_bfPWM16_Mask      ; Disable interrupts
0772: 41 E1 F7 AND   REG[0xE1],0xF7     (0265)    and   reg[ADCINCVR_pot_bfCounter_INT_REG], ~ADCINCVR_pot_bfCounter_Mask
                                        (0266) 
                                        (0267) ADCINCVR_pot_END_PWM16_ISR:
0775: 7E       RETI                     (0268)    reti
(0269) 
(0270) ; End of File ADCINCVR_potINT.asm
FILE: lib\adcincvr_pot.asm
                                        (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  ADCINCVR_pot.asm
                                        (0004) ;;  Version: 3.1, Updated on 2009/10/15 at 17:11:37
                                        (0005) ;;  Generated by PSoC Designer 5.0.1127.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: ADCINCVR User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "ADCINCVR_pot.inc"
                                        (0023) include "m8c.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  ADCINCVR_pot_Start
                                        (0030) export _ADCINCVR_pot_Start
                                        (0031) export  ADCINCVR_pot_SetPower
                                        (0032) export _ADCINCVR_pot_SetPower
                                        (0033) export  ADCINCVR_pot_Stop
                                        (0034) export _ADCINCVR_pot_Stop
                                        (0035) export  ADCINCVR_pot_GetSamples
                                        (0036) export _ADCINCVR_pot_GetSamples
                                        (0037) export  ADCINCVR_pot_StopAD
                                        (0038) export _ADCINCVR_pot_StopAD
                                        (0039) export  ADCINCVR_pot_fIsData
                                        (0040) export _ADCINCVR_pot_fIsData
                                        (0041) export  ADCINCVR_pot_fIsDataAvailable
                                        (0042) export _ADCINCVR_pot_fIsDataAvailable
                                        (0043) export  ADCINCVR_pot_iGetData
                                        (0044) export _ADCINCVR_pot_iGetData
                                        (0045) export  ADCINCVR_pot_ClearFlag
                                        (0046) export _ADCINCVR_pot_ClearFlag
                                        (0047) export  ADCINCVR_pot_iGetDataClearFlag
                                        (0048) export _ADCINCVR_pot_iGetDataClearFlag
                                        (0049) export  ADCINCVR_pot_SetResolution
                                        (0050) export _ADCINCVR_pot_SetResolution
                                        (0051) 
                                        (0052) ;-----------------------------------------------
                                        (0053) ;  EQUATES
                                        (0054) ;-----------------------------------------------
                                        (0055) LowByte:       equ 1
                                        (0056) HighByte:      equ 0
                                        (0057) 
                                        (0058) ; Calctime parameters
                                        (0059) wCalcTime:     equ   ADCINCVR_pot_bCALCTIME
                                        (0060) 
                                        (0061) AREA UserModules (ROM, REL)
                                        (0062) 
                                        (0063) .SECTION
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;  FUNCTION NAME: ADCINCVR_pot_Start
                                        (0066) ;  FUNCTION NAME: ADCINCVR_pot_SetPower
                                        (0067) ;
                                        (0068) ;  DESCRIPTION:
                                        (0069) ;  Applies power setting to the module's analog PSoc block.
                                        (0070) ;
                                        (0071) ;-----------------------------------------------------------------------------
                                        (0072) ;
                                        (0073) ;  ARGUMENTS:
                                        (0074) ;   A  Contains power level setting 0 to 3
                                        (0075) ;
                                        (0076) ;  RETURNS:  NA
                                        (0077) ;
                                        (0078) ;  SIDE EFFECTS:
                                        (0079) ;    The A and X registers may be modified by this or future implementations
                                        (0080) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0081) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0082) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0083) ;    functions.
                                        (0084) ;          
                                        (0085) ;    Currently only the page pointer registers listed below are modified:
                                        (0086) ;          CUR_PP
                                        (0087) ;
                                        (0088)  ADCINCVR_pot_Start:
                                        (0089) _ADCINCVR_pot_Start:
                                        (0090)  ADCINCVR_pot_SetPower:
                                        (0091) _ADCINCVR_pot_SetPower:
                                        (0092)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_2
0776: 62 D0 00 MOV   REG[0xD0],0x0      (0094)    RAM_SETPAGE_CUR >ADCINCVR_pot_bfStatus
                                        (0095)    
0779: 4F       MOV   X,SP               (0096)    mov   X, SP                                       ; Get location of next location on stack
077A: 21 03    AND   A,0x3              (0097)    and   A,ADCINCVR_pot_bfPOWERMASK                  ; Mask only the valid power setting bits
077C: 08       PUSH  A                  (0098)    push  A                                           ; Save power value on temp location
077D: 5D 9B    MOV   A,REG[0x9B]        (0099)    mov   A, reg[ADCINCVR_pot_bfAtoDcr3]              ; Get current value of AtoDcr3
077F: 21 FC    AND   A,0xFC             (0100)    and   A, ~ADCINCVR_pot_bfPOWERMASK                ; Mask off old power value
0781: 2B 00    OR    A,[X+0]            (0101)    or    A, [X]                                      ; OR in new power value
0783: 29 F0    OR    A,0xF0             (0102)    or    A, f0h                                      ; Make sure other register is set correctly
0785: 60 9B    MOV   REG[0x9B],A        (0103)    mov   reg[ADCINCVR_pot_bfAtoDcr3], A              ; Reload CR with new power value
                                        (0104) 
0787: 49 9A 01 TST   REG[0x9A],0x1      (0105)    tst   reg[ADCINCVR_pot_bfAtoDcr2], ADCINCVR_pot_fRES_SET
078A: A0 05    JZ    0x0790             (0106)    jz    .DoNotLoadRes
078C: 50 03    MOV   A,0x3              (0107)    mov   A,ADCINCVR_pot_bNUMBITS - ADCINCVR_pot_bMINRES         ; get and set the resolution
078E: 53 0B    MOV   [0xB],A            (0108)    mov   [ADCINCVR_pot_bfStatus], A              ; place it in the status variable
                                        (0109) .DoNotLoadRes:
0790: 18       POP   A                  (0110)    pop   A                                           ; Restore the stack and power value
0791: 70 3F    AND   F,0x3F             
0793: 71 C0    OR    F,0xC0             (0111)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0112)    RAM_EPILOGUE RAM_USE_CLASS_4
0795: 7F       RET                      (0113)    ret
                                        (0114) .ENDSECTION
                                        (0115) 
                                        (0116) .SECTION
                                        (0117) ;-----------------------------------------------------------------------------
                                        (0118) ;  FUNCTION NAME: ADCINCVR_pot_Stop
                                        (0119) ;
                                        (0120) ;  DESCRIPTION:
                                        (0121) ;  Removes power from the module's analog PSoc block, but the digital
                                        (0122) ;  blocks keep on running.
                                        (0123) ;
                                        (0124) ;-----------------------------------------------------------------------------
                                        (0125) ;
                                        (0126) ;  ARGUMENTS: None
                                        (0127) ;
                                        (0128) ;  RETURNS:   NA
                                        (0129) ;
                                        (0130) ;  SIDE EFFECTS:
                                        (0131) ;    The A and X registers may be modified by this or future implementations
                                        (0132) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0133) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0134) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0135) ;    functions.
                                        (0136) ;
                                        (0137)  ADCINCVR_pot_Stop:
                                        (0138) _ADCINCVR_pot_Stop:
                                        (0139)    RAM_PROLOGUE RAM_USE_CLASS_1
0796: 41 9B FC AND   REG[0x9B],0xFC     (0140)    and   reg[ADCINCVR_pot_bfAtoDcr3], ~ADCINCVR_pot_bfPOWERMASK
                                        (0141)    RAM_EPILOGUE RAM_USE_CLASS_1
0799: 7F       RET                      (0142)    ret
                                        (0143) .ENDSECTION
                                        (0144) 
                                        (0145) .SECTION
                                        (0146) ;-----------------------------------------------------------------------------
                                        (0147) ;  FUNCTION NAME: ADCINCVR_pot_Get_Samples
                                        (0148) ;
                                        (0149) ;  DESCRIPTION:
                                        (0150) ;  Starts the A/D convertor and will place data is memory.  A flag
                                        (0151) ;  is set whenever a new data value is available.
                                        (0152) ;
                                        (0153) ;-----------------------------------------------------------------------------
                                        (0154) ;
                                        (0155) ;  ARGUMENTS:
                                        (0156) ;  A  Number of samples to be taken.  A zero will cause the ADC to run
                                        (0157) ;     continuously.
                                        (0158) ;
                                        (0159) ;  RETURNS:  NA
                                        (0160) ;
                                        (0161) ;  SIDE EFFECTS:
                                        (0162) ;    The A and X registers may be modified by this or future implementations
                                        (0163) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0164) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0165) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0166) ;    functions.
                                        (0167) ;          
                                        (0168) ;    Currently only the page pointer registers listed below are modified:
                                        (0169) ;          CUR_PP
                                        (0170) ;
                                        (0171)  ADCINCVR_pot_GetSamples:
                                        (0172) _ADCINCVR_pot_GetSamples:
                                        (0173)    RAM_PROLOGUE RAM_USE_CLASS_4
079A: 62 D0 00 MOV   REG[0xD0],0x0      (0174)    RAM_SETPAGE_CUR >ADCINCVR_pot_bfStatus
079D: 53 0C    MOV   [0xC],A            (0175)    mov   [ADCINCVR_pot_bSampC], A                          ; Store sample count
                                        (0176)                                                            ; Interrupts, Put A/D in reset
079F: 51 0B    MOV   A,[0xB]            (0177)    mov   A,[ADCINCVR_pot_bfStatus]                         ; get and set the resolution
07A1: 21 0F    AND   A,0xF              (0178)    and   A,ADCINCVR_pot_bRES_MASK
07A3: 01 07    ADD   A,0x7              (0179)    add   A,ADCINCVR_pot_bMINRES
07A5: 90 5A    CALL  0x0801             (0180)    call  ADCINCVR_pot_SetResolution
                                        (0181) 
                                        (0182) ADCINCVR_pot_LoadMSBCounter:                               ; The PWM has been setup by SetResolution, now set the upper
                                        (0183)                                                            ; counter which will be the same as the period.
                                        (0184)                                                            ; Reset MSB of counter to most negative value
                                        (0185) 
07A7: 5D 36    MOV   A,REG[0x36]        (0186)    mov   A,reg[ADCINCVR_pot_bPWM_IntTime_MSB]              ; Get MSB of PWM and move it into RAM
07A9: 53 08    MOV   [0x8],A            (0187)    mov   [ADCINCVR_pot_cCounterU], A                       ; Use counter as temp location
07AB: 50 00    MOV   A,0x0              (0188)    mov   A, 00h                                            ; Load A with zero for the calculation
07AD: 12 08    SUB   A,[0x8]            (0189)    sub   A, [ADCINCVR_pot_cCounterU]                       ; 0 - MSB_PWM = MSB_of_most_neg_value
07AF: 67       ASR   A                  (0190)    asr   A                                                 ; Half the range (+ and -)
                                        (0191) IF (ADCINCVR_pot_DATA_FORMAT)
07B0: 53 08    MOV   [0x8],A            (0192)    mov   [ADCINCVR_pot_cCounterU], A                       ; Place result back into MSB of counter
                                        (0193) ELSE
                                        (0194)    mov   [ADCINCVR_pot_cCounterU], 00h                     ; Always start at zero for unsigned values
                                        (0195) ENDIF
07B2: 5D 32    MOV   A,REG[0x32]        (0196)    mov   A, reg[ADCINCVR_pot_bPWM_IntTime_LSB]             ; Dummy Read  - required do not remove
07B4: 62 2D FF MOV   REG[0x2D],0xFF     (0197)    mov   reg[ADCINCVR_pot_bPeriod], FFh                    ; Make sure counter starts at FF
                                        (0198) 
07B7: 41 9B EF AND   REG[0x9B],0xEF     (0199)    and   reg[ADCINCVR_pot_bfAtoDcr3],~ADCINCVR_pot_fFSW0   ; Take Integrator out of reset
                                        (0200) IF ADCINCVR_pot_NoAZ
07BA: 41 9A DF AND   REG[0x9A],0xDF     (0201)     and  reg[ADCINCVR_pot_bfAtoDcr2],~ADCINCVR_pot_fAutoZero  ; Take Integrator out of AutoZero
                                        (0202) ENDIF
                                        (0203) 
                                        (0204)                                                                ; Enable the A/D and Start it!
07BD: 43 2F 05 OR    REG[0x2F],0x5      (0205)    or    reg[ADCINCVR_pot_bCounter_CR0], (ADCINCVR_pot_fDBLK_ENABLE|ADCINCVR_pot_fPULSE_WIDE)   ; Enable the Counter
07C0: 43 33 01 OR    REG[0x33],0x1      (0206)    or    reg[ADCINCVR_pot_fPWM_LSB_CR0], ADCINCVR_pot_fDBLK_ENABLE          ; Enable PWM
07C3: 43 E1 20 OR    REG[0xE1],0x20     (0207)    or    reg[ADCINCVR_pot_bfPWM16_INT_REG], ADCINCVR_pot_bfPWM16_Mask    ; Enable Counter interrupts
07C6: 43 E1 08 OR    REG[0xE1],0x8      (0208)    or    reg[ADCINCVR_pot_bfCounter_INT_REG], ADCINCVR_pot_bfCounter_Mask
                                        (0209)    RAM_EPILOGUE RAM_USE_CLASS_4
07C9: 7F       RET                      (0210)    ret
                                        (0211) .ENDSECTION
                                        (0212) 
                                        (0213) .SECTION
                                        (0214) ;-----------------------------------------------------------------------------
                                        (0215) ;  FUNCTION NAME: ADCINCVR_pot_StopAD
                                        (0216) ;
                                        (0217) ;  DESCRIPTION:
                                        (0218) ;  Completely shuts down the A/D is an orderly manner.  Both the
                                        (0219) ;  Timer and Counter are disabled and their interrupts are deactivated.
                                        (0220) ;
                                        (0221) ;-----------------------------------------------------------------------------
                                        (0222) ;
                                        (0223) ;  ARGUMENTS:  None
                                        (0224) ;
                                        (0225) ;  RETURNS: NA
                                        (0226) ;
                                        (0227) ;  SIDE EFFECTS:
                                        (0228) ;    The A and X registers may be modified by this or future implementations
                                        (0229) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0230) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0231) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0232) ;    functions.
                                        (0233) ;
                                        (0234)  ADCINCVR_pot_StopAD:
                                        (0235) _ADCINCVR_pot_StopAD:
                                        (0236)    RAM_PROLOGUE RAM_USE_CLASS_1
07CA: 41 33 FE AND   REG[0x33],0xFE     (0237)    and   reg[ADCINCVR_pot_fPWM_LSB_CR0], ~ADCINCVR_pot_fDBLK_ENABLE     ; Disable the PWM
                                        (0238) 
07CD: 41 2F FE AND   REG[0x2F],0xFE     (0239)    and   reg[ADCINCVR_pot_bCounter_CR0], ~ADCINCVR_pot_fDBLK_ENABLE           ; Disable the Counter
                                        (0240) 
                                        (0241) IF ADCINCVR_pot_NoAZ
07D0: 43 9A 20 OR    REG[0x9A],0x20     (0242)    or   reg[ADCINCVR_pot_bfAtoDcr2], ADCINCVR_pot_fAutoZero    ; Put the Integrator into Autozero mode
                                        (0243) ENDIF
                                        (0244) 
07D3: 43 9B 10 OR    REG[0x9B],0x10     (0245)    or   reg[ADCINCVR_pot_bfAtoDcr3], ADCINCVR_pot_fFSW0        ; Put Integrator into reset
07D6: 08       PUSH  A                  (0246)    push A
07D7: 41 E1 DF AND   REG[0xE1],0xDF     (0247)    M8C_DisableIntMask ADCINCVR_pot_bfPWM16_INT_REG, ADCINCVR_pot_bfPWM16_Mask      ; Disable interrupts
07DA: 41 E1 F7 AND   REG[0xE1],0xF7     (0248)    M8C_DisableIntMask ADCINCVR_pot_bfCounter_INT_REG, ADCINCVR_pot_bfCounter_Mask
07DD: 18       POP   A                  (0249)    pop  A
                                        (0250)    RAM_EPILOGUE RAM_USE_CLASS_1
07DE: 7F       RET                      (0251)    ret
                                        (0252) .ENDSECTION
                                        (0253) 
                                        (0254) .SECTION
                                        (0255) ;-----------------------------------------------------------------------------
                                        (0256) ;  FUNCTION NAME: ADCINCVR_pot_fIsData
                                        (0257) ;  FUNCTION NAME: ADCINCVR_pot_fIsDataAvailable
                                        (0258) ;
                                        (0259) ;  DESCRIPTION:
                                        (0260) ;  Returns the status of the A/D Data is set whenever a new data
                                        (0261) ;  value is available.
                                        (0262) ;
                                        (0263) ;-----------------------------------------------------------------------------
                                        (0264) ;
                                        (0265) ;  ARGUMENTS: None
                                        (0266) ;
                                        (0267) ;  RETURNS:
                                        (0268) ;  A  Returns data status  A == 0 no data available
                                        (0269) ;                          A != 0 data available
                                        (0270) ;
                                        (0271) ;  SIDE EFFECTS:
                                        (0272) ;    The A and X registers may be modified by this or future implementations
                                        (0273) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0274) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0275) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0276) ;    functions.
                                        (0277) ;          
                                        (0278) ;    Currently only the page pointer registers listed below are modified: 
                                        (0279) ;          CUR_PP
                                        (0280) ;
                                        (0281)  ADCINCVR_pot_fIsData:
                                        (0282) _ADCINCVR_pot_fIsData:
                                        (0283)  ADCINCVR_pot_fIsDataAvailable:
                                        (0284) _ADCINCVR_pot_fIsDataAvailable:
                                        (0285)    RAM_PROLOGUE RAM_USE_CLASS_4
07DF: 62 D0 00 MOV   REG[0xD0],0x0      (0286)    RAM_SETPAGE_CUR >ADCINCVR_pot_bfStatus
07E2: 51 0B    MOV   A,[0xB]            (0287)    mov   A, [ADCINCVR_pot_bfStatus]                   ; Get status byte
07E4: 21 10    AND   A,0x10             (0288)    and   A, ADCINCVR_pot_fDATA_READY                  ; Mask off other bits
                                        (0289)    RAM_EPILOGUE RAM_USE_CLASS_4
07E6: 7F       RET                      (0290)    ret
                                        (0291) .ENDSECTION
                                        (0292) 
                                        (0293) .SECTION
                                        (0294) ;-----------------------------------------------------------------------------
                                        (0295) ;  FUNCTION NAME: ADCINCVR_pot_iGetDataClearFlag
                                        (0296) ;  FUNCTION NAME: ADCINCVR_pot_iGetData
                                        (0297) ;
                                        (0298) ;  DESCRIPTION:
                                        (0299) ;  Returns the data from the A/D.  Does not check if data is available.
                                        (0300) ;  iGetDataClearFlag clears the result ready flag as well.
                                        (0301) ;
                                        (0302) ;-----------------------------------------------------------------------------
                                        (0303) ;
                                        (0304) ;  ARGUMENTS: None
                                        (0305) ;
                                        (0306) ;  RETURNS:
                                        (0307) ;  A:X  return the ADC result.
                                        (0308) ;
                                        (0309) ;  SIDE EFFECTS:
                                        (0310) ;    The A and X registers may be modified by this or future implementations
                                        (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0314) ;    functions.
                                        (0315) ;          
                                        (0316) ;    Currently only the page pointer registers listed below are modified: 
                                        (0317) ;          CUR_PP
                                        (0318) ;
                                        (0319)  ADCINCVR_pot_iGetDataClearFlag:
                                        (0320) _ADCINCVR_pot_iGetDataClearFlag:   
                                        (0321)    RAM_PROLOGUE RAM_USE_CLASS_4
07E7: 62 D0 00 MOV   REG[0xD0],0x0      (0322)    RAM_SETPAGE_CUR >ADCINCVR_pot_bfStatus
07EA: 26 0B EF AND   [0xB],0xEF         (0323)    and   [ADCINCVR_pot_bfStatus], ~ADCINCVR_pot_fDATA_READY  ; Clear Data ready bit
07ED: 58 09    MOV   X,[0x9]            (0324)    mov   X, [(ADCINCVR_pot_iResult + HighByte)]
07EF: 51 0A    MOV   A,[0xA]            (0325)    mov   A, [(ADCINCVR_pot_iResult + LowByte)]
                                        (0326)    RAM_EPILOGUE RAM_USE_CLASS_4
07F1: 7F       RET                      (0327)    ret
                                        (0328) 
                                        (0329) 
                                        (0330)  ADCINCVR_pot_iGetData:
                                        (0331) _ADCINCVR_pot_iGetData:
                                        (0332)    RAM_PROLOGUE RAM_USE_CLASS_4
07F2: 62 D0 00 MOV   REG[0xD0],0x0      (0333)    RAM_SETPAGE_CUR >ADCINCVR_pot_iResult
07F5: 58 09    MOV   X,[0x9]            (0334)    mov   X, [(ADCINCVR_pot_iResult + HighByte)]
07F7: 51 0A    MOV   A,[0xA]            (0335)    mov   A, [(ADCINCVR_pot_iResult + LowByte)]
                                        (0336)    RAM_EPILOGUE RAM_USE_CLASS_4
07F9: 7F       RET                      (0337)    ret
                                        (0338) .ENDSECTION
                                        (0339) 
                                        (0340) .SECTION
                                        (0341) ;-----------------------------------------------------------------------------
                                        (0342) ;  FUNCTION NAME: ADCINCVR_pot_ClearFlag
                                        (0343) ;
                                        (0344) ;  DESCRIPTION:
                                        (0345) ;  Clears the data ready flag.
                                        (0346) ;
                                        (0347) ;-----------------------------------------------------------------------------
                                        (0348) ;
                                        (0349) ;  ARGUMENTS: None
                                        (0350) ;
                                        (0351) ;  RETURNS: NA
                                        (0352) ;
                                        (0353) ;  SIDE EFFECTS:
                                        (0354) ;    The A and X registers may be modified by this or future implementations
                                        (0355) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0356) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0357) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0358) ;    functions.
                                        (0359) ;          
                                        (0360) ;    Currently only the page pointer registers listed below are modified: 
                                        (0361) ;          CUR_PP
                                        (0362) ;
                                        (0363)  ADCINCVR_pot_ClearFlag:
                                        (0364) _ADCINCVR_pot_ClearFlag:
                                        (0365)    RAM_PROLOGUE RAM_USE_CLASS_4
07FA: 62 D0 00 MOV   REG[0xD0],0x0      (0366)    RAM_SETPAGE_CUR >ADCINCVR_pot_bfStatus
07FD: 26 0B EF AND   [0xB],0xEF         (0367)    and   [ADCINCVR_pot_bfStatus], ~ADCINCVR_pot_fDATA_READY  ; Clear Data ready bit
                                        (0368)    RAM_EPILOGUE RAM_USE_CLASS_4
0800: 7F       RET                      (0369)    ret
                                        (0370) .ENDSECTION
                                        (0371) 
                                        (0372) .SECTION
                                        (0373) ;-----------------------------------------------------------------------------
                                        (0374) ;  FUNCTION NAME: ADCINCVR_pot_SetResolution
                                        (0375) ;
                                        (0376) ;  DESCRIPTION:
                                        (0377) ;  Sets A/D resolution between 7 and 13 bits.
                                        (0378) ;
                                        (0379) ;-----------------------------------------------------------------------------
                                        (0380) ;
                                        (0381) ;  ARGUMENTS:
                                        (0382) ;  A  Passes the number of bits of resolution, between 7 and 13.
                                        (0383) ;
                                        (0384) ;  RETURNS:  NA
                                        (0385) ;
                                        (0386) ;  SIDE EFFECTS:
                                        (0387) ;    The A and X registers may be modified by this or future implementations
                                        (0388) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0389) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0390) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0391) ;    functions.
                                        (0392) ;          
                                        (0393) ;    Currently only the page pointer registers listed below are modified: 
                                        (0394) ;          CUR_PP
                                        (0395) ;
                                        (0396) ;     This function halts the PWM and the counter to sync the A/D , but
                                        (0397) ;     does not re-enable the counter or PWM. To restart the A/D, "Get_Samples"
                                        (0398) ;     should be called.
                                        (0399) ;
                                        (0400)  ADCINCVR_pot_SetResolution:
                                        (0401) _ADCINCVR_pot_SetResolution:
                                        (0402)    RAM_PROLOGUE RAM_USE_CLASS_4
0801: 62 D0 00 MOV   REG[0xD0],0x0      (0403)    RAM_SETPAGE_CUR >ADCINCVR_pot_bfStatus
                                        (0404)    
0804: 41 9A FE AND   REG[0x9A],0xFE     (0405)    and   reg[ADCINCVR_pot_bfAtoDcr2], ~ADCINCVR_pot_fRES_SET
                                        (0406) 
0807: 9F C1    CALL  0x07CA             (0407)    call  ADCINCVR_pot_StopAD                       ; Stop the A/D if it is running
0809: 55 0B 00 MOV   [0xB],0x0          (0408)    mov   [ADCINCVR_pot_bfStatus], 00h              ; and clear status and old resolution
                                        (0409) 
                                        (0410)                                                    ; Check for resolution to be within min and max values
080C: 39 07    CMP   A,0x7              (0411)    cmp   A,ADCINCVR_pot_bMINRES                    ; Check low end of resolution
080E: D0 05    JNC   0x0814             (0412)    jnc   ADCINCVR_pot_CHECKHI
0810: 50 07    MOV   A,0x7              (0413)    mov   A,ADCINCVR_pot_bMINRES                    ; Too low - load legal low value
0812: 80 07    JMP   0x081A             (0414)    jmp   ADCINCVR_pot_RES_OK
                                        (0415) 
                                        (0416) ADCINCVR_pot_CHECKHI:                              ; Check high end of resolution
0814: 39 0D    CMP   A,0xD              (0417)    cmp   A,ADCINCVR_pot_bMAXRES
0816: C0 03    JC    0x081A             (0418)    jc    ADCINCVR_pot_RES_OK
0818: 50 0D    MOV   A,0xD              (0419)    mov   A,ADCINCVR_pot_bMAXRES                    ; Too high - load legal Max value
                                        (0420) 
                                        (0421) ADCINCVR_pot_RES_OK:
                                        (0422)                                                    ; Calculate compare value for the PWM which
                                        (0423)                                                    ; computes the integrate time
081A: 11 07    SUB   A,0x7              (0424)    sub   A, ADCINCVR_pot_bMINRES                   ; Normalize with min resolution
081C: 2C 0B    OR    [0xB],A            (0425)    or    [ADCINCVR_pot_bfStatus], A
                                        (0426)                                                    ; Since min resolution is 7, 2^^7 = 128, the clock
                                        (0427)                                                    ; is running 4x so 128*4=512 or 0x0200
081E: 01 01    ADD   A,0x1              (0428)    add   A,01h                                     ; The MSB is 02h.
0820: 5C       MOV   X,A                (0429)    mov   X,A
0821: 50 01    MOV   A,0x1              (0430)    mov   A,01h
                                        (0431) 
                                        (0432) ADCINCVR_pot_CALC_INTTIME:                         ; Now shift the MSB left for every bit of resolution of min (7).
0823: 64       ASL   A                  (0433)    asl   A
0824: 79       DEC   X                  (0434)    dec   X
0825: BF FD    JNZ   0x0823             (0435)    jnz   ADCINCVR_pot_CALC_INTTIME
                                        (0436) 
                                        (0437) ADCINCVR_pot_LOAD_INTTIME:                         ; Load compare value and Calc time into registers
                                        (0438)                                                    ; Since minimum resolution is 7 bits, this value will always start at 0
0827: 62 32 00 MOV   REG[0x32],0x0      (0439)    mov   reg[ADCINCVR_pot_bPWM_IntTime_LSB], 00h
082A: 60 36    MOV   REG[0x36],A        (0440)    mov   reg[ADCINCVR_pot_bPWM_IntTime_MSB], A
                                        (0441) 
                                        (0442)                                                    ; Load the CalcTime into the PWM Period
082C: 62 31 0A MOV   REG[0x31],0xA      (0443)    mov   reg[ADCINCVR_pot_bPWM_Period_LSB], <wCalcTime
082F: 01 00    ADD   A,0x0              (0444)    add   A, >wCalcTime
0831: 60 35    MOV   REG[0x35],A        (0445)    mov   reg[ADCINCVR_pot_bPWM_Period_MSB],A
                                        (0446)    RAM_EPILOGUE RAM_USE_CLASS_4
0833: 7F       RET                      (0447)    ret
(0448) .ENDSECTION
(0449) ; End of File ADCINCVR_pot.asm
FILE: lib\adcincvr_mesint.asm
                                        (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   ADCINCVR_mesINT.asm
                                        (0004) ;;  Version: 3.1, Updated on 2009/10/15 at 17:11:37
                                        (0005) ;;  Generated by PSoC Designer 5.0.1127.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: ADCINCVR Interrupt Service Routines
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "ADCINCVR_mes.inc"
                                        (0016) 
                                        (0017) ;-----------------------------------------------
                                        (0018) ;  Global Symbols
                                        (0019) ;-----------------------------------------------
                                        (0020) export _ADCINCVR_mes_CNT_ISR
                                        (0021) export _ADCINCVR_mes_PWM16_ISR
                                        (0022) export  ADCINCVR_mes_cCounterU
                                        (0023) export _ADCINCVR_mes_iResult
                                        (0024) export  ADCINCVR_mes_iResult
                                        (0025) export _ADCINCVR_mes_bfStatus
                                        (0026) export  ADCINCVR_mes_bfStatus
                                        (0027) export  ADCINCVR_mes_bSampC
                                        (0028) 
                                        (0029) ;-----------------------------------------------
                                        (0030) ; Variable Allocation
                                        (0031) ;-----------------------------------------------
                                        (0032) AREA InterruptRAM(RAM, REL, CON)
                                        (0033) 
                                        (0034)  ADCINCVR_mes_cCounterU:     BLK   1  ;The Upper byte of the Counter
                                        (0035) _ADCINCVR_mes_iResult:
                                        (0036)  ADCINCVR_mes_iResult:       BLK   2  ;A/D value
                                        (0037) _ADCINCVR_mes_bfStatus:
                                        (0038)  ADCINCVR_mes_bfStatus:      BLK   1  ;Data Valid Flag
                                        (0039)  ADCINCVR_mes_bSampC:        BLK   1  ;# of times to run A/D
                                        (0040) 
                                        (0041) 
                                        (0042) ;-----------------------------------------------
                                        (0043) ;  EQUATES and TABLES
                                        (0044) ;-----------------------------------------------
                                        (0045) LowByte:   equ 1
                                        (0046) HighByte:  equ 0
                                        (0047) 
                                        (0048) 
                                        (0049) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0050) ;---------------------------------------------------
                                        (0051) ; Insert your custom declarations below this banner
                                        (0052) ;---------------------------------------------------
                                        (0053) 
                                        (0054) ;------------------------
                                        (0055) ; Includes
                                        (0056) ;------------------------
                                        (0057) 
                                        (0058) 	
                                        (0059) ;------------------------
                                        (0060) ;  Constant Definitions
                                        (0061) ;------------------------
                                        (0062) 
                                        (0063) 
                                        (0064) ;------------------------
                                        (0065) ; Variable Allocation
                                        (0066) ;------------------------
                                        (0067) 
                                        (0068) 
                                        (0069) ;---------------------------------------------------
                                        (0070) ; Insert your custom declarations above this banner
                                        (0071) ;---------------------------------------------------
                                        (0072) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0073) 
                                        (0074) AREA UserModules (ROM, REL)
                                        (0075) 
                                        (0076) .LITERAL
                                        (0077) ADCINCVR_mesMaxNegX4Table:
                                        (0078) ; Bits  7    8    9   10   11   12   13
                                        (0079)    DB  FFh, FEh, FCh, F8h, F0h, E0h, C0h
                                        (0080) 
                                        (0081) ADCINCVR_mesMaxPosX4Table:
                                        (0082) IF (ADCINCVR_mes_DATA_FORMAT)
                                        (0083) ; Bits (signed)    7    8    9   10   11   12   13
                                        (0084)               DB  01h, 02h, 04h, 08h, 10h, 20h, 40h
                                        (0085) ELSE
                                        (0086) ; Bits (unsigned)  7    8    9   10   11   12   13
                                        (0087)               DB  02h, 04h, 08h, 10h, 20h, 40h, 80h
                                        (0088) 
                                        (0089)  ENDIF
                                        (0090) .ENDLITERAL
                                        (0091) 
                                        (0092) ;-----------------------------------------------------------------------------
                                        (0093) ;  FUNCTION NAME: _ADCINCVR_mes_CNT_ISR (Counter8 Interrupt)
                                        (0094) ;
                                        (0095) ;
                                        (0096) ;  DESCRIPTION:
                                        (0097) ;     Increment the upper (software) half on the counter whenever the
                                        (0098) ;     lower (hardware) half of the counter underflows.  This counter
                                        (0099) ;     should start out at the most negative value (0xFF).
                                        (0100) ;
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;
                                        (0103) _ADCINCVR_mes_CNT_ISR:

0842: 76 0D    INC   [0xD]              (0104)    inc [ADCINCVR_mes_cCounterU]
                                        (0105)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (0106)    ;---------------------------------------------------
                                        (0107)    ; Insert your custom code below this banner
                                        (0108)    ;---------------------------------------------------
                                        (0109)    ;   NOTE: interrupt service routines must preserve
                                        (0110)    ;   the values of the A and X CPU registers.
                                        (0111) 
                                        (0112)    ;---------------------------------------------------
                                        (0113)    ; Insert your custom code above this banner
                                        (0114)    ;---------------------------------------------------
                                        (0115)    ;@PSoC_UserCode_END@ (Do not change this line.)
0844: 7E       RETI                     (0116)    reti
                                        (0117) 
                                        (0118) 
                                        (0119) ;-----------------------------------------------------------------------------
                                        (0120) ;  FUNCTION NAME: _ADCINCVR_mes_PWM16_ISR  (PWM16 Interrupt)
                                        (0121) ;
                                        (0122) ;  DESCRIPTION:
                                        (0123) ;     This ISR is called when the ADC has completed and integrate cycle.
                                        (0124) ;     The ADC value is calculated and stored in a global location before
                                        (0125) ;     the end of the ISR.
                                        (0126) ;
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;
                                        (0129) _ADCINCVR_mes_PWM16_ISR:
0845: 41 23 FE AND   REG[0x23],0xFE     (0130)    and   reg[ADCINCVR_mes_bCounter_CR0], ~ADCINCVR_mes_fDBLK_ENABLE  ; Disable Counter
                                        (0131) IF ADCINCVR_mes_NoAZ
0848: 43 8E 20 OR    REG[0x8E],0x20     (0132)    or    reg[ADCINCVR_mes_bfAtoDcr2], ADCINCVR_mes_fAutoZero      ; Put Integrator in AutoZero
                                        (0133) ENDIF
084B: 43 8F 10 OR    REG[0x8F],0x10     (0134)    or   reg[ADCINCVR_mes_bfAtoDcr3],ADCINCVR_mes_fFSW0        ; Put Integrator in reset
                                        (0135) 
                                        (0136)                                                            ; Enable interrupts for a short period of time just in case.
                                        (0137)                                                            ; Make sure we didn't have a counter interrupt ready to fire
084E: 71 01    OR    F,0x1              (0138)    M8C_EnableGInt
0850: 40       NOP                      (0139)    nop                                                     ; Wait a couple cycles
0851: 70 FE    AND   F,0xFE             (0140)    M8C_DisableGInt                                         ; Disable interrupt, read to complete processing
0853: 08       PUSH  A                  (0141)    push  A                                                 ; Save the Accumulator
0854: 5D 20    MOV   A,REG[0x20]        (0142)    mov   A,reg[ADCINCVR_mes_bCount]                        ; Read counter value  (Bogus read puts value in Period register)
0856: 5D 22    MOV   A,REG[0x22]        (0143)    mov   A,reg[ADCINCVR_mes_bCompare]                      ; Read counter value
0858: 78       DEC   A                  (0144)    dec   A                                                 ; Decrement by one to make sure we didn't miss a count
0859: 73       CPL   A                  (0145)    cpl   A                                                 ; Invert the value
085A: D0 03    JNC   0x085E             (0146)    jnc   ADCINCVR_mes_INT_CALCV                            ; if carry, then inc MSB as well
085C: 76 0D    INC   [0xD]              (0147)    inc   [ADCINCVR_mes_cCounterU]
                                        (0148) ADCINCVR_mes_INT_CALCV:
085E: 53 0F    MOV   [iles],A           (0149)    mov   [(ADCINCVR_mes_iResult + LowByte)], A             ; Store LSB value
0860: 51 0D    MOV   A,[0xD]            (0150)    mov   A, [ADCINCVR_mes_cCounterU]                       ; Store MSB from temp counter
0862: 53 0E    MOV   [0xE],A            (0151)    mov   [(ADCINCVR_mes_iResult + HighByte)], A
                                        (0152)                                                            ; The new value has been stored,
                                        (0153)                                                            ; so get counters ready for next reading first.
0864: 62 21 FF MOV   REG[0x21],0xFF     (0154)    mov   reg[ADCINCVR_mes_bPeriod], ffh                    ; Initialize counter to FF - Set to overflow after 256 counts
0867: 43 23 01 OR    REG[0x23],0x1      (0155)    or    reg[ADCINCVR_mes_bCounter_CR0],ADCINCVR_mes_fDBLK_ENABLE  ; Enable Counter
                                        (0156) 
                                        (0157) IF (ADCINCVR_mes_DATA_FORMAT)                              ; Only check for Negative numbers if SIGNED result
086A: 51 10    MOV   A,[iles+1]         (0158)    mov   A, [ADCINCVR_mes_bfStatus]                        ; Get Status with Resolution
086C: 21 0F    AND   A,0xF              (0159)    and   A, ADCINCVR_mes_bRES_MASK                         ; Mask of resolution
086E: FF C4    INDEX 0x0834             (0160)    index ADCINCVR_mesMaxNegX4Table                         ; Get Maximum negative value from table
0870: 53 0D    MOV   [0xD],A            (0161)    mov   [ADCINCVR_mes_cCounterU], A                       ; Place result back into MSB of counter
                                        (0162) ELSE
                                        (0163)    mov   [ADCINCVR_mes_cCounterU], 00h                     ; Place result back into MSB of counter
                                        (0164) ENDIF
                                        (0165) 
                                        (0166)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                        (0167)    ;---------------------------------------------------
                                        (0168)    ; If the input is muxed with multiple inputs
                                        (0169)    ; this is a good place to change inputs.
                                        (0170)    ; Insert your custom code below this banner
                                        (0171)    ;---------------------------------------------------
                                        (0172)    ;   NOTE: interrupt service routines must preserve
                                        (0173)    ;   the values of the A and X CPU registers. At this
                                        (0174)    ;   point A is already preserved and will be restored;
                                        (0175)    ;   however, if you use X, you must take care of it
                                        (0176)    ;   here!
                                        (0177) 
                                        (0178)    ;---------------------------------------------------
                                        (0179)    ; Insert your custom code above this banner
                                        (0180)    ;---------------------------------------------------
                                        (0181)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0182) 
0872: 41 8F EF AND   REG[0x8F],0xEF     (0183)    and   reg[ADCINCVR_mes_bfAtoDcr3],~ADCINCVR_mes_fFSW0   ; Take Integrator out of reset
                                        (0184) IF ADCINCVR_mes_NoAZ
0875: 41 8E DF AND   REG[0x8E],0xDF     (0185)    and   reg[ADCINCVR_mes_bfAtoDcr2],~ADCINCVR_mes_fAutoZero  ; Take Integrator out of AutoZero
                                        (0186) ENDIF
                                        (0187) 
                                        (0188)    ;****************************************************************************
                                        (0189)    ;M8C_EnableGInt            ; May want to re-enable interrupts at this point,
                                        (0190)    ;                          ; if stack space isn't at a premium.
                                        (0191)    ; NOTE:  this will make system more responsive but, will increase the
                                        (0192)    ;        overall processing time of the A/D calctime.  If an interrupt is
                                        (0193)    ;        taken, it must return within the specified CalcTime to guarantee
                                        (0194)    ;        successful acquisition of the next byte.
                                        (0195)    ;****************************************************************************
                                        (0196) IF (ADCINCVR_mes_DATA_FORMAT)                    ; Only check for Negative numbers if SIGNED result
                                        (0197) 
                                        (0198)                                                  ; Negative Overflow Check
0878: 47 0E 80 TST   [0xE],0x80         (0199)    tst   [(ADCINCVR_mes_iResult + HighByte)],80h
087B: B0 17    JNZ   0x0893             (0200)    jnz   ADCINCVR_mes_NOT_POVFL2
                                        (0201) 
                                        (0202) ENDIF
                                        (0203)                                                  ; Postive Overflow Check
                                        (0204)                                                  ; Get MSB of Max Positive value x4 + 1
087D: 51 10    MOV   A,[iles+1]         (0205)    mov   A,[ADCINCVR_mes_bfStatus]               ; Get Status with Resolution
087F: 21 0F    AND   A,0xF              (0206)    and   A,ADCINCVR_mes_bRES_MASK                ; Mask of resolution normalized to 0
0881: FF B8    INDEX 0x083B             (0207)    index ADCINCVR_mesMaxPosX4Table               ; Get Maximum positive value x4 + 1 from table
0883: 08       PUSH  A                  (0208)    push  A
0884: 22 0E    AND   A,[0xE]            (0209)    and   A, [(ADCINCVR_mes_iResult + HighByte)]
0886: A0 0B    JZ    0x0892             (0210)    jz    ADCINCVR_mes_NOT_POVFL
                                        (0211)                                                  ; Positive overflow, fix it - set to Max Positive + 1
0888: 18       POP   A                  (0212)    pop   A
0889: 11 01    SUB   A,0x1              (0213)    sub   A, 01h
                                        (0214) 
                                        (0215)                                                  ; Force most positive * 4 into result
088B: 53 0E    MOV   [0xE],A            (0216)    mov   [(ADCINCVR_mes_iResult + HighByte)], A
088D: 55 0F FF MOV   [iles],0xFF        (0217)    mov   [(ADCINCVR_mes_iResult + LowByte)], ffh
0890: 80 02    JMP   0x0893             (0218)    jmp   ADCINCVR_mes_NOT_POVFL2
                                        (0219) ADCINCVR_mes_NOT_POVFL:
0892: 18       POP   A                  (0220)    pop   A
                                        (0221) 
                                        (0222) ADCINCVR_mes_NOT_POVFL2:
0893: 68 0E    ASR   [0xE]              (0223)    asr   [(ADCINCVR_mes_iResult + HighByte)]     ; Shift MSB and LSB right twice to divide by four
0895: 6E 0F    RRC   [iles]             (0224)    rrc   [(ADCINCVR_mes_iResult + LowByte)]      ; Remember digital clock 4 times analog clock
0897: 68 0E    ASR   [0xE]              (0225)    asr   [(ADCINCVR_mes_iResult + HighByte)]
0899: 6E 0F    RRC   [iles]             (0226)    rrc   [(ADCINCVR_mes_iResult + LowByte)]
                                        (0227) 
                                        (0228)    ;@PSoC_UserCode_BODY_3@ (Do not change this line.)
                                        (0229)    ;---------------------------------------------------
                                        (0230)    ; Data is ready at this point.
                                        (0231)    ; If processing Data at Interrupt level - add
                                        (0232)    ; User Code to handle the data below this banner
                                        (0233)    ;---------------------------------------------------
                                        (0234)    ;   NOTE: interrupt service routines must preserve
                                        (0235)    ;   the values of the A and X CPU registers. At this
                                        (0236)    ;   point A is already preserved and will be restored;
                                        (0237)    ;   however, if you use X, you must take care of it
                                        (0238)    ;   here!
                                        (0239) 
                                        (0240)    ;---------------------------------------------------
                                        (0241)    ; Insert your custom code above this banner
                                        (0242)    ;---------------------------------------------------
                                        (0243)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0244) 
089B: 18       POP   A                  (0245)    pop   A                                       ; Restore A, not used any more
                                        (0246) 
089C: 2E 10 10 OR    [iles+1],0x10      (0247)    or    [ADCINCVR_mes_bfStatus],ADCINCVR_mes_fDATA_READY  ; Set Data ready bit
                                        (0248) 
089F: 47 11 FF TST   [iles+2],0xFF      (0249)    tst   [ADCINCVR_mes_bSampC], ffh              ; If sample_counter == 0 -->> continuous data collection
08A2: A0 17    JZ    0x08BA             (0250)    jz    ADCINCVR_mes_END_PWM16_ISR
                                        (0251) 
08A4: 7A 11    DEC   [iles+2]           (0252)    dec   [ADCINCVR_mes_bSampC]                   ; Dec sample counter and check for zero
08A6: B0 13    JNZ   0x08BA             (0253)    jnz   ADCINCVR_mes_END_PWM16_ISR
                                        (0254) 
                                        (0255)    ;**********************************************
                                        (0256)    ; Turn off ADC
                                        (0257)    ;**********************************************
08A8: 41 27 FE AND   REG[0x27],0xFE     (0258)    and   reg[ADCINCVR_mes_fPWM_LSB_CR0], ~ADCINCVR_mes_fDBLK_ENABLE     ; Disable the PWM
08AB: 41 23 FE AND   REG[0x23],0xFE     (0259)    and   reg[ADCINCVR_mes_bCounter_CR0], ~ADCINCVR_mes_fDBLK_ENABLE           ; Disable the Counter
                                        (0260) IF ADCINCVR_mes_NoAZ
08AE: 43 8E 20 OR    REG[0x8E],0x20     (0261)    or    reg[ADCINCVR_mes_bfAtoDcr2], ADCINCVR_mes_fAutoZero   ; Put the Integrator into Autozero mode
                                        (0262) ENDIF
08B1: 43 8F 10 OR    REG[0x8F],0x10     (0263)    or    reg[ADCINCVR_mes_bfAtoDcr3], ADCINCVR_mes_fFSW0       ; Put Integrator into reset
08B4: 41 E1 FB AND   REG[0xE1],0xFB     (0264)    and   reg[ADCINCVR_mes_bfPWM16_INT_REG], ~ADCINCVR_mes_bfPWM16_Mask      ; Disable interrupts
08B7: 41 E1 FE AND   REG[0xE1],0xFE     (0265)    and   reg[ADCINCVR_mes_bfCounter_INT_REG], ~ADCINCVR_mes_bfCounter_Mask
                                        (0266) 
                                        (0267) ADCINCVR_mes_END_PWM16_ISR:
08BA: 7E       RETI                     (0268)    reti
(0269) 
(0270) ; End of File ADCINCVR_mesINT.asm
FILE: lib\adcincvr_mes.asm
                                        (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  ADCINCVR_mes.asm
                                        (0004) ;;  Version: 3.1, Updated on 2009/10/15 at 17:11:37
                                        (0005) ;;  Generated by PSoC Designer 5.0.1127.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: ADCINCVR User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "ADCINCVR_mes.inc"
                                        (0023) include "m8c.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  ADCINCVR_mes_Start
                                        (0030) export _ADCINCVR_mes_Start
                                        (0031) export  ADCINCVR_mes_SetPower
                                        (0032) export _ADCINCVR_mes_SetPower
                                        (0033) export  ADCINCVR_mes_Stop
                                        (0034) export _ADCINCVR_mes_Stop
                                        (0035) export  ADCINCVR_mes_GetSamples
                                        (0036) export _ADCINCVR_mes_GetSamples
                                        (0037) export  ADCINCVR_mes_StopAD
                                        (0038) export _ADCINCVR_mes_StopAD
                                        (0039) export  ADCINCVR_mes_fIsData
                                        (0040) export _ADCINCVR_mes_fIsData
                                        (0041) export  ADCINCVR_mes_fIsDataAvailable
                                        (0042) export _ADCINCVR_mes_fIsDataAvailable
                                        (0043) export  ADCINCVR_mes_iGetData
                                        (0044) export _ADCINCVR_mes_iGetData
                                        (0045) export  ADCINCVR_mes_ClearFlag
                                        (0046) export _ADCINCVR_mes_ClearFlag
                                        (0047) export  ADCINCVR_mes_iGetDataClearFlag
                                        (0048) export _ADCINCVR_mes_iGetDataClearFlag
                                        (0049) export  ADCINCVR_mes_SetResolution
                                        (0050) export _ADCINCVR_mes_SetResolution
                                        (0051) 
                                        (0052) ;-----------------------------------------------
                                        (0053) ;  EQUATES
                                        (0054) ;-----------------------------------------------
                                        (0055) LowByte:       equ 1
                                        (0056) HighByte:      equ 0
                                        (0057) 
                                        (0058) ; Calctime parameters
                                        (0059) wCalcTime:     equ   ADCINCVR_mes_bCALCTIME
                                        (0060) 
                                        (0061) AREA UserModules (ROM, REL)
                                        (0062) 
                                        (0063) .SECTION
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;  FUNCTION NAME: ADCINCVR_mes_Start
                                        (0066) ;  FUNCTION NAME: ADCINCVR_mes_SetPower
                                        (0067) ;
                                        (0068) ;  DESCRIPTION:
                                        (0069) ;  Applies power setting to the module's analog PSoc block.
                                        (0070) ;
                                        (0071) ;-----------------------------------------------------------------------------
                                        (0072) ;
                                        (0073) ;  ARGUMENTS:
                                        (0074) ;   A  Contains power level setting 0 to 3
                                        (0075) ;
                                        (0076) ;  RETURNS:  NA
                                        (0077) ;
                                        (0078) ;  SIDE EFFECTS:
                                        (0079) ;    The A and X registers may be modified by this or future implementations
                                        (0080) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0081) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0082) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0083) ;    functions.
                                        (0084) ;          
                                        (0085) ;    Currently only the page pointer registers listed below are modified:
                                        (0086) ;          CUR_PP
                                        (0087) ;
                                        (0088)  ADCINCVR_mes_Start:
                                        (0089) _ADCINCVR_mes_Start:
                                        (0090)  ADCINCVR_mes_SetPower:
                                        (0091) _ADCINCVR_mes_SetPower:
                                        (0092)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_2
08BB: 62 D0 00 MOV   REG[0xD0],0x0      (0094)    RAM_SETPAGE_CUR >ADCINCVR_mes_bfStatus
                                        (0095)    
08BE: 4F       MOV   X,SP               (0096)    mov   X, SP                                       ; Get location of next location on stack
08BF: 21 03    AND   A,0x3              (0097)    and   A,ADCINCVR_mes_bfPOWERMASK                  ; Mask only the valid power setting bits
08C1: 08       PUSH  A                  (0098)    push  A                                           ; Save power value on temp location
08C2: 5D 8F    MOV   A,REG[0x8F]        (0099)    mov   A, reg[ADCINCVR_mes_bfAtoDcr3]              ; Get current value of AtoDcr3
08C4: 21 FC    AND   A,0xFC             (0100)    and   A, ~ADCINCVR_mes_bfPOWERMASK                ; Mask off old power value
08C6: 2B 00    OR    A,[X+0]            (0101)    or    A, [X]                                      ; OR in new power value
08C8: 29 F0    OR    A,0xF0             (0102)    or    A, f0h                                      ; Make sure other register is set correctly
08CA: 60 8F    MOV   REG[0x8F],A        (0103)    mov   reg[ADCINCVR_mes_bfAtoDcr3], A              ; Reload CR with new power value
                                        (0104) 
08CC: 49 8E 01 TST   REG[0x8E],0x1      (0105)    tst   reg[ADCINCVR_mes_bfAtoDcr2], ADCINCVR_mes_fRES_SET
08CF: A0 05    JZ    0x08D5             (0106)    jz    .DoNotLoadRes
08D1: 50 03    MOV   A,0x3              (0107)    mov   A,ADCINCVR_mes_bNUMBITS - ADCINCVR_mes_bMINRES         ; get and set the resolution
08D3: 53 10    MOV   [iles+1],A         (0108)    mov   [ADCINCVR_mes_bfStatus], A              ; place it in the status variable
                                        (0109) .DoNotLoadRes:
08D5: 18       POP   A                  (0110)    pop   A                                           ; Restore the stack and power value
08D6: 70 3F    AND   F,0x3F             
08D8: 71 C0    OR    F,0xC0             (0111)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0112)    RAM_EPILOGUE RAM_USE_CLASS_4
08DA: 7F       RET                      (0113)    ret
                                        (0114) .ENDSECTION
                                        (0115) 
                                        (0116) .SECTION
                                        (0117) ;-----------------------------------------------------------------------------
                                        (0118) ;  FUNCTION NAME: ADCINCVR_mes_Stop
                                        (0119) ;
                                        (0120) ;  DESCRIPTION:
                                        (0121) ;  Removes power from the module's analog PSoc block, but the digital
                                        (0122) ;  blocks keep on running.
                                        (0123) ;
                                        (0124) ;-----------------------------------------------------------------------------
                                        (0125) ;
                                        (0126) ;  ARGUMENTS: None
                                        (0127) ;
                                        (0128) ;  RETURNS:   NA
                                        (0129) ;
                                        (0130) ;  SIDE EFFECTS:
                                        (0131) ;    The A and X registers may be modified by this or future implementations
                                        (0132) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0133) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0134) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0135) ;    functions.
                                        (0136) ;
                                        (0137)  ADCINCVR_mes_Stop:
                                        (0138) _ADCINCVR_mes_Stop:
                                        (0139)    RAM_PROLOGUE RAM_USE_CLASS_1
08DB: 41 8F FC AND   REG[0x8F],0xFC     (0140)    and   reg[ADCINCVR_mes_bfAtoDcr3], ~ADCINCVR_mes_bfPOWERMASK
                                        (0141)    RAM_EPILOGUE RAM_USE_CLASS_1
08DE: 7F       RET                      (0142)    ret
                                        (0143) .ENDSECTION
                                        (0144) 
                                        (0145) .SECTION
                                        (0146) ;-----------------------------------------------------------------------------
                                        (0147) ;  FUNCTION NAME: ADCINCVR_mes_Get_Samples
                                        (0148) ;
                                        (0149) ;  DESCRIPTION:
                                        (0150) ;  Starts the A/D convertor and will place data is memory.  A flag
                                        (0151) ;  is set whenever a new data value is available.
                                        (0152) ;
                                        (0153) ;-----------------------------------------------------------------------------
                                        (0154) ;
                                        (0155) ;  ARGUMENTS:
                                        (0156) ;  A  Number of samples to be taken.  A zero will cause the ADC to run
                                        (0157) ;     continuously.
                                        (0158) ;
                                        (0159) ;  RETURNS:  NA
                                        (0160) ;
                                        (0161) ;  SIDE EFFECTS:
                                        (0162) ;    The A and X registers may be modified by this or future implementations
                                        (0163) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0164) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0165) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0166) ;    functions.
                                        (0167) ;          
                                        (0168) ;    Currently only the page pointer registers listed below are modified:
                                        (0169) ;          CUR_PP
                                        (0170) ;
                                        (0171)  ADCINCVR_mes_GetSamples:
                                        (0172) _ADCINCVR_mes_GetSamples:
                                        (0173)    RAM_PROLOGUE RAM_USE_CLASS_4
08DF: 62 D0 00 MOV   REG[0xD0],0x0      (0174)    RAM_SETPAGE_CUR >ADCINCVR_mes_bfStatus
08E2: 53 11    MOV   [iles+2],A         (0175)    mov   [ADCINCVR_mes_bSampC], A                          ; Store sample count
                                        (0176)                                                            ; Interrupts, Put A/D in reset
08E4: 51 10    MOV   A,[iles+1]         (0177)    mov   A,[ADCINCVR_mes_bfStatus]                         ; get and set the resolution
08E6: 21 0F    AND   A,0xF              (0178)    and   A,ADCINCVR_mes_bRES_MASK
08E8: 01 07    ADD   A,0x7              (0179)    add   A,ADCINCVR_mes_bMINRES
08EA: 90 5A    CALL  0x0946             (0180)    call  ADCINCVR_mes_SetResolution
                                        (0181) 
                                        (0182) ADCINCVR_mes_LoadMSBCounter:                               ; The PWM has been setup by SetResolution, now set the upper
                                        (0183)                                                            ; counter which will be the same as the period.
                                        (0184)                                                            ; Reset MSB of counter to most negative value
                                        (0185) 
08EC: 5D 2A    MOV   A,REG[0x2A]        (0186)    mov   A,reg[ADCINCVR_mes_bPWM_IntTime_MSB]              ; Get MSB of PWM and move it into RAM
08EE: 53 0D    MOV   [0xD],A            (0187)    mov   [ADCINCVR_mes_cCounterU], A                       ; Use counter as temp location
08F0: 50 00    MOV   A,0x0              (0188)    mov   A, 00h                                            ; Load A with zero for the calculation
08F2: 12 0D    SUB   A,[0xD]            (0189)    sub   A, [ADCINCVR_mes_cCounterU]                       ; 0 - MSB_PWM = MSB_of_most_neg_value
08F4: 67       ASR   A                  (0190)    asr   A                                                 ; Half the range (+ and -)
                                        (0191) IF (ADCINCVR_mes_DATA_FORMAT)
08F5: 53 0D    MOV   [0xD],A            (0192)    mov   [ADCINCVR_mes_cCounterU], A                       ; Place result back into MSB of counter
                                        (0193) ELSE
                                        (0194)    mov   [ADCINCVR_mes_cCounterU], 00h                     ; Always start at zero for unsigned values
                                        (0195) ENDIF
08F7: 5D 26    MOV   A,REG[0x26]        (0196)    mov   A, reg[ADCINCVR_mes_bPWM_IntTime_LSB]             ; Dummy Read  - required do not remove
08F9: 62 21 FF MOV   REG[0x21],0xFF     (0197)    mov   reg[ADCINCVR_mes_bPeriod], FFh                    ; Make sure counter starts at FF
                                        (0198) 
08FC: 41 8F EF AND   REG[0x8F],0xEF     (0199)    and   reg[ADCINCVR_mes_bfAtoDcr3],~ADCINCVR_mes_fFSW0   ; Take Integrator out of reset
                                        (0200) IF ADCINCVR_mes_NoAZ
08FF: 41 8E DF AND   REG[0x8E],0xDF     (0201)     and  reg[ADCINCVR_mes_bfAtoDcr2],~ADCINCVR_mes_fAutoZero  ; Take Integrator out of AutoZero
                                        (0202) ENDIF
                                        (0203) 
                                        (0204)                                                                ; Enable the A/D and Start it!
0902: 43 23 05 OR    REG[0x23],0x5      (0205)    or    reg[ADCINCVR_mes_bCounter_CR0], (ADCINCVR_mes_fDBLK_ENABLE|ADCINCVR_mes_fPULSE_WIDE)   ; Enable the Counter
0905: 43 27 01 OR    REG[0x27],0x1      (0206)    or    reg[ADCINCVR_mes_fPWM_LSB_CR0], ADCINCVR_mes_fDBLK_ENABLE          ; Enable PWM
0908: 43 E1 04 OR    REG[0xE1],0x4      (0207)    or    reg[ADCINCVR_mes_bfPWM16_INT_REG], ADCINCVR_mes_bfPWM16_Mask    ; Enable Counter interrupts
090B: 43 E1 01 OR    REG[0xE1],0x1      (0208)    or    reg[ADCINCVR_mes_bfCounter_INT_REG], ADCINCVR_mes_bfCounter_Mask
                                        (0209)    RAM_EPILOGUE RAM_USE_CLASS_4
090E: 7F       RET                      (0210)    ret
                                        (0211) .ENDSECTION
                                        (0212) 
                                        (0213) .SECTION
                                        (0214) ;-----------------------------------------------------------------------------
                                        (0215) ;  FUNCTION NAME: ADCINCVR_mes_StopAD
                                        (0216) ;
                                        (0217) ;  DESCRIPTION:
                                        (0218) ;  Completely shuts down the A/D is an orderly manner.  Both the
                                        (0219) ;  Timer and Counter are disabled and their interrupts are deactivated.
                                        (0220) ;
                                        (0221) ;-----------------------------------------------------------------------------
                                        (0222) ;
                                        (0223) ;  ARGUMENTS:  None
                                        (0224) ;
                                        (0225) ;  RETURNS: NA
                                        (0226) ;
                                        (0227) ;  SIDE EFFECTS:
                                        (0228) ;    The A and X registers may be modified by this or future implementations
                                        (0229) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0230) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0231) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0232) ;    functions.
                                        (0233) ;
                                        (0234)  ADCINCVR_mes_StopAD:
                                        (0235) _ADCINCVR_mes_StopAD:
                                        (0236)    RAM_PROLOGUE RAM_USE_CLASS_1
090F: 41 27 FE AND   REG[0x27],0xFE     (0237)    and   reg[ADCINCVR_mes_fPWM_LSB_CR0], ~ADCINCVR_mes_fDBLK_ENABLE     ; Disable the PWM
                                        (0238) 
0912: 41 23 FE AND   REG[0x23],0xFE     (0239)    and   reg[ADCINCVR_mes_bCounter_CR0], ~ADCINCVR_mes_fDBLK_ENABLE           ; Disable the Counter
                                        (0240) 
                                        (0241) IF ADCINCVR_mes_NoAZ
0915: 43 8E 20 OR    REG[0x8E],0x20     (0242)    or   reg[ADCINCVR_mes_bfAtoDcr2], ADCINCVR_mes_fAutoZero    ; Put the Integrator into Autozero mode
                                        (0243) ENDIF
                                        (0244) 
0918: 43 8F 10 OR    REG[0x8F],0x10     (0245)    or   reg[ADCINCVR_mes_bfAtoDcr3], ADCINCVR_mes_fFSW0        ; Put Integrator into reset
091B: 08       PUSH  A                  (0246)    push A
091C: 41 E1 FB AND   REG[0xE1],0xFB     (0247)    M8C_DisableIntMask ADCINCVR_mes_bfPWM16_INT_REG, ADCINCVR_mes_bfPWM16_Mask      ; Disable interrupts
091F: 41 E1 FE AND   REG[0xE1],0xFE     (0248)    M8C_DisableIntMask ADCINCVR_mes_bfCounter_INT_REG, ADCINCVR_mes_bfCounter_Mask
0922: 18       POP   A                  (0249)    pop  A
                                        (0250)    RAM_EPILOGUE RAM_USE_CLASS_1
0923: 7F       RET                      (0251)    ret
                                        (0252) .ENDSECTION
                                        (0253) 
                                        (0254) .SECTION
                                        (0255) ;-----------------------------------------------------------------------------
                                        (0256) ;  FUNCTION NAME: ADCINCVR_mes_fIsData
                                        (0257) ;  FUNCTION NAME: ADCINCVR_mes_fIsDataAvailable
                                        (0258) ;
                                        (0259) ;  DESCRIPTION:
                                        (0260) ;  Returns the status of the A/D Data is set whenever a new data
                                        (0261) ;  value is available.
                                        (0262) ;
                                        (0263) ;-----------------------------------------------------------------------------
                                        (0264) ;
                                        (0265) ;  ARGUMENTS: None
                                        (0266) ;
                                        (0267) ;  RETURNS:
                                        (0268) ;  A  Returns data status  A == 0 no data available
                                        (0269) ;                          A != 0 data available
                                        (0270) ;
                                        (0271) ;  SIDE EFFECTS:
                                        (0272) ;    The A and X registers may be modified by this or future implementations
                                        (0273) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0274) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0275) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0276) ;    functions.
                                        (0277) ;          
                                        (0278) ;    Currently only the page pointer registers listed below are modified: 
                                        (0279) ;          CUR_PP
                                        (0280) ;
                                        (0281)  ADCINCVR_mes_fIsData:
                                        (0282) _ADCINCVR_mes_fIsData:
                                        (0283)  ADCINCVR_mes_fIsDataAvailable:
                                        (0284) _ADCINCVR_mes_fIsDataAvailable:
                                        (0285)    RAM_PROLOGUE RAM_USE_CLASS_4
0924: 62 D0 00 MOV   REG[0xD0],0x0      (0286)    RAM_SETPAGE_CUR >ADCINCVR_mes_bfStatus
0927: 51 10    MOV   A,[iles+1]         (0287)    mov   A, [ADCINCVR_mes_bfStatus]                   ; Get status byte
0929: 21 10    AND   A,0x10             (0288)    and   A, ADCINCVR_mes_fDATA_READY                  ; Mask off other bits
                                        (0289)    RAM_EPILOGUE RAM_USE_CLASS_4
092B: 7F       RET                      (0290)    ret
                                        (0291) .ENDSECTION
                                        (0292) 
                                        (0293) .SECTION
                                        (0294) ;-----------------------------------------------------------------------------
                                        (0295) ;  FUNCTION NAME: ADCINCVR_mes_iGetDataClearFlag
                                        (0296) ;  FUNCTION NAME: ADCINCVR_mes_iGetData
                                        (0297) ;
                                        (0298) ;  DESCRIPTION:
                                        (0299) ;  Returns the data from the A/D.  Does not check if data is available.
                                        (0300) ;  iGetDataClearFlag clears the result ready flag as well.
                                        (0301) ;
                                        (0302) ;-----------------------------------------------------------------------------
                                        (0303) ;
                                        (0304) ;  ARGUMENTS: None
                                        (0305) ;
                                        (0306) ;  RETURNS:
                                        (0307) ;  A:X  return the ADC result.
                                        (0308) ;
                                        (0309) ;  SIDE EFFECTS:
                                        (0310) ;    The A and X registers may be modified by this or future implementations
                                        (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0314) ;    functions.
                                        (0315) ;          
                                        (0316) ;    Currently only the page pointer registers listed below are modified: 
                                        (0317) ;          CUR_PP
                                        (0318) ;
                                        (0319)  ADCINCVR_mes_iGetDataClearFlag:
                                        (0320) _ADCINCVR_mes_iGetDataClearFlag:   
                                        (0321)    RAM_PROLOGUE RAM_USE_CLASS_4
092C: 62 D0 00 MOV   REG[0xD0],0x0      (0322)    RAM_SETPAGE_CUR >ADCINCVR_mes_bfStatus
092F: 26 10 EF AND   [iles+1],0xEF      (0323)    and   [ADCINCVR_mes_bfStatus], ~ADCINCVR_mes_fDATA_READY  ; Clear Data ready bit
0932: 58 0E    MOV   X,[0xE]            (0324)    mov   X, [(ADCINCVR_mes_iResult + HighByte)]
0934: 51 0F    MOV   A,[iles]           (0325)    mov   A, [(ADCINCVR_mes_iResult + LowByte)]
                                        (0326)    RAM_EPILOGUE RAM_USE_CLASS_4
0936: 7F       RET                      (0327)    ret
                                        (0328) 
                                        (0329) 
                                        (0330)  ADCINCVR_mes_iGetData:
                                        (0331) _ADCINCVR_mes_iGetData:
                                        (0332)    RAM_PROLOGUE RAM_USE_CLASS_4
0937: 62 D0 00 MOV   REG[0xD0],0x0      (0333)    RAM_SETPAGE_CUR >ADCINCVR_mes_iResult
093A: 58 0E    MOV   X,[0xE]            (0334)    mov   X, [(ADCINCVR_mes_iResult + HighByte)]
093C: 51 0F    MOV   A,[iles]           (0335)    mov   A, [(ADCINCVR_mes_iResult + LowByte)]
                                        (0336)    RAM_EPILOGUE RAM_USE_CLASS_4
093E: 7F       RET                      (0337)    ret
                                        (0338) .ENDSECTION
                                        (0339) 
                                        (0340) .SECTION
                                        (0341) ;-----------------------------------------------------------------------------
                                        (0342) ;  FUNCTION NAME: ADCINCVR_mes_ClearFlag
                                        (0343) ;
                                        (0344) ;  DESCRIPTION:
                                        (0345) ;  Clears the data ready flag.
                                        (0346) ;
                                        (0347) ;-----------------------------------------------------------------------------
                                        (0348) ;
                                        (0349) ;  ARGUMENTS: None
                                        (0350) ;
                                        (0351) ;  RETURNS: NA
                                        (0352) ;
                                        (0353) ;  SIDE EFFECTS:
                                        (0354) ;    The A and X registers may be modified by this or future implementations
                                        (0355) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0356) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0357) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0358) ;    functions.
                                        (0359) ;          
                                        (0360) ;    Currently only the page pointer registers listed below are modified: 
                                        (0361) ;          CUR_PP
                                        (0362) ;
                                        (0363)  ADCINCVR_mes_ClearFlag:
                                        (0364) _ADCINCVR_mes_ClearFlag:
                                        (0365)    RAM_PROLOGUE RAM_USE_CLASS_4
093F: 62 D0 00 MOV   REG[0xD0],0x0      (0366)    RAM_SETPAGE_CUR >ADCINCVR_mes_bfStatus
0942: 26 10 EF AND   [iles+1],0xEF      (0367)    and   [ADCINCVR_mes_bfStatus], ~ADCINCVR_mes_fDATA_READY  ; Clear Data ready bit
                                        (0368)    RAM_EPILOGUE RAM_USE_CLASS_4
0945: 7F       RET                      (0369)    ret
                                        (0370) .ENDSECTION
                                        (0371) 
                                        (0372) .SECTION
                                        (0373) ;-----------------------------------------------------------------------------
                                        (0374) ;  FUNCTION NAME: ADCINCVR_mes_SetResolution
                                        (0375) ;
                                        (0376) ;  DESCRIPTION:
                                        (0377) ;  Sets A/D resolution between 7 and 13 bits.
                                        (0378) ;
                                        (0379) ;-----------------------------------------------------------------------------
                                        (0380) ;
                                        (0381) ;  ARGUMENTS:
                                        (0382) ;  A  Passes the number of bits of resolution, between 7 and 13.
                                        (0383) ;
                                        (0384) ;  RETURNS:  NA
                                        (0385) ;
                                        (0386) ;  SIDE EFFECTS:
                                        (0387) ;    The A and X registers may be modified by this or future implementations
                                        (0388) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0389) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0390) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0391) ;    functions.
                                        (0392) ;          
                                        (0393) ;    Currently only the page pointer registers listed below are modified: 
                                        (0394) ;          CUR_PP
                                        (0395) ;
                                        (0396) ;     This function halts the PWM and the counter to sync the A/D , but
                                        (0397) ;     does not re-enable the counter or PWM. To restart the A/D, "Get_Samples"
                                        (0398) ;     should be called.
                                        (0399) ;
                                        (0400)  ADCINCVR_mes_SetResolution:
                                        (0401) _ADCINCVR_mes_SetResolution:
                                        (0402)    RAM_PROLOGUE RAM_USE_CLASS_4
0946: 62 D0 00 MOV   REG[0xD0],0x0      (0403)    RAM_SETPAGE_CUR >ADCINCVR_mes_bfStatus
                                        (0404)    
0949: 41 8E FE AND   REG[0x8E],0xFE     (0405)    and   reg[ADCINCVR_mes_bfAtoDcr2], ~ADCINCVR_mes_fRES_SET
                                        (0406) 
094C: 9F C1    CALL  0x090F             (0407)    call  ADCINCVR_mes_StopAD                       ; Stop the A/D if it is running
094E: 55 10 00 MOV   [iles+1],0x0       (0408)    mov   [ADCINCVR_mes_bfStatus], 00h              ; and clear status and old resolution
                                        (0409) 
                                        (0410)                                                    ; Check for resolution to be within min and max values
0951: 39 07    CMP   A,0x7              (0411)    cmp   A,ADCINCVR_mes_bMINRES                    ; Check low end of resolution
0953: D0 05    JNC   0x0959             (0412)    jnc   ADCINCVR_mes_CHECKHI
0955: 50 07    MOV   A,0x7              (0413)    mov   A,ADCINCVR_mes_bMINRES                    ; Too low - load legal low value
0957: 80 07    JMP   0x095F             (0414)    jmp   ADCINCVR_mes_RES_OK
                                        (0415) 
                                        (0416) ADCINCVR_mes_CHECKHI:                              ; Check high end of resolution
0959: 39 0D    CMP   A,0xD              (0417)    cmp   A,ADCINCVR_mes_bMAXRES
095B: C0 03    JC    0x095F             (0418)    jc    ADCINCVR_mes_RES_OK
095D: 50 0D    MOV   A,0xD              (0419)    mov   A,ADCINCVR_mes_bMAXRES                    ; Too high - load legal Max value
                                        (0420) 
                                        (0421) ADCINCVR_mes_RES_OK:
                                        (0422)                                                    ; Calculate compare value for the PWM which
                                        (0423)                                                    ; computes the integrate time
095F: 11 07    SUB   A,0x7              (0424)    sub   A, ADCINCVR_mes_bMINRES                   ; Normalize with min resolution
0961: 2C 10    OR    [iles+1],A         (0425)    or    [ADCINCVR_mes_bfStatus], A
                                        (0426)                                                    ; Since min resolution is 7, 2^^7 = 128, the clock
                                        (0427)                                                    ; is running 4x so 128*4=512 or 0x0200
0963: 01 01    ADD   A,0x1              (0428)    add   A,01h                                     ; The MSB is 02h.
0965: 5C       MOV   X,A                (0429)    mov   X,A
0966: 50 01    MOV   A,0x1              (0430)    mov   A,01h
                                        (0431) 
                                        (0432) ADCINCVR_mes_CALC_INTTIME:                         ; Now shift the MSB left for every bit of resolution of min (7).
0968: 64       ASL   A                  (0433)    asl   A
0969: 79       DEC   X                  (0434)    dec   X
096A: BF FD    JNZ   0x0968             (0435)    jnz   ADCINCVR_mes_CALC_INTTIME
                                        (0436) 
                                        (0437) ADCINCVR_mes_LOAD_INTTIME:                         ; Load compare value and Calc time into registers
                                        (0438)                                                    ; Since minimum resolution is 7 bits, this value will always start at 0
096C: 62 26 00 MOV   REG[0x26],0x0      (0439)    mov   reg[ADCINCVR_mes_bPWM_IntTime_LSB], 00h
096F: 60 2A    MOV   REG[0x2A],A        (0440)    mov   reg[ADCINCVR_mes_bPWM_IntTime_MSB], A
                                        (0441) 
                                        (0442)                                                    ; Load the CalcTime into the PWM Period
0971: 62 25 24 MOV   REG[0x25],0x24     (0443)    mov   reg[ADCINCVR_mes_bPWM_Period_LSB], <wCalcTime
0974: 01 00    ADD   A,0x0              (0444)    add   A, >wCalcTime
0976: 60 29    MOV   REG[0x29],A        (0445)    mov   reg[ADCINCVR_mes_bPWM_Period_MSB],A
                                        (0446)    RAM_EPILOGUE RAM_USE_CLASS_4
0978: 7F       RET                      (0447)    ret
(0448) .ENDSECTION
(0449) ; End of File ADCINCVR_mes.asm
FILE: C:\DOCUME~1\ADMINI~1\Desktop\PSOCPR~1\EXPLOR~1\EXPLOR~1\EXPLOR~1\main.c
(0001) //----------------------------------------------------------------------------
(0002) // C main line
(0003) //----------------------------------------------------------------------------
(0004) 
(0005) #include <m8c.h>        // part specific constants and macros
(0006) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0007) 
(0008) 
(0009) void main(void)
_main|__text_start|_main:
    0979: 10       PUSH  X
    097A: 50 03    MOV   A,0x3
    097C: 7C 07 76 LCALL 0x0776
    097F: 20       POP   X
(0010) {
(0011)     //****************** Blocks Init
(0012) 	ADCINCVR_pot_Start(ADCINCVR_pot_HIGHPOWER);
(0013) 	ADCINCVR_mes_Start(ADCINCVR_mes_HIGHPOWER);
    0980: 10       PUSH  X
    0981: 50 03    MOV   A,0x3
    0983: 7C 08 BB LCALL 0x08BB
(0014) 	AMUX4_mic_Start();
    0986: 7C 06 ED LCALL 0x06ED
    0989: 20       POP   X
(0015) 	BPF4_4KHz_Start(BPF4_4KHz_HIGHPOWER);
    098A: 10       PUSH  X
    098B: 50 03    MOV   A,0x3
    098D: 7C 06 0B LCALL 0x060B
(0016) 	I2CHW_Start();
    0990: 7C 04 BB LCALL 0x04BB
    0993: 20       POP   X
(0017) 	PGA_out_Start(PGA_out_HIGHPOWER);
    0994: 10       PUSH  X
    0995: 50 03    MOV   A,0x3
    0997: 7C 04 7B LCALL 0x047B
    099A: 20       POP   X
(0018) 	PGA_pre_Start(PGA_pre_HIGHPOWER); 
    099B: 10       PUSH  X
    099C: 50 03    MOV   A,0x3
    099E: 7C 04 3B LCALL 0x043B
    09A1: 20       POP   X
(0019) 	PGA_pre_SetGain(PGA_pre_G1_00);
    09A2: 10       PUSH  X
    09A3: 50 F8    MOV   A,0xF8
    09A5: 7C 04 4D LCALL 0x044D
    09A8: 20       POP   X
(0020) 	RefMux_1_Start(RefMux_1_HIGHPOWER);
    09A9: 10       PUSH  X
    09AA: 50 03    MOV   A,0x3
    09AC: 7C 04 13 LCALL 0x0413
    09AF: 20       POP   X
(0021)     SCBLOCK_inbuff_Start(SCBLOCK_inbuff_HIGHPOWER);	
    09B0: 10       PUSH  X
    09B1: 50 03    MOV   A,0x3
    09B3: 7C 03 FB LCALL 0x03FB
    09B6: 20       POP   X
(0022) 	AMUX4_mic_InputSelect(AMUX4_mic_PORT0_1);
    09B7: 10       PUSH  X
    09B8: 50 00    MOV   A,0x0
    09BA: 7C 06 D2 LCALL 0x06D2
    09BD: 20       POP   X
(0023) 	while (1)
(0024) 	{
(0025) 	
(0026) 	}
    09BE: 8F FF    JMP   0x09BE
(0027) }
FILE: <library>
--------------------------------------------------------------------------------


PSoC Designer Version: 5.0.1127.0

Copyright (C) 1994 - 2009 ImageCraft Creations Inc.
ImageCraft, 706 Colorado Ave., Suite 10-88, Palo Alto, CA 94303
info@imagecraft.com, phone (650) 493-9326 FAX (650) 493-9329
http://www.imagecraft.com
lcc source code (C) 1995, by David R. Hanson and AT&T. Reproduced by permission.
Release version 7.02.004
